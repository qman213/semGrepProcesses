rules:
- id: csharp.lang.security.injections.os-command.os-command-injection
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (OS Command Injection)'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Command_Injection
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.injections.os-command.os-command-injection
  message: |
    The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.
  patterns:
  - pattern-inside: |
      using System.Diagnostics;
      ...
  - pattern-either:
    - pattern: |
        public $T $F($X)
        {
          ... Process.Start($X);
        }
    - pattern: |
        public $T $F($X)
        {
          ...
          Process $Y = new Process();

          $Y.StartInfo.FileName = $X;
          $Y.Start();
          ...
        }
    - pattern: |
        public $T $F($Y)
        {
          ...
          ProcessStartInfo $X = new ProcessStartInfo()
          {
            FileName = $Y
          };
          ...
          Process.Start($X);
        }
    - pattern: |
        public $T $F($Y)
        {
          ...
          ProcessStartInfo $X = new ProcessStartInfo()
          {
            FileName = @"python.exe",
            Arguments = $Y,
            UseShellExecute = false
          };
          ...
          Process.Start($X);
        }
- id: csharp.lang.security.insecure-deserialization.binary-formatter.insecure-binaryformatter-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.binary-formatter.insecure-binaryformatter-deserialization
  message: |
    The BinaryFormatter type is dangerous and is not recommended for data processing. Applications should stop using BinaryFormatter as soon as possible, even if they believe the data they're processing to be trustworthy. BinaryFormatter is insecure and can't be made secure
  patterns:
  - pattern-inside: |
      using System.Runtime.Serialization.Formatters.Binary;
      ...
  - pattern: |
      new BinaryFormatter();
- id: csharp.lang.security.insecure-deserialization.fast-json.insecure-fastjson-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://github.com/mgholam/fastJSON#security-warning-update
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.fast-json.insecure-fastjson-deserialization
  message: |
    $type extension has the potential to be unsafe, so use it with common sense and known json sources and not public facing ones to be safe
  patterns:
  - pattern-inside: |
      using fastJSON;
      ...
  - pattern: |
      new JSONParameters
      {
        BadListTypeChecking = false
      }
- id: csharp.lang.security.insecure-deserialization.fs-pickler.insecure-fspickler-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://mbraceproject.github.io/FsPickler/tutorial.html#Disabling-Subtype-Resolution
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.fs-pickler.insecure-fspickler-deserialization
  message: |
    The FsPickler is dangerous and is not recommended for data processing. Default configuration tend to insecure deserialization vulnerability.
  patterns:
  - pattern-inside: |
      using MBrace.FsPickler.Json;
      ...
  - pattern: |
      FsPickler.CreateJsonSerializer();
- id: csharp.lang.security.insecure-deserialization.javascript-serializer.insecure-javascriptserializer-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.microsoft.com/en-us/dotnet/api/system.web.script.serialization.simpletyperesolver?view=netframework-4.8#remarks
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.javascript-serializer.insecure-javascriptserializer-deserialization
  message: |
    The SimpleTypeResolver class is insecure and should not be used. Using SimpleTypeResolver to deserialize JSON could allow the remote client to execute malicious code within the app and take control of the web server.
  patterns:
  - pattern-inside: |
      using System.Web.Script.Serialization;
      ...
  - pattern: |
      new JavaScriptSerializer(new SimpleTypeResolver());
- id: csharp.lang.security.insecure-deserialization.los-formatter.insecure-losformatter-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.microsoft.com/en-us/dotnet/api/system.web.ui.losformatter?view=netframework-4.8
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.los-formatter.insecure-losformatter-deserialization
  message: |
    The LosFormatter type is dangerous and is not recommended for data processing. Applications should stop using LosFormatter as soon as possible, even if they believe the data they're processing to be trustworthy. LosFormatter is insecure and can't be made secure
  patterns:
  - pattern-inside: |
      using System.Web.UI;
      ...
  - pattern: |
      new LosFormatter();
- id: csharp.lang.security.insecure-deserialization.net-data-contract.insecure-netdatacontract-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.netdatacontractserializer?view=netframework-4.8#security
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.net-data-contract.insecure-netdatacontract-deserialization
  message: |
    The NetDataContractSerializer type is dangerous and is not recommended for data processing. Applications should stop using NetDataContractSerializer as soon as possible, even if they believe the data they're processing to be trustworthy. NetDataContractSerializer is insecure and can't be made secure
  patterns:
  - pattern-inside: |
      using System.Runtime.Serialization;
      ...
  - pattern: |
      new NetDataContractSerializer();
- id: csharp.lang.security.insecure-deserialization.newtonsoft.insecure-newtonsoft-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializer_TypeNameHandling.htm
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.newtonsoft.insecure-newtonsoft-deserialization
  message: |
    TypeNameHandling should be used with caution when your application deserializes JSON from an external source. Incoming types should be validated with a custom SerializationBinder when deserializing with a value other than None.
  patterns:
  - pattern-inside: |
      using Newtonsoft.Json;
      ...
  - pattern-either:
    - pattern: |
        new JsonSerializerSettings
        {
          TypeNameHandling = TypeNameHandling.All
        }
    - pattern: |
        new JsonSerializerSettings
        {
          TypeNameHandling = TypeNameHandling.Auto
        }
    - pattern: |
        new JsonSerializerSettings
        {
          TypeNameHandling = TypeNameHandling.Arrays
        }
    - pattern: |
        new JsonSerializerSettings
        {
          TypeNameHandling = TypeNameHandling.Objects
        }
- id: csharp.lang.security.insecure-deserialization.soap-formatter.insecure-soapformatter-deserialization
  severity: WARNING
  languages:
  - C#
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.soap.soapformatter?view=netframework-4.8#remarks
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/csharp.lang.security.insecure-deserialization.soap-formatter.insecure-soapformatter-deserialization
  message: |
    The SoapFormatter type is dangerous and is not recommended for data processing. Applications should stop using SoapFormatter as soon as possible, even if they believe the data they're processing to be trustworthy. SoapFormatter is insecure and can't be made secure
  patterns:
  - pattern-inside: |
      using System.Runtime.Serialization.Formatters.Soap;
      ...
  - pattern: |
      new SoapFormatter();
- id: go.gorilla.security.audit.handler-assignment-from-multiple-sources.handler-assignment-from-multiple-sources
  metadata:
    cwe: 'CWE-289: Authentication Bypass by Alternate Name'
    owasp: 'A2: Broken Authentication'
    owaspapi: 'API1: Broken Object Level Authorization'
    category: security
    technology:
    - gorilla
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.gorilla.security.audit.handler-assignment-from-multiple-sources.handler-assignment-from-multiple-sources
  patterns:
  - pattern-inside: |
      func $HANDLER(..., $R *http.Request, ...) {
        ...
      }
  - pattern-not: |
      $VAR = true
      ...
      $VAR = false
  - pattern-not: |
      $VAR = false
      ...
      $VAR = true
  - pattern-not: |
      $VAR = $X
      ...
      $VAR = $X
  - pattern-not: |
      $VAR = $X
      ...
      $VAR = $Z(..., $VAR, ...)
  - pattern-not: |
      $VAR = $X
      ...
      $VAR = $Z($W(..., $VAR, ...))
  - pattern-not: |
      $VAR = $X
      ...
      $VAR = $VAR[:$Z(..., $VAR, ...)]
  - pattern-not: |
      $VAR = $X
      ...
      $VAR = $VAR[$Z(..., $VAR, ...):]
  - pattern-not: |
      $VAR = $X
      ...
      $VAR = $VAR[$Z(..., $VAR, ...)]
  - pattern: |
      $VAR = $X
      ...
      $VAR = $Y
  message: 'Variable $VAR is assigned from two different sources: ''$X'' and ''$Y''.
    Make sure this is intended, as this could cause logic bugs if they are treated
    as they are the same object.'
  languages:
  - go
  severity: WARNING
- id: go.gorilla.security.audit.session-cookie-missing-httponly.session-cookie-missing-httponly
  patterns:
  - pattern-not-inside: |
      &sessions.Options{
        ...,
        HttpOnly: true,
        ...,
      }
  - pattern: |
      &sessions.Options{
        ...,
      }
  message: |
    A session cookie was detected without setting the 'HttpOnly' flag.
    The 'HttpOnly' flag for cookies instructs the browser to forbid
    client-side scripts from reading the cookie which mitigates XSS
    attacks. Set the 'HttpOnly' flag by setting 'HttpOnly' to 'true'
    in the Options struct.
  metadata:
    cwe: 'CWE-1004: Sensitive Cookie Without ''HttpOnly'' Flag'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/user/session/session.go#L69
    category: security
    technology:
    - gorilla
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.gorilla.security.audit.session-cookie-missing-httponly.session-cookie-missing-httponly
  fix-regex:
    regex: (HttpOnly\s*:\s+)false
    replacement: \1true
  severity: WARNING
  languages:
  - go
- id: go.gorilla.security.audit.session-cookie-missing-secure.session-cookie-missing-secure
  patterns:
  - pattern-not-inside: |
      &sessions.Options{
        ...,
        Secure: true,
        ...,
      }
  - pattern: |
      &sessions.Options{
        ...,
      }
  message: |
    A session cookie was detected without setting the 'Secure' flag.
    The 'secure' flag for cookies prevents the client from transmitting
    the cookie over insecure channels such as HTTP.  Set the 'Secure'
    flag by setting 'Secure' to 'true' in the Options struct.
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/user/session/session.go#L69
    category: security
    technology:
    - gorilla
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.gorilla.security.audit.session-cookie-missing-secure.session-cookie-missing-secure
  fix-regex:
    regex: (Secure\s*:\s+)false
    replacement: \1true
  severity: WARNING
  languages:
  - go
- id: go.jwt-go.security.audit.jwt-parse-unverified.jwt-go-parse-unverified
  message: |
    Detected the decoding of a JWT token without a verify step.
    Don't use `ParseUnverified` unless you know what you're doing
    This method parses the token but doesn't validate the signature. It's only ever useful in cases where you know the signature is valid (because it has been checked previously in the stack) and you want to extract values from it.
  metadata:
    cwe: 'CWE-345: Insufficient Verification of Data Authenticity'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.jwt-go.security.audit.jwt-parse-unverified.jwt-go-parse-unverified
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-inside: |
      import "github.com/dgrijalva/jwt-go"
      ...
  - pattern: |
      $JWT.ParseUnverified(...)
- id: go.jwt-go.security.jwt-none-alg.jwt-go-none-algorithm
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.jwt-go.security.jwt-none-alg.jwt-go-none-algorithm
  languages:
  - go
  severity: ERROR
  patterns:
  - pattern-inside: |
      import "github.com/dgrijalva/jwt-go"
      ...
  - pattern-either:
    - pattern: |
        jwt.SigningMethodNone
    - pattern: jwt.UnsafeAllowNoneSignatureType
- id: go.jwt-go.security.jwt.hardcoded-jwt-key
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.jwt-go.security.jwt.hardcoded-jwt-key
  pattern-either:
  - pattern: |
      $X = []byte("...")
      ...
      $Y := $TOKEN.SignedString($X)
  - pattern: |
      $TOKEN.SignedString([]byte("..."))
  message: JWT token is hardcoded
  languages:
  - go
  severity: WARNING
- id: go.lang.security.audit.crypto.bad_imports.insecure-module-used
  message: Detected use of an insecure cryptographic hashing method. This method is
    known to be broken and easily compromised. Use SHA256 or SHA3 instead.
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://godoc.org/golang.org/x/crypto/sha3
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.bad_imports.insecure-module-used
  languages:
  - go
  severity: WARNING
  pattern-either:
  - patterns:
    - pattern-inside: |
        import "crypto/md5"
        ...
    - pattern: |
        md5.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/des"
        ...
    - pattern: |
        des.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/sha1"
        ...
    - pattern: |
        sha1.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/rc4"
        ...
    - pattern: |
        rc4.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "net/http/cgi"
        ...
    - pattern: |
        cgi.$FUNC(...)
- id: go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
  message: |
    Disabled host key verification detected. This allows man-in-the-middle
    attacks. Use the 'golang.org/x/crypto/ssh/knownhosts' package to do
    host key verification.
    See https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    to learn more about the problem and how to fix it.
  metadata:
    cwe: 'CWE-322: Key Exchange without Entity Authentication'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    - https://gist.github.com/Skarlso/34321a230cf0245018288686c9e70b2d
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
  languages:
  - go
  severity: WARNING
  pattern: ssh.InsecureIgnoreHostKey()
- id: go.lang.security.audit.crypto.math_random.math-random-used
  metadata:
    cwe: 'CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.math_random.math-random-used
  message: Do not use `math/rand`. Use `crypto/rand` instead.
  languages:
  - go
  severity: WARNING
  pattern-either:
  - patterns:
    - pattern-inside: |
        import mrand "math/rand"
        ...
    - pattern-either:
      - pattern: mrand.Int()
      - pattern: mrand.Read(...)
  - patterns:
    - pattern-inside: |
        import "math/rand"
        ...
    - pattern-not-inside: |
        import "crypto/rand"
        ...
    - pattern-either:
      - pattern: rand.Int()
      - pattern: rand.Read(...)
- id: go.lang.security.audit.crypto.missing-ssl-minversion.missing-ssl-minversion
  message: |
    `MinVersion` is missing from this TLS configuration. The default
    value is TLS1.0 which is considered insecure. Explicitly set the
    `MinVersion` to a secure version of TLS, such as `VersionTLS13`.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go
    references:
    - https://golang.org/doc/go1.14#crypto/tls
    - https://golang.org/pkg/crypto/tls/#:~:text=MinVersion
    - https://www.us-cert.gov/ncas/alerts/TA14-290A
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.missing-ssl-minversion.missing-ssl-minversion
  languages:
  - go
  severity: ERROR
  patterns:
  - pattern: tls.Config{...}
  - pattern-not-inside: 'tls.Config{..., MinVersion: ..., ...}'
  fix-regex:
    regex: Config\s*\{
    replacement: 'Config{MinVersion: SSL.VersionTLS13,'
- id: go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
  message: |
    SSLv3 is insecure because it has known vulnerabilities.
    Starting with go1.14, SSLv3 will be removed. Instead, use
    'tls.VersionTLS13'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go
    references:
    - https://golang.org/doc/go1.14#crypto/tls
    - https://www.us-cert.gov/ncas/alerts/TA14-290A
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
  languages:
  - go
  severity: ERROR
  fix-regex:
    regex: VersionSSL30
    replacement: VersionTLS13
  pattern: 'tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}'
- id: go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
  message: |
    Detected an insecure CipherSuite via the 'tls' module. This suite is considered weak.
    Use the function 'tls.CipherSuites()' to get a list of good cipher suites.
    See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    for why and what other cipher suites to use.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls.go
    references:
    - https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 ,...}
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
  pattern-either:
  - pattern: |
      md5.New()
  - pattern: |
      md5.Sum(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
  pattern-either:
  - pattern: |
      sha1.New()
  - pattern: |
      sha1.Sum(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
  message: |
    Detected DES cipher algorithm which is insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
  pattern-either:
  - pattern: |
      des.NewTripleDESCipher(...)
  - pattern: |
      des.NewCipher(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
  message: |
    Detected RC4 cipher algorithm which is insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
  pattern: rc4.NewCipher(...)
- id: go.lang.security.audit.crypto.use_of_weak_rsa_key.use-of-weak-rsa-key
  message: RSA keys should be at least 2048 bits
  languages:
  - go
  severity: WARNING
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/rsa.go
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.crypto.use_of_weak_rsa_key.use-of-weak-rsa-key
  patterns:
  - pattern-either:
    - pattern: |
        rsa.GenerateKey(..., $BITS)
    - pattern: |
        rsa.GenerateMultiPrimeKey(..., $BITS)
  - metavariable-comparison:
      metavariable: $BITS
      comparison: $BITS < 2048
- id: go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd
  patterns:
  - pattern-either:
    - patterns:
      - pattern: |
          exec.Cmd {...,Path: $CMD,...}
      - pattern-not: |
          exec.Cmd {...,Path: "...",...}
      - pattern-not-inside: |
          $CMD,$ERR := exec.LookPath("...");
          ...
      - pattern-not-inside: |
          $CMD = "...";
          ...
    - patterns:
      - pattern: |
          exec.Cmd {...,Args: $ARGS,...}
      - pattern-not: |
          exec.Cmd {...,Args: []string{...},...}
      - pattern-not-inside: |
          $ARGS = []string{"...",...};
          ...
      - pattern-not-inside: |
          $CMD = "...";
          ...
          $ARGS = []string{$CMD,...};
          ...
      - pattern-not-inside: |
          $CMD = exec.LookPath("...");
          ...
          $ARGS = []string{$CMD,...};
          ...
    - patterns:
      - pattern: |
          exec.Cmd {...,Args: []string{$CMD,...},...}
      - pattern-not: |
          exec.Cmd {...,Args: []string{"...",...},...}
      - pattern-not-inside: |
          $CMD,$ERR := exec.LookPath("...");
          ...
      - pattern-not-inside: |
          $CMD = "...";
          ...
    - patterns:
      - pattern-either:
        - pattern: |
            exec.Cmd {...,Args: []string{"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$EXE,...},...}
        - patterns:
          - pattern: |
              exec.Cmd {...,Args: []string{$CMD,"-c",$EXE,...},...}
          - pattern-inside: |
              $CMD,$ERR := exec.LookPath("=~/(sh|bash|ksh|csh|tcsh|zsh)/");
              ...
      - pattern-not: |
          exec.Cmd {...,Args: []string{"...","...","...",...},...}
      - pattern-not-inside: |
          $EXE = "...";
          ...
  - pattern-inside: |
      import "os/exec"
      ...
  message: |
    Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.dangerous-exec-command.dangerous-exec-command
  patterns:
  - pattern-either:
    - patterns:
      - pattern-either:
        - pattern: |
            exec.Command($CMD,...)
        - pattern: |
            exec.CommandContext($CTX,$CMD,...)
      - pattern-not: |
          exec.Command("...",...)
      - pattern-not: |
          exec.CommandContext($CTX,"...",...)
    - patterns:
      - pattern-either:
        - pattern: |
            exec.Command("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$CMD,...)
        - pattern: |
            exec.CommandContext($CTX,"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$CMD,...)
      - pattern-not: |
          exec.Command("...","...","...",...)
      - pattern-not: |
          exec.CommandContext($CTX,"...","...","...",...)
  - pattern-inside: |
      import "os/exec"
      ...
  - pattern-not-inside: |
      $CMD,$ERR := exec.LookPath("...");
      ...
  - pattern-not-inside: |
      $CMD = "...";
      ...
  message: |
    Detected non-static command inside Command. Audit the input to 'exec.Command'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.dangerous-exec-command.dangerous-exec-command
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec
  patterns:
  - pattern-either:
    - patterns:
      - pattern: |
          syscall.$METHOD($BIN,...)
      - pattern-not: |
          syscall.$METHOD("...",...)
      - pattern-not-inside: |
          $BIN,$ERR := exec.LookPath("...");
          ...
      - pattern-not-inside: |
          $BIN = "...";
          ...
    - patterns:
      - pattern: |
          syscall.$METHOD($BIN,$ARGS,...)
      - pattern-not: |
          syscall.$METHOD($BIN,[]string{"...",...},...)
      - pattern-not-inside: |
          $ARGS := []string{"...",...};
          ...
      - pattern-not-inside: |
          $CMD = "...";
          ...
          $ARGS = []string{$CMD,...};
          ...
      - pattern-not-inside: |
          $CMD,$ERR := exec.LookPath("...");
          ...
          $ARGS = []string{$CMD,...};
          ...
    - patterns:
      - pattern: |
          syscall.$METHOD($BIN,[]string{"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$EXE,...},...)
      - pattern-not: |
          syscall.$METHOD($BIN,[]string{"...","...","...",...},...)
    - patterns:
      - pattern: |
          syscall.$METHOD($BIN,$ARGS,...)
      - pattern-either:
        - pattern-inside: |
            $ARGS := []string{"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$EXE,...};
            ...
        - pattern-inside: |
            $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/";
            ...
            $ARGS = []string{$CMD,"-c",$EXE,...};
            ...
        - pattern-inside: |
            $CMD,$ERR := exec.LookPath("=~/(sh|bash|ksh|csh|tcsh|zsh)/");
            ...
            $ARGS = []string{$CMD,"-c",$EXE,...};
            ...
      - pattern-not-inside: |
          $ARGS := []string{"...","...","...",...};
          ...
      - pattern-not-inside: |
          $CMD = "...";
          ...
          $ARGS = []string{$CMD,"...","...",...};
          ...
      - pattern-not-inside: |
          $CMD,$ERR := exec.LookPath("...");
          ...
          $ARGS = []string{$CMD,"...","...",...};
          ...
  - pattern-inside: |
      import "syscall"
      ...
  - metavariable-regex:
      metavariable: $METHOD
      regex: (Exec|ForkExec)
  message: |
    Detected non-static command inside Exec. Audit the input to 'syscall.Exec'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.database.string-formatted-query.string-formatted-query
  languages:
  - go
  message: |
    String-formatted SQL query detected. This could lead to SQL injection if
    the string is not sanitized properly. Audit this call to ensure the
    SQL is not manipulatable by external data.
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    source-rule-url: https://github.com/securego/gosec
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.database.string-formatted-query.string-formatted-query
  patterns:
  - pattern-not-inside: |
      $VAR = "..." + "..."
      ...
      $OBJ.$SINK(..., $VAR, ...)
  - pattern-not: $OBJ.Exec("...")
  - pattern-not: $OBJ.ExecContext($CTX, "...")
  - pattern-not: $OBJ.Query("...")
  - pattern-not: $OBJ.QueryContext($CTX, "...")
  - pattern-not: $OBJ.QueryRow("...")
  - pattern-not: $OBJ.QueryRow($CTX, "...")
  - pattern-not: $OBJ.QueryRowContext($CTX, "...")
  - pattern-either:
    - pattern: $OBJ.Exec($X + ...)
    - pattern: $OBJ.ExecContext($CTX, $X + ...)
    - pattern: $OBJ.Query($X + ...)
    - pattern: $OBJ.QueryContext($CTX, $X + ...)
    - pattern: $OBJ.QueryRow($X + ...)
    - pattern: $OBJ.QueryRow($CTX, $X + ...)
    - pattern: $OBJ.QueryRowContext($CTX, $X + ...)
    - pattern: $OBJ.Exec(fmt.$P("...", ...))
    - pattern: $OBJ.ExecContext($CTX, fmt.$P("...", ...))
    - pattern: $OBJ.Query(fmt.$P("...", ...))
    - pattern: $OBJ.QueryContext($CTX, fmt.$P("...", ...))
    - pattern: $OBJ.QueryRow(fmt.$P("...", ...))
    - pattern: $OBJ.QueryRow($CTX, fmt.$P("...", ...))
    - pattern: $OBJ.QueryRowContext($CTX, fmt.$P("...", ...))
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Exec($QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Query($QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.ExecContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($QUERY)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($CTX, $QUERY)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRowContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Exec($OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Query($OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.ExecContext($CTX, $OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryContext($CTX, $OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($OTHER)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($CTX, $OTHER)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRowContext($CTX, $OTHER, ...)
    - pattern: |
        $QUERY = $X + ...
        ...
        $OBJ.Exec($QUERY, ...)
    - pattern: |
        $QUERY = $X + ...
        ...
        $OBJ.Query($QUERY, ...)
    - pattern: |
        $QUERY = $X + ...
        ...
        $OBJ.ExecContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = $X + ...
        ...
        $OBJ.QueryContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = $X + ...
        ...
        $OBJ.QueryRow($QUERY)
    - pattern: |
        $QUERY = $X + ...
        ...
        $OBJ.QueryRow($CTX, $QUERY)
    - pattern: |
        $QUERY = $X + ...
        ...
        $OBJ.QueryRowContext($CTX, $QUERY, ...)
- id: go.lang.security.audit.net.bind_all.avoid-bind-to-all-interfaces
  message: Listening on 0.0.0.0 or empty string could unexpectedly expose the server
    publicly as it binds to all available interfaces
  languages:
  - go
  severity: WARNING
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/securego/gosec
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.bind_all.avoid-bind-to-all-interfaces
  pattern-either:
  - pattern: tls.Listen($NETWORK, "=~/^0.0.0.0:.*$/", ...)
  - pattern: net.Listen($NETWORK, "=~/^0.0.0.0:.*$/", ...)
  - pattern: tls.Listen($NETWORK, "=~/^:.*$/", ...)
  - pattern: net.Listen($NETWORK, "=~/^:.*$/", ...)
- id: go.lang.security.audit.net.cookie-missing-httponly.cookie-missing-httponly
  patterns:
  - pattern-not-inside: |
      http.Cookie{
        ...,
        HttpOnly: true,
        ...,
      }
  - pattern: |
      http.Cookie{
        ...,
      }
  message: |
    A session cookie was detected without setting the 'HttpOnly' flag.
    The 'HttpOnly' flag for cookies instructs the browser to forbid
    client-side scripts from reading the cookie which mitigates XSS
    attacks. Set the 'HttpOnly' flag by setting 'HttpOnly' to 'true'
    in the Cookie.
  metadata:
    cwe: 'CWE-1004: Sensitive Cookie Without ''HttpOnly'' Flag'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/util/cookie.go
    - https://golang.org/src/net/http/cookie.go
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.cookie-missing-httponly.cookie-missing-httponly
  fix-regex:
    regex: (HttpOnly\s*:\s+)false
    replacement: \1true
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.net.cookie-missing-secure.cookie-missing-secure
  patterns:
  - pattern-not-inside: |
      http.Cookie{
        ...,
        Secure: true,
        ...,
      }
  - pattern: |
      http.Cookie{
        ...,
      }
  message: |
    A session cookie was detected without setting the 'Secure' flag.
    The 'secure' flag for cookies prevents the client from transmitting
    the cookie over insecure channels such as HTTP.  Set the 'Secure'
    flag by setting 'Secure' to 'true' in the Options struct.
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/util/cookie.go
    - https://golang.org/src/net/http/cookie.go
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.cookie-missing-secure.cookie-missing-secure
  fix-regex:
    regex: (Secure\s*:\s+)false
    replacement: \1true
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
  message: |
    Detected a potentially dynamic ClientTrace. This occurred because semgrep could not
    find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because
    they deserialize function code to run when certain Request events occur, which could lead
    to code being run without your knowledge. Ensure that your ClientTrace is statically defined.
  metadata:
    cwe: 'CWE-913: Improper Control of Dynamically-Managed Code Resources'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://github.com/returntocorp/semgrep-rules/issues/518
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
  patterns:
  - pattern-not-inside: |
      ...
      &httptrace.ClientTrace { ... }
      ...
  - pattern: httptrace.WithClientTrace($ANY, $TRACE)
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.net.formatted-template-string.formatted-template-string
  message: |
    Found a formatted template string passed to 'template.HTML()'.
    'template.HTML()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template. If user data
    can reach this template, you may have a XSS vulnerability.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#HTML
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.formatted-template-string.formatted-template-string
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-not: template.HTML("..." + "...")
  - pattern-either:
    - pattern: template.HTML($T + $X, ...)
    - pattern: template.HTML(fmt.$P("...", ...), ...)
    - pattern: |
        $T = "..."
        ...
        $T = $FXN(..., $T, ...)
        ...
        template.HTML($T, ...)
    - pattern: |
        $T = fmt.$P("...", ...)
        ...
        template.HTML($T, ...)
    - pattern: |
        $T, $ERR = fmt.$P("...", ...)
        ...
        template.HTML($T, ...)
    - pattern: |
        $T = $X + $Y
        ...
        template.HTML($T, ...)
    - pattern: |
        $T = "..."
        ...
        $OTHER, $ERR = fmt.$P(..., $T, ...)
        ...
        template.HTML($OTHER, ...)
- id: go.lang.security.audit.net.pprof.pprof-debug-exposure
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/securego/gosec#available-rules
    references:
    - https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.pprof.pprof-debug-exposure
  message: |
    The profiling 'pprof' endpoint is automatically exposed on /debug/pprof.
    This could leak information about the server.
    Instead, use `import "net/http/pprof"`. See
    https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    for more information and mitigation.
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-inside: |
      import _ "net/http/pprof"
      ...
  - pattern-inside: |
      func $ANY(...) {
        ...
      }
  - pattern-not: http.ListenAndServe("=~/^localhost.*/", ...)
  - pattern-not: http.ListenAndServe("=~/^127[.]0[.]0[.]1.*/", ...)
  - pattern: http.ListenAndServe(...)
- id: go.lang.security.audit.net.unescaped-data-in-htmlattr.unescaped-data-in-htmlattr
  message: |
    Found a formatted template string passed to 'template.HTMLAttr()'.
    'template.HTMLAttr()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#HTMLAttr
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.unescaped-data-in-htmlattr.unescaped-data-in-htmlattr
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: template.HTMLAttr($T + $X, ...)
  - pattern: template.HTMLAttr(fmt.$P("...", ...), ...)
  - pattern: |
      $T = "..."
      ...
      $T = $FXN(..., $T, ...)
      ...
      template.HTMLAttr($T, ...)
  - pattern: |
      $T = fmt.$P("...", ...)
      ...
      template.HTMLAttr($T, ...)
  - pattern: |
      $T, $ERR = fmt.$P("...", ...)
      ...
      template.HTMLAttr($T, ...)
  - pattern: |
      $T = $X + $Y
      ...
      template.HTMLAttr($T, ...)
  - pattern: |
      $T = "..."
      ...
      $OTHER, $ERR = fmt.$P(..., $T, ...)
      ...
      template.HTMLAttr($OTHER, ...)
- id: go.lang.security.audit.net.unescaped-data-in-js.unescaped-data-in-js
  message: |
    Found a formatted template string passed to 'template.JS()'.
    'template.JS()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#JS
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.unescaped-data-in-js.unescaped-data-in-js
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: template.JS($T + $X, ...)
  - pattern: template.JS(fmt.$P("...", ...), ...)
  - pattern: |
      $T = "..."
      ...
      $T = $FXN(..., $T, ...)
      ...
      template.JS($T, ...)
  - pattern: |
      $T = fmt.$P("...", ...)
      ...
      template.JS($T, ...)
  - pattern: |
      $T, $ERR = fmt.$P("...", ...)
      ...
      template.JS($T, ...)
  - pattern: |
      $T = $X + $Y
      ...
      template.JS($T, ...)
  - pattern: |
      $T = "..."
      ...
      $OTHER, $ERR = fmt.$P(..., $T, ...)
      ...
      template.JS($OTHER, ...)
- id: go.lang.security.audit.net.unescaped-data-in-url.unescaped-data-in-url
  message: |
    Found a formatted template string passed to 'template.URL()'.
    'template.URL()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#URL
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.unescaped-data-in-url.unescaped-data-in-url
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: template.URL($T + $X, ...)
  - pattern: template.URL(fmt.$P("...", ...), ...)
  - pattern: |
      $T = "..."
      ...
      $T = $FXN(..., $T, ...)
      ...
      template.URL($T, ...)
  - pattern: |
      $T = fmt.$P("...", ...)
      ...
      template.URL($T, ...)
  - pattern: |
      $T, $ERR = fmt.$P("...", ...)
      ...
      template.URL($T, ...)
  - pattern: |
      $T = $X + $Y
      ...
      template.URL($T, ...)
  - pattern: |
      $T = "..."
      ...
      $OTHER, $ERR = fmt.$P(..., $T, ...)
      ...
      template.URL($OTHER, ...)
- id: go.lang.security.audit.net.use-tls.use-tls
  pattern: http.ListenAndServe($ADDR, $HANDLER)
  fix: http.ListenAndServeTLS($ADDR, certFile, keyFile, $HANDLER)
  metadata:
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://golang.org/pkg/net/http/#ListenAndServeTLS
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.use-tls.use-tls
  message: Found an HTTP server without TLS. Use 'http.ListenAndServeTLS' instead.
    See https://golang.org/pkg/net/http/#ListenAndServeTLS for more information.
  languages:
  - go
  severity: WARNING
- id: go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
  patterns:
  - pattern-inside: |
      func $FUNC(..., $W http.ResponseWriter, ...) {
          ...
      }
  - pattern-inside: |
      ...
      var $T = "..."
      ...
      $W.Write([]byte(fmt.$PRINTF($T, ...)), ...)
  - pattern-either:
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))
  message: |
    Found data going from url query parameters into formatted data written to ResponseWriter.
    This could be XSS and should not be done. If you must do this, ensure your data is
    sanitized or escaped.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.reflect-makefunc.reflect-makefunc
  message: |
    'reflect.MakeFunc' detected. This will sidestep protections that are
    normally afforded by Go's type system. Audit this call and be sure that
    user input cannot be used to affect the code generated by MakeFunc;
    otherwise, you will have a serious security vulnerability.
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-913: Improper Control of Dynamically-Managed Code Resources'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.reflect-makefunc.reflect-makefunc
  severity: WARNING
  pattern: reflect.MakeFunc(...)
  languages:
  - go
- id: go.lang.security.audit.unsafe-reflect-by-name.unsafe-reflect-by-name
  patterns:
  - pattern-either:
    - pattern: |
        $SMTH.MethodByName($NAME,...)
    - pattern: |
        $SMTH.FieldByName($NAME,...)
  - pattern-not: |
      $SMTH.MethodByName("...",...)
  - pattern-not: |
      $SMTH.FieldByName("...",...)
  - pattern-inside: |
      import "reflect"
      ...
  message: |
    If an attacker can supply values that the application then uses to determine which method or field to invoke,
    the potential exists for the attacker to create control flow paths through the application
    that were not intended by the application developers.
    This attack vector may allow the attacker to bypass authentication or access control checks
    or otherwise cause the application to behave in an unexpected manner.
  metadata:
    cwe: 'CWE-470: Use of Externally-Controlled Input to Select Classes or Code (''Unsafe
      Reflection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.unsafe-reflect-by-name.unsafe-reflect-by-name
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.xss.import-text-template.import-text-template
  message: |
    'text/template' does not escape HTML content. If you need
    to escape HTML content, use 'html/template' instead.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://www.veracode.com/blog/secure-development/use-golang-these-mistakes-could-compromise-your-apps-security
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.xss.import-text-template.import-text-template
  severity: WARNING
  pattern: |
    import "text/template"
  languages:
  - go
- id: go.lang.security.audit.xss.no-direct-write-to-responsewriter.no-direct-write-to-responsewriter
  languages:
  - go
  message: |
    Detected directly writing or similar in 'http.ResponseWriter.write()'.
    This bypasses HTML escaping that prevents cross-site scripting
    vulnerabilities. Instead, use the 'html/template' package
    and render data using 'template.Execute()'.
  metadata:
    category: security
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/
    source: https://semgrep.dev/r/go.lang.security.audit.xss.no-direct-write-to-responsewriter.no-direct-write-to-responsewriter
  patterns:
  - pattern-either:
    - pattern-inside: |
        func $HANDLER(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
    - pattern-inside: |
        func $HANDLER(..., $WRITER *http.ResponseWriter, ...) {
          ...
        }
    - pattern-inside: |
        func(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
  - pattern-either:
    - pattern: $WRITER.Write(...)
    - pattern: (*$WRITER).Write(...)
  - pattern-not: $WRITER.Write([]byte("..."))
  severity: WARNING
- id: go.lang.security.audit.xss.no-fprintf-to-responsewriter.no-fprintf-to-responsewriter
  message: |
    Detected 'Fprintf' or similar writing to 'http.ResponseWriter'.
    This bypasses HTML escaping that prevents cross-site scripting
    vulnerabilities. Instead, use the 'html/template' package
    to render data to users.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.xss.no-fprintf-to-responsewriter.no-fprintf-to-responsewriter
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern-inside: |
        func $HANDLER(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
    - pattern-inside: |
        func(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
  - pattern-not: fmt.$PRINTF($WRITER, "...")
  - pattern: fmt.$PRINTF($WRITER, ...)
  languages:
  - go
- id: go.lang.security.audit.xss.no-interpolation-in-tag.no-interpolation-in-tag
  message: |
    Detected template variable interpolation in an HTML tag.
    This is potentially vulnerable to cross-site scripting (XSS)
    attacks because a malicious actor has control over HTML
    but without the need to use escaped characters. Use explicit
    tags instead.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://github.com/golang/go/issues/19669
    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.xss.no-interpolation-in-tag.no-interpolation-in-tag
  languages:
  - generic
  severity: WARNING
  pattern: <{{ ... }} ... >
- id: go.lang.security.audit.xss.no-interpolation-js-template-string.no-interpolation-js-template-string
  message: Detected template variable interpolation in a JavaScript template string.
    This is potentially vulnerable to cross-site scripting (XSS) attacks because a
    malicious actor has control over JavaScript but without the need to use escaped
    characters. Instead, obtain this variable outside of the template string and ensure
    your template is properly escaped.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://github.com/golang/go/issues/9200#issuecomment-66100328
    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.xss.no-interpolation-js-template-string.no-interpolation-js-template-string
  languages:
  - generic
  severity: WARNING
  patterns:
  - pattern-inside: <script ...> ... ... ... ... ... </script>
  - pattern: '` ... {{ ... }} ...`'
- id: go.lang.security.audit.xss.no-io-writestring-to-responsewriter.no-io-writestring-to-responsewriter
  message: |
    Detected 'io.WriteString()' writing directly to 'http.ResponseWriter'.
    This bypasses HTML escaping that prevents cross-site scripting
    vulnerabilities. Instead, use the 'html/template' package
    to render data to users.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/
    - https://golang.org/pkg/io/#WriteString
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.xss.no-io-writestring-to-responsewriter.no-io-writestring-to-responsewriter
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern-inside: |
        func $HANDLER(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
    - pattern-inside: |
        func(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
  - pattern-not: io.WriteString($WRITER, "...")
  - pattern: io.WriteString($WRITER, $STRING)
  languages:
  - go
- id: go.lang.security.audit.xss.no-printf-in-responsewriter.no-printf-in-responsewriter
  message: |
    Detected 'printf' or similar in 'http.ResponseWriter.write()'.
    This bypasses HTML escaping that prevents cross-site scripting
    vulnerabilities. Instead, use the 'html/template' package
    to render data to users.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.xss.no-printf-in-responsewriter.no-printf-in-responsewriter
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern-inside: |
        func $HANDLER(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
    - pattern-inside: |
        func(..., $WRITER http.ResponseWriter, ...) {
          ...
        }
  - pattern: |
      $WRITER.Write(<... fmt.$PRINTF(...) ...>, ...)
  languages:
  - go
- id: go.lang.security.audit.xss.template-html-does-not-escape.unsafe-template-type
  message: |
    Semgrep could not determine that the argument to 'template.HTML()'
    is a constant. 'template.HTML()' and similar does not escape contents.
    Be absolutely sure there is no user-controlled data in this
    template. If user data can reach this template, you may have
    a XSS vulnerability. Instead, do not use this function and
    use 'template.Execute()'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://golang.org/pkg/html/template/#HTML
    - https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/vulnerability/xss/xss.go#L33
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.lang.security.audit.xss.template-html-does-not-escape.unsafe-template-type
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-not: template.$ANY("..." + "...")
  - pattern-not: template.$ANY("...")
  - pattern-either:
    - pattern: template.HTML(...)
    - pattern: template.CSS(...)
    - pattern: template.HTMLAttr(...)
    - pattern: template.JS(...)
    - pattern: template.JSStr(...)
    - pattern: template.Srcset(...)
    - pattern: template.URL(...)
- id: go.otto.security.audit.dangerous-execution.dangerous-execution
  message: |
    Detected non-static script inside otto VM. Audit the input to 'VM.Run'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - otto
    - vm
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/go.otto.security.audit.dangerous-execution.dangerous-execution
  severity: WARNING
  patterns:
  - pattern-inside: |
      $VM = otto.New(...)
      ...
  - pattern-not: $VM.Run("...", ...)
  - pattern: $VM.Run(...)
  languages:
  - go
- id: java.java-jwt.security.audit.jwt-decode-without-verify.java-jwt-decode-without-verify
  message: |
    Detected the decoding of a JWT token without a verify step.
    JWT tokens must be verified before use, otherwise the token's
    integrity is unknown. This means a malicious actor could forge
    a JWT token with any claims. Call '.verify()' before using the token.
  metadata:
    cwe: 'CWE-345: Insufficient Verification of Data Authenticity'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.java-jwt.security.audit.jwt-decode-without-verify.java-jwt-decode-without-verify
  languages:
  - java
  severity: WARNING
  patterns:
  - pattern: |
      com.auth0.jwt.JWT.decode(...);
  - pattern-not-inside: |-
      class $CLASS {
        ...
        $RETURNTYPE $FUNC (...) {
          ...
          $VERIFIER.verify(...);
          ...
        }
      }
- id: java.java-jwt.security.jwt-hardcode.java-jwt-hardcoded-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.java-jwt.security.jwt-hardcode.java-jwt-hardcoded-secret
  languages:
  - java
  severity: ERROR
  pattern-either:
  - pattern: |
      com.auth0.jwt.algorithms.Algorithm.HMAC256("...");
  - pattern: |
      $SECRET = "...";
      ...
      com.auth0.jwt.algorithms.Algorithm.HMAC256($SECRET);
  - pattern: |
      class $CLASS {
        ...
        $TYPE $SECRET = "...";
        ...
        $RETURNTYPE $FUNC (...) {
          ...
          com.auth0.jwt.algorithms.Algorithm.HMAC256($SECRET);
          ...
        }
        ...
      }
  - pattern: |
      com.auth0.jwt.algorithms.Algorithm.HMAC384("...");
  - pattern: |
      $SECRET = "...";
      ...
      com.auth0.jwt.algorithms.Algorithm.HMAC384($SECRET);
  - pattern: |
      class $CLASS {
        ...
        $TYPE $SECRET = "...";
        ...
        $RETURNTYPE $FUNC (...) {
          ...
          com.auth0.jwt.algorithms.Algorithm.HMAC384($SECRET);
          ...
        }
        ...
      }
  - pattern: |
      com.auth0.jwt.algorithms.Algorithm.HMAC512("...");
  - pattern: |
      $SECRET = "...";
      ...
      com.auth0.jwt.algorithms.Algorithm.HMAC512($SECRET);
  - pattern: |
      class $CLASS {
        ...
        $TYPE $SECRET = "...";
        ...
        $RETURNTYPE $FUNC (...) {
          ...
          com.auth0.jwt.algorithms.Algorithm.HMAC512($SECRET);
          ...
        }
        ...
      }
- id: java.java-jwt.security.jwt-none-alg.java-jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.java-jwt.security.jwt-none-alg.java-jwt-none-alg
  languages:
  - java
  severity: ERROR
  pattern-either:
  - pattern: |
      $JWT.sign(com.auth0.jwt.algorithms.Algorithm.none());
  - pattern: |
      $NONE = com.auth0.jwt.algorithms.Algorithm.none();
      ...
      $JWT.sign($NONE);
  - pattern: |-
      class $CLASS {
        ...
        $TYPE $NONE = com.auth0.jwt.algorithms.Algorithm.none();
        ...
        $RETURNTYPE $FUNC (...) {
          ...
          $JWT.sign($NONE);
          ...
        }
        ...
      }
- id: java.jax-rs.security.insecure-resteasy.insecure-resteasy-deserialization
  severity: WARNING
  languages:
  - java
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://access.redhat.com/blogs/766093/posts/3162112
    category: security
    technology:
    - jax-rs
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.jax-rs.security.insecure-resteasy.insecure-resteasy-deserialization
  message: |
    When a Restful webservice endpoint is configured to use wildcard mediaType {*/*} as a value for the @Consumes annotation, an attacker could abuse the SerializableProvider by sending a HTTP Request with a Content-Type of application/x-java-serialized-object. The body of that request would be processed by the SerializationProvider and could contain a malicious payload, which may lead to arbitrary code execution when calling the $Y.getObject method.
  pattern-either:
  - pattern: |
      @Consumes({"application/x-java-serialized-object"})
  - pattern: |
      @Consumes({"*/*"})
  - pattern: |
      @Consumes("*/*")
  - pattern: |
      @Consumes({MediaType.WILDCARD_TYPE})
- id: java.jax-rs.security.insecure-resteasy.default-resteasy-provider-abuse
  severity: WARNING
  languages:
  - java
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://access.redhat.com/blogs/766093/posts/3162112
    category: security
    technology:
    - jax-rs
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.jax-rs.security.insecure-resteasy.default-resteasy-provider-abuse
  message: |
    When a Restful webservice endpoint isn't configured with a @Consumes annotation, an attacker could abuse the SerializableProvider by sending a HTTP Request with a Content-Type of application/x-java-serialized-object. The body of that request would be processed by the SerializationProvider and could contain a malicious payload, which may lead to arbitrary code execution.
  patterns:
  - pattern: |
      @Path("...")
      public $RETURNTYPE $METHOD(...) { ...}
  - pattern-not-inside: |
      @Path("...")
      @Consumes(...)
      public $RETURNTYPE $METHOD(...) { ...}
- id: java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
    category: security
    technology:
    - jax-rs
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      $RETURNTYPE $FUNC (..., @PathParam(...) $TYPE $VAR, ...) {
        ...
        new File(..., $VAR, ...);
        ...
      }
  - pattern: |-
      $RETURNTYPE $FUNC (..., @javax.ws.rs.PathParam(...) $TYPE $VAR, ...) {
        ...
        new File(..., $VAR, ...);
        ...
      }
- id: java.jboss.security.seam-log-injection.seam-log-injection
  patterns:
  - pattern: |
      $LOG.$INFO($X + $Y,...)
  - pattern-either:
    - pattern-inside: |
        import org.jboss.seam.log.Log;
        ...
    - pattern-inside: |
        org.jboss.seam.log.Log $LOG = ...;
        ...
  - metavariable-regex:
      metavariable: $INFO
      regex: (debug|error|fatal|info|trace|warn)
  languages:
  - java
  message: |
    Seam Logging API support an expression language to introduce bean property to log messages.
    The expression language can also be the source to unwanted code execution.
    In this context, an expression is built with a dynamic value.
    The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SEAM_LOG_INJECTION
    category: security
    technology:
    - jboss
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.jboss.security.seam-log-injection.seam-log-injection
  severity: ERROR
- id: java.jjwt.security.jwt-none-alg.jjwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.3 Insecue Stateless Session Tokens
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.jjwt.security.jwt-none-alg.jjwt-none-alg
  languages:
  - java
  severity: ERROR
  patterns:
  - pattern: |
      io.jsonwebtoken.Jwts.builder();
  - pattern-not-inside: |-
      $RETURNTYPE $FUNC(...) {
        ...
        $JWTS.signWith(...);
        ...
      }
- id: java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind
  metadata:
    cwe: 'CWE-287: Improper Authentication'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_ANONYMOUS
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind
  message: |
    Detected anonymous LDAP bind.
    This permits anonymous users to execute LDAP statements. Consider enforcing
    authentication for LDAP. See https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html
    for more information.
  severity: WARNING
  pattern: |
    $ENV.put($CTX.SECURITY_AUTHENTICATION, "none");
    ...
    $DCTX = new InitialDirContext($ENV, ...);
  languages:
  - java
- id: java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion
  metadata:
    cwe: 'CWE-704: Incorrect Type Conversion or Cast'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion
  message: |
    'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte.
    This mistake weakens the hash value computed since it introduces more collisions.
    Use 'String.format("%02X", ...)' instead.
  severity: WARNING
  languages:
  - java
  pattern: |-
    $X $METHOD(...) {
      ...
      MessageDigest $MD = ...;
      ...
      $MD.digest(...);
      ...
      Integer.toHexString(...);
    }
- id: java.lang.security.audit.blowfish-insufficient-key-size.blowfish-insufficient-key-size
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#BLOWFISH_KEY_SIZE
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.blowfish-insufficient-key-size.blowfish-insufficient-key-size
  message: |
    Using less than 128 bits for Blowfish is considered insecure. Use 128 bits
    or more, or switch to use AES instead.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern: |
      $KEYGEN = KeyGenerator.getInstance("Blowfish");
      ...
      $KEYGEN.init($SIZE);
  - metavariable-comparison:
      metavariable: $SIZE
      comparison: $SIZE < 128
- id: java.lang.security.audit.cbc-padding-oracle.cbc-padding-oracle
  message: |
    Using CBC with PKCS5Padding is susceptible to padding orcale attacks. A malicious actor
    could discern the difference between plaintext with valid or invalid padding. Further,
    CBC mode does not include any integrity checks. See https://find-sec-bugs.github.io/bugs.htm#CIPHER_INTEGRITY.
    Use 'AES/GCM/NoPadding' instead.
  metadata:
    cwe: 'CWE-696: Incorrect Behavior Order'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PADDING_ORACLE
    references:
    - https://capec.mitre.org/data/definitions/463.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.cbc-padding-oracle.cbc-padding-oracle
  severity: WARNING
  fix: $CIPHER.getInstance("AES/GCM/NoPadding");
  languages:
  - java
  pattern: $CIPHER.getInstance("=~/.*\/CBC\/PKCS5Padding/");
- id: java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call
  patterns:
  - pattern-either:
    - pattern: $RUNTIME.exec($X + $Y);
    - pattern: $RUNTIME.exec(String.format(...));
    - pattern: $RUNTIME.loadLibrary($X + $Y);
    - pattern: $RUNTIME.loadLibrary(String.format(...));
    - patterns:
      - pattern-either:
        - pattern: |
            $RUNTIME.exec("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...)
        - pattern: |
            $RUNTIME.exec(Arrays.asList("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...),...)
        - pattern: |
            $RUNTIME.exec(new String[]{"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...},...)
        - patterns:
          - pattern-either:
            - pattern: |
                $RUNTIME.exec($CMD,"-c",$ARG,...)
            - pattern: |
                $RUNTIME.exec(Arrays.asList($CMD,"-c",$ARG,...),...)
            - pattern: |
                $RUNTIME.exec(new String[]{$CMD,"-c",$ARG,...},...)
          - pattern-inside: |
              $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/";
              ...
      - pattern-not-inside: |
          $ARG = "...";
          ...
      - pattern-not: |
          $RUNTIME.exec("...","...","...",...)
      - pattern-not: |
          $RUNTIME.exec(new String[]{"...","...","...",...},...)
      - pattern-not: |
          $RUNTIME.exec(Arrays.asList("...","...","...",...),...)
  - pattern-inside: |
      $TYPE $RUNTIME = Runtime.getRuntime(...);
      ...
  message: |
    A formatted or concatenated string was detected as input to a java.lang.Runtime call.
    This is dangerous if a variable is controlled by user input and could result in a
    command injection. Ensure your variables are not controlled by users or sufficiently sanitized.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
  pattern-either:
  - patterns:
    - pattern: |
        new ProcessBuilder($CMD,...)
    - pattern-not-inside: |
        $CMD = "...";
        ...
    - pattern-not-inside: |
        $CMD = Arrays.asList("...",...);
        ...
    - pattern-not-inside: |
        $CMD = new String[]{"...",...};
        ...
    - pattern-not: |
        new ProcessBuilder("...",...)
    - pattern-not: |
        new ProcessBuilder(new String[]{"...",...},...)
    - pattern-not: |
        new ProcessBuilder(Arrays.asList("...",...),...)
  - patterns:
    - pattern: |
        $PB.command($CMD,...)
    - pattern-inside: |
        $TYPE $PB = new ProcessBuilder(...);
        ...
    - pattern-not-inside: |
        $CMD = "...";
        ...
    - pattern-not-inside: |
        $CMD = Arrays.asList("...",...);
        ...
    - pattern-not-inside: |
        $CMD = new String[]{"...",...};
        ...
    - pattern-not: |
        $PB.command("...",...)
    - pattern-not: |
        $PB.command(new String[]{"...",...},...)
    - pattern-not: |
        $PB.command(Arrays.asList("...",...),...)
  - patterns:
    - pattern-either:
      - pattern: |
          new ProcessBuilder("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...)
      - pattern: |
          new ProcessBuilder(Arrays.asList("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...),...)
      - pattern: |
          new ProcessBuilder(new String[]{"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...},...)
      - patterns:
        - pattern-either:
          - pattern: |
              new ProcessBuilder($CMD,"-c",$ARG,...)
          - pattern: |
              new ProcessBuilder(Arrays.asList($CMD,"-c",$ARG,...),...)
          - pattern: |
              new ProcessBuilder(new String[]{$CMD,"-c",$ARG,...},...)
        - pattern-inside: |
            $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/";
            ...
    - pattern-not-inside: |
        $ARG = "...";
        ...
    - pattern-not: |
        new ProcessBuilder("...","...","...",...)
    - pattern-not: |
        new ProcessBuilder(new String[]{"...","...","...",...},...)
    - pattern-not: |
        new ProcessBuilder(Arrays.asList("...","...","...",...),...)
  - patterns:
    - pattern-either:
      - pattern: |
          $PB.command("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...)
      - pattern: |
          $PB.command(Arrays.asList("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...),...)
      - pattern: |
          $PB.command(new String[]{"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...},...)
      - patterns:
        - pattern-either:
          - pattern: |
              $PB.command($CMD,"-c",$ARG,...)
          - pattern: |
              $PB.command(Arrays.asList($CMD,"-c",$ARG,...),...)
          - pattern: |
              $PB.command(new String[]{$CMD,"-c",$ARG,...},...)
        - pattern-inside: |
            $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/";
            ...
    - pattern-inside: |
        $TYPE $PB = new ProcessBuilder(...);
        ...
    - pattern-not-inside: |
        $ARG = "...";
        ...
    - pattern-not: |
        $PB.command("...","...","...",...)
    - pattern-not: |
        $PB.command(new String[]{"...","...","...",...},...)
    - pattern-not: |
        $PB.command(Arrays.asList("...","...","...",...),...)
  message: |
    A formatted or concatenated string was detected as input to a ProcessBuilder call.
    This is dangerous if a variable is controlled by user input and could result in a
    command injection. Ensure your variables are not controlled by users or sufficiently sanitized.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.command-injection-process-builder.command-injection-process-builder
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly
  metadata:
    cwe: 'CWE-1004: Sensitive Cookie Without ''HttpOnly'' Flag'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.4.2 Missing Cookie Attribute
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly
  message: |
    A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag
    for cookies instructs the browser to forbid client-side scripts from reading the
    cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not-inside: $COOKIE.setValue(""); ...
  - pattern-either:
    - pattern: $COOKIE.setHttpOnly(false);
    - patterns:
      - pattern-not-inside: $COOKIE.setHttpOnly(...); ...
      - pattern: $RESPONSE.addCookie($COOKIE);
- id: java.lang.security.audit.cookie-missing-samesite.cookie-missing-samesite
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.4.3 Missing Cookie Attribute
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management
      version: '4'
    references:
    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.cookie-missing-samesite.cookie-missing-samesite
  message: |
    Detected cookie without the SameSite attribute.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not-inside: |
      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {
        ...
        $RESP.setHeader("Set-Cookie", "=~/.*SameSite=.*/");
        ...
      }
  - pattern-either:
    - pattern: $RESP.addCookie(...);
    - pattern: $RESP.setHeader("Set-Cookie", ...);
- id: java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_COOKIE
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.4.1 Missing Cookie Attribute
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag
  message: |
    A cookie was detected without setting the 'secure' flag. The 'secure' flag
    for cookies prevents the client from transmitting the cookie over insecure
    channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not-inside: $COOKIE.setValue(""); ...
  - pattern-either:
    - pattern: $COOKIE.setSecure(false);
    - patterns:
      - pattern-not-inside: $COOKIE.setSecure(...); ...
      - pattern: $RESPONSE.addCookie($COOKIE);
- id: java.lang.security.audit.crlf-injection-logs.crlf-injection-logs
  message: |
    When data from an untrusted source is put into a logger and not neutralized correctly,
    an attacker could forge log entries or include malicious content.
  metadata:
    cwe: 'CWE-93: Improper Neutralization of CRLF Sequences (''CRLF Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#CRLF_INJECTION_LOGS
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crlf-injection-logs.crlf-injection-logs
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          class $CLASS {
            ...
            Logger $LOG = ...;
            ...
          }
      - pattern-either:
        - pattern-inside: |
            $X $METHOD(...,HttpServletRequest $REQ,...) {
              ...
            }
        - pattern-inside: |
            $X $METHOD(...,ServletRequest $REQ,...) {
              ...
            }
        - pattern-inside: |
            $X $METHOD(...) {
              ...
              HttpServletRequest $REQ = ...;
              ...
            }
        - pattern-inside: |
            $X $METHOD(...) {
              ...
              ServletRequest $REQ = ...;
              ...
            }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          Logger $LOG = ...;
          ...
          HttpServletRequest $REQ = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          Logger $LOG = ...;
          ...
          ServletRequest $REQ = ...;
          ...
        }
  - pattern-either:
    - pattern: |
        String $VAL = $REQ.getParameter(...);
        ...
        $LOG.$LEVEL(<... $VAL ...>);
    - pattern: |
        String $VAL = $REQ.getParameter(...);
        ...
        $LOG.log($LEVEL,<... $VAL ...>);
    - pattern: |
        $LOG.$LEVEL(<... $REQ.getParameter(...) ...>);
    - pattern: |
        $LOG.log($LEVEL,<... $REQ.getParameter(...) ...>);
- id: java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated
  message: |
    Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher.
    Upgrade to use AES.
    See https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA for more information.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
    references:
    - https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated
  severity: WARNING
  pattern: $CIPHER.getInstance("=~/DESede.*/");
  fix: Cipher.getInstance("AES/GCM/NoPadding");
  languages:
  - java
- id: java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
  message: |
    DES is considered deprecated. AES is the recommended cipher.
    Upgrade to use AES.
    See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DES_USAGE
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    references:
    - https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard
    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
  severity: WARNING
  pattern: $CIPHER.getInstance("=~/DES/.*/");
  fix: $CIPHER.getInstance("AES/GCM/NoPadding");
  languages:
  - java
- id: java.lang.security.audit.crypto.ecb-cipher.ecb-cipher
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#ECB_MODE
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.ecb-cipher.ecb-cipher
  message: |
    Cipher in ECB mode is detected. ECB mode produces the same output for the same input each time
    which allows an attacker to intercept and replay the data. Further, ECB mode does not provide
    any integrity checking. See https://find-sec-bugs.github.io/bugs.htm#CIPHER_INTEGRITY.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern: |
      Cipher $VAR = $CIPHER.getInstance($MODE);
  - metavariable-regex:
      metavariable: $MODE
      regex: .*ECB.*
- id: java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
  pattern: new NullCipher(...);
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
  message: |
    NullCipher was detected. This will not encrypt anything;
    the cipher text will be the same as the plain text. Use
    a valid, secure cipher: Cipher.getInstance("AES/CBC/PKCS7PADDING").
    See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions
    for more information.
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
  message: |
    Initialization Vectors (IVs) for block ciphers should be randomly generated
    each time they are used. Using a static IV means the same plaintext
    encrypts to the same ciphertext every time, weakening the strength
    of the encryption.
  metadata:
    cwe: 'CWE-329: Not Using a Random IV with CBC Mode'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#STATIC_IV
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    references:
    - https://cwe.mitre.org/data/definitions/329.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      byte[] $IV = {
          ...
      };
      ...
      new IvParameterSpec($IV, ...);
  - pattern: |
      class $CLASS {
          byte[] $IV = {
              ...
          };
          ...
          $METHOD(...) {
              ...
              new IvParameterSpec($IV, ...);
              ...
          }
      }
- id: java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#RSA_NO_PADDING
    references:
    - https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding
  message: |
    Using RSA without OAEP mode weakens the encryption.
  severity: WARNING
  languages:
  - java
  pattern: $CIPHER.getInstance("RSA/NONE/NoPadding")
- id: java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#CUSTOM_MESSAGE_DIGEST
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.2 Insecure Custom Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#custom-algorithms
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests
  message: |
    Cryptographic algorithms are notoriously difficult to get right. By implementing
    a custom message digest, you risk introducing security issues into your program.
    Use one of the many sound message digests already available to you:
    MessageDigest sha256Digest = MessageDigest.getInstance("SHA256");
  severity: WARNING
  languages:
  - java
  pattern: |-
    class $CLASS extends MessageDigest {
      ...
    }
- id: java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.1.3 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v91-client-communications-security-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
  message: |
    DefaultHttpClient is deprecated. Further, it does not support connections
    using TLS1.2, which makes using DefaultHttpClient a security hazard.
    Use SystemDefaultHttpClient instead, which supports TLS1.2.
  severity: WARNING
  languages:
  - java
  pattern: new DefaultHttpClient(...);
  fix-regex:
    regex: DefaultHttpClient
    replacement: SystemDefaultHttpClient
- id: java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
  message: |
    Insecure HostnameVerifier implementation detected. This will accept
    any SSL certificate with any hostname, which creates the possibility
    for man-in-the-middle attacks.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.2.1 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      class $CLASS implements HostnameVerifier {
        ...
        public boolean verify(...) { return true; }
      }
  - pattern: |-
      new HostnameVerifier(...){
        public boolean verify(...) {
          return true;
        }
      }
  - pattern: import org.apache.http.conn.ssl.NoopHostnameVerifier;
- id: java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.2.1 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements
      version: '4'
    references:
    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
  message: |
    Detected empty trust manager implementations. This is dangerous because it accepts any
    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore
    and TrustManagerFactory isntead.
    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    for more information.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS implements X509TrustManager {
          ...
        }
    - pattern-inside: |
        new X509TrustManager() {
          ...
        }
    - pattern-inside: |
        class $CLASS implements X509ExtendedTrustManager {
          ...
        }
    - pattern-inside: |
        new X509ExtendedTrustManager() {
          ...
        }
  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }
  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }
  - pattern-either:
    - pattern: public void checkClientTrusted(...) {}
    - pattern: public void checkServerTrusted(...) {}
    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }
- id: java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket
  metadata:
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNENCRYPTED_SOCKET
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket
  message: |
    This socket is not encrypted.
    The traffic could be read by an attacker intercepting the network traffic.
    Use an SSLSocket created by 'SSLSocketFactory' or 'SSLServerSocketFactory'
    instead
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: new ServerSocket(...)
  - pattern: new Socket(...)
- id: java.lang.security.audit.crypto.weak-hash.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - java
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.weak-hash.use-of-sha1
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("SHA1");
  - pattern: |
      $DU.getSha1Digest().digest(...)
- id: java.lang.security.audit.crypto.weak-hash.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - java
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.weak-hash.use-of-md5
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("MD5");
  - pattern: |
      $DU.getMd5Digest().digest(...)
- id: java.lang.security.audit.crypto.weak-rsa.use-of-weak-rsa-key
  message: RSA keys should be at least 2048 bits based on NIST recommendation.
  languages:
  - java
  severity: WARNING
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#RSA_KEY_SIZE
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.5 Insecure Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.crypto.weak-rsa.use-of-weak-rsa-key
  patterns:
  - pattern: |
      KeyPairGenerator $KEY = $G.getInstance("RSA");
      ...
      $KEY.initialize($BITS);
  - metavariable-comparison:
      metavariable: $BITS
      comparison: $BITS < 2048
- id: java.lang.security.audit.dangerous-groovy-shell.dangerous-groovy-shell
  patterns:
  - pattern-either:
    - pattern: |
        $SHELL.parse(...)
    - pattern: |
        $SHELL.evaluate(...)
    - pattern: |
        $SHELL.parseClass(...)
  - pattern-either:
    - pattern-inside: |
        groovy.lang.GroovyShell $SHELL = ...;
        ...
    - pattern-inside: |
        groovy.lang.GroovyClassLoader $SHELL = ...;
        ...
  - pattern-not: |
      $SHELL.parse("...",...)
  - pattern-not: |
      $SHELL.evaluate("...",...)
  - pattern-not: |
      $SHELL.parseClass("...",...)
  message: |
    A expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#GROOVY_SHELL
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.dangerous-groovy-shell.dangerous-groovy-shell
  languages:
  - java
  severity: WARNING
- id: java.lang.security.audit.el-injection.el-injection
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.el-injection.el-injection
  message: |
    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF;
          ...
          $X $METHOD(...) {
            ...
            $EF.createValueExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF = ...;
          ...
          $X $METHOD(...) {
            ...
            $EF.createValueExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ExpressionFactory $EF = ...;
          ...
          $EF.createValueExpression($CTX,$INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ExpressionFactory $EF,...) {
          ...
          $EF.createValueExpression($CTX,$INPUT,...);
          ...
        }
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF;
          ...
          $X $METHOD(...) {
            ...
            $EF.createMethodExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF = ...;
          ...
          $X $METHOD(...) {
            ...
            $EF.createMethodExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ExpressionFactory $EF = ...;
          ...
          $EF.createMethodExpression($CTX,$INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ExpressionFactory $EF,...) {
          ...
          $EF.createMethodExpression($CTX,$INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(String $INPUT, ...) {
          ...
          $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);
          ...
        }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $EF.createValueExpression($CTX,"...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $EF.createValueExpression($CTX,$S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $EF.createMethodExpression($CTX,"...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $EF.createMethodExpression($CTX,$S,...);
        ...
      }
- id: java.lang.security.audit.formatted-sql-string.formatted-sql-string
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.3.5 Injection
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements
      version: '4'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps
    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.formatted-sql-string.formatted-sql-string
  message: |
    Detected a formatted string in a SQL statement. This could lead to SQL
    injection if variables in the SQL statement are not properly sanitized.
    Use a prepared statements (java.sql.PreparedStatement) instead. You
    can obtain a PreparedStatement using 'connection.prepareStatement'.
  patterns:
  - pattern-not: $W.execute(<... "=~/.*TABLE *$/" ...>);
  - pattern-not: $W.execute(<... "=~/.*TABLE %s$/" ...>);
  - pattern-either:
    - pattern: $W.execute($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.execute($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.execute($SQL, ...);
    - pattern: $W.execute(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.execute($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.execute($SQL, ...);
    - pattern: $W.executeQuery($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.executeQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.executeQuery($SQL, ...);
    - pattern: $W.executeQuery(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.executeQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.executeQuery($SQL, ...);
    - pattern: $W.createQuery($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.createQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.createQuery($SQL, ...);
    - pattern: $W.createQuery(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.createQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.createQuery($SQL, ...);
    - pattern: $W.query($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.query($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.query($SQL, ...);
    - pattern: $W.query(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.query($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.query($SQL, ...);
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.http-response-splitting.http-response-splitting
  metadata:
    cwe: 'CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers (''HTTP
      Response Splitting'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTP_RESPONSE_SPLITTING
    references:
    - https://www.owasp.org/index.php/HTTP_Response_Splitting
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.http-response-splitting.http-response-splitting
  message: |
    Older Java application servers are vulnreable to HTTP response splitting, which may occur if an HTTP
    request can be injected with CRLF characters. This finding is reported for completeness; it is recommended
    to ensure your environment is not affected by testing this yourself.
  severity: INFO
  languages:
  - java
  pattern-either:
  - pattern: |
      $VAR = $REQ.getParameter(...);
      ...
      $COOKIE = new Cookie(..., $VAR, ...);
      ...
      $RESP.addCookie($COOKIE, ...);
  - patterns:
    - pattern-inside: |
        $RETTYPE $FUNC(...,@PathVariable $TYPE $VAR, ...) {
          ...
        }
    - pattern: |
        $COOKIE = new Cookie(..., $VAR, ...);
        ...
        $RESP.addCookie($COOKIE, ...);
- id: java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
  metadata:
    cwe: 'CWE-297: Improper Validation of Certificate with Host Mismatch'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
  message: |
    Insecure SMTP connection detected. This connection will trust any SSL certificate.
    Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.
  severity: WARNING
  patterns:
  - pattern-not-inside: |
      $EMAIL.setSSLCheckServerIdentity(true);
      ...
  - pattern-inside: |
      $EMAIL = new SimpleEmail(...);
      ...
  - pattern: $EMAIL.send(...);
  languages:
  - java
- id: java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION_SPRING_JDBC
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.3.5 Injection
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string
  message: |
    Possible JDBC injection detected. Use the parameterized query
    feature available in queryForObject instead of concatenating or formatting strings:
    'jdbc.queryForObject("select * from table where name = ?", Integer.class, parameterName);'
  patterns:
  - pattern-inside: |
      $JDBC = new JdbcTemplate(...);
      ...
  - pattern-either:
    - pattern: $JDBC.queryForObject($STR + $VAR, ...);
    - pattern: $JDBC.queryForObject(String.format(...), ...);
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.queryForObject($Q, ...);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.queryForObject($Q, ...);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.queryForObject($Q, ...);
    - pattern: $JDBC.queryForList($STR + $VAR);
    - pattern: $JDBC.queryForList(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.queryForList($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.queryForList($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.queryForList($Q, ...);
    - pattern: $JDBC.update($STR + $VAR);
    - pattern: $JDBC.update(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.update($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.update($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.update($Q, ...);
    - pattern: $JDBC.execute($STR + $VAR);
    - pattern: $JDBC.execute(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.execute($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.execute($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.execute($Q, ...);
    - pattern: $JDBC.insert($STR + $VAR);
    - pattern: $JDBC.insert(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.insert($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.insert($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.insert($Q, ...);
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-90: Improper Neutralization of Special Elements used in an LDAP Query
      (''LDAP Injection'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_ENTRY_POISONING
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.3.7 Injection
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements
      version: '4'
    references:
    - https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf
    - https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning
  message: |
    An object-returning LDAP search will allow attackers to control the LDAP response. This could
    lead to Remote Code Execution.
  severity: WARNING
  pattern-either:
  - pattern: |
      new SearchControls($S, $CL, $TL, $AT, true, $DEREF)
  - pattern: |
      SearchControls $VAR = new SearchControls();
      ...
      $VAR.setReturningObjFlag(true);
  languages:
  - java
- id: java.lang.security.audit.ldap-injection.ldap-injection
  message: |
    Detected non-constant data passed into an LDAP query. If this data can be
    controlled by an external user, this is an LDAP injection.
    Ensure data passed to an LDAP query is not controllable; or properly sanitize
    the data.
  metadata:
    cwe: 'CWE-90: Improper Neutralization of Special Elements used in an LDAP Query
      (''LDAP Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_INJECTION
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.3.7 Injection
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.ldap-injection.ldap-injection
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          InitialDirContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          DirContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          InitialLdapContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          LdapContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          LdapCtx $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          EventDirContext $CTX = ...;
          ...
        }
  - pattern: |
      $X $METHOD(...) {
        ...
        $CTX.search($Y,$INPUT,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $CTX.search($Y,"...",...);
        ...
      }
- id: java.lang.security.audit.object-deserialization.object-deserialization
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OBJECT_DESERIALIZATION
    references:
    - https://www.owasp.org/index.php/Deserialization_of_untrusted_data
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.object-deserialization.object-deserialization
  message: |
    Found object deserialization using ObjectInputStream. Deserializing entire
    Java objects is dangerous because malicious actors can create Java object
    streams with unintended consequences. Ensure that the objects being deserialized
    are not user-controlled. If this must be done, consider using HMACs to sign
    the data stream to make sure it is not tampered with, or consider only
    transmitting object fields and populating a new object.
  severity: WARNING
  languages:
  - java
  pattern: new ObjectInputStream(...);
- id: java.lang.security.audit.ognl-injection.ognl-injection
  message: |
    A expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OGNL_INJECTION
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.ognl-injection.ognl-injection
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern: |
        $X $METHOD(...,OgnlReflectionProvider $P,...) {
          ...
          $P.getGetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlReflectionProvider $P,...) {
          ...
          $P.getSetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlReflectionProvider $P,...) {
          ...
          $P.getField($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlReflectionProvider $P,...) {
          ...
          $P.setProperties($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlReflectionProvider $P,...) {
          ...
          $P.setProperty($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlReflectionProvider $P,...) {
          ...
          $P.getValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlReflectionProvider $P,...) {
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ReflectionProvider $P,...) {
          ...
          $P.getGetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ReflectionProvider $P,...) {
          ...
          $P.getSetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ReflectionProvider $P,...) {
          ...
          $P.getField($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ReflectionProvider $P,...) {
          ...
          $P.setProperties($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ReflectionProvider $P,...) {
          ...
          $P.setProperty($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ReflectionProvider $P,...) {
          ...
          $P.getValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ReflectionProvider $P,...) {
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,TextParseUtil $P,...) {
          ...
          $P.translateVariables($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,TextParseUtil $P,...) {
          ...
          $P.translateVariablesCollection($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,TextParseUtil $P,...) {
          ...
          $P.shallBeIncluded($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,TextParseUtil $P,...) {
          ...
          $P.commaDelimitedStringToSet($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,TextParser $P,...) {
          ...
          $P.evaluate($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlTextParser $P,...) {
          ...
          $P.evaluate($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlUtil $P,...) {
          ...
          $P.setProperties($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlUtil $P,...) {
          ...
          $P.setProperty($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlUtil $P,...) {
          ...
          $P.getValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlUtil $P,...) {
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlUtil $P,...) {
          ...
          $P.callMethod($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlUtil $P,...) {
          ...
          $P.compile($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,VelocityStrutsUtil $P,...) {
          ...
          $P.evaluate($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,StrutsUtil $P,...) {
          ...
          $P.isTrue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,StrutsUtil $P,...) {
          ...
          $P.findString($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,StrutsUtil $P,...) {
          ...
          $P.findValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,StrutsUtil $P,...) {
          ...
          $P.getText($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,StrutsUtil $P,...) {
          ...
          $P.translateVariables($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,StrutsUtil $P,...) {
          ...
          $P.makeSelectList($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,OgnlTool $P,...) {
          ...
          $P.findValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ValueStack $P,...) {
          ...
          $P.findString($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ValueStack $P,...) {
          ...
          $P.findValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ValueStack $P,...) {
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ValueStack $P,...) {
          ...
          $P.setParameter($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlReflectionProvider $P = ...;
          ...
          $P.getGetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlReflectionProvider $P = ...;
          ...
          $P.getSetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlReflectionProvider $P = ...;
          ...
          $P.getField($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlReflectionProvider $P = ...;
          ...
          $P.setProperties($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlReflectionProvider $P = ...;
          ...
          $P.setProperty($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlReflectionProvider $P = ...;
          ...
          $P.getValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlReflectionProvider $P = ...;
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ReflectionProvider $P = ...;
          ...
          $P.getGetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ReflectionProvider $P = ...;
          ...
          $P.getSetMethod($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ReflectionProvider $P = ...;
          ...
          $P.getField($T, $INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ReflectionProvider $P = ...;
          ...
          $P.setProperties($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ReflectionProvider $P = ...;
          ...
          $P.setProperty($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ReflectionProvider $P = ...;
          ...
          $P.getValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ReflectionProvider $P = ...;
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          TextParseUtil $P = ...;
          ...
          $P.translateVariables($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          TextParseUtil $P = ...;
          ...
          $P.translateVariablesCollection($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          TextParseUtil $P = ...;
          ...
          $P.shallBeIncluded($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          TextParseUtil $P = ...;
          ...
          $P.commaDelimitedStringToSet($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          TextParser $P = ...;
          ...
          $P.evaluate($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlTextParser $P = ...;
          ...
          $P.evaluate($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlUtil $P = ...;
          ...
          $P.setProperties($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlUtil $P = ...;
          ...
          $P.setProperty($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlUtil $P = ...;
          ...
          $P.getValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlUtil $P = ...;
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlUtil $P = ...;
          ...
          $P.callMethod($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlUtil $P = ...;
          ...
          $P.compile($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          VelocityStrutsUtil $P = ...;
          ...
          $P.evaluate($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          StrutsUtil $P = ...;
          ...
          $P.isTrue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          StrutsUtil $P = ...;
          ...
          $P.findString($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          StrutsUtil $P = ...;
          ...
          $P.findValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          StrutsUtil $P = ...;
          ...
          $P.getText($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          StrutsUtil $P = ...;
          ...
          $P.translateVariables($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          StrutsUtil $P = ...;
          ...
          $P.makeSelectList($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          OgnlTool $P = ...;
          ...
          $P.findValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ValueStack $P = ...;
          ...
          $P.findString($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ValueStack $P = ...;
          ...
          $P.findValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ValueStack $P = ...;
          ...
          $P.setValue($INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ValueStack $P = ...;
          ...
          $P.setParameter($INPUT,...);
          ...
        }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.getGetMethod($T,"...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.getSetMethod($T,"...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.getField($T,"...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.setProperties("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.setProperty("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.getValue("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.setValue("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.translateVariables("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.translateVariablesCollection("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.shallBeIncluded("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.commaDelimitedStringToSet("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.evaluate("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.callMethod("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.compile("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.isTrue("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.findString("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.findValue("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.getText("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.makeSelectList("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $P.setParameter("...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.getGetMethod($T,$S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.getSetMethod($T,$S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.getField($T,$S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.setProperties($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.setProperty($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.getValue($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.setValue($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.translateVariables($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.translateVariablesCollection($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.shallBeIncluded($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.commaDelimitedStringToSet($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.evaluate($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.callMethod($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.compile($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.isTrue($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.findString($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.findValue($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.getText($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.makeSelectList($S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $P.setParameter($S,...);
        ...
      }
- id: java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission
  message: |
    It is generally a bad practices to set overly permissive file permission such as read+write+exec for all users.
    If the file affected is a configuration, a binary, a script or sensitive data, it can lead to privilege escalation or information leakage.
  severity: WARNING
  languages:
  - java
  metadata:
    cwe: 'CWE-276: Incorrect Default Permissions'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OVERLY_PERMISSIVE_FILE_PERMISSION
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission
  pattern-either:
  - pattern: java.nio.file.Files.setPosixFilePermissions($FILE, java.nio.file.attribute.PosixFilePermissions.fromString("=~/(^......r..$)|(^.......w.$)|(^........x$)/"));
  - pattern: |
      $TYPE $P = java.nio.file.attribute.PosixFilePermissions.fromString("=~/(^......r..$)|(^.......w.$)|(^........x$)/");
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
  - pattern: |
      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_READ);
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
  - pattern: |
      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE);
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
  - pattern: |-
      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
- id: java.lang.security.audit.script-engine-injection.script-engine-injection
  message: |
    Detected potential code injection using ScriptEngine. Ensure
    user-controlled data cannot enter '.eval()', otherwise, this is
    a code injection vulnerability.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SCRIPT_ENGINE_INJECTION
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.script-engine-injection.script-engine-injection
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS {
          ...
          ScriptEngine $SE;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          ScriptEngine $SE = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          ScriptEngine $SE = ...;
          ...
        }
  - pattern: |
      $X $METHOD(...) {
        ...
        $SE.eval(...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $SE.eval("...");
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $SE.eval($S);
        ...
      }
- id: java.lang.security.audit.unsafe-reflection.unsafe-reflection
  patterns:
  - pattern: |
      Class.forName($CLASS,...)
  - pattern-not: |
      Class.forName("...",...)
  - pattern-not-inside: |
      $CLASS = "...";
      ...
  message: |
    If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke,
    the potential exists for the attacker to create control flow paths through the application
    that were not intended by the application developers.
    This attack vector may allow the attacker to bypass authentication or access control checks
    or otherwise cause the application to behave in an unexpected manner.
  metadata:
    cwe: 'CWE-470: Use of Externally-Controlled Input to Select Classes or Code (''Unsafe
      Reflection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.unsafe-reflection.unsafe-reflection
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.unvalidated-redirect.unvalidated-redirect
  message: |
    Application redirects to a destination URL specified by a user-supplied
    parameter that is not validated. This could direct users to malicious locations.
    Consider using an allowlist to validate URLs.
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.1.5 Open Redirect
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.unvalidated-redirect.unvalidated-redirect
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        $RES.sendRedirect($REQ.getParameter(...));
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        $RES.sendRedirect($REQ.getParameter(...));
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        $RES.addHeader("Location",$REQ.getParameter(...));
        ...
      }
  - pattern: |-
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        $RES.addHeader("Location",$REQ.getParameter(...));
        ...
      }
- id: java.lang.security.audit.url-rewriting.url-rewriting
  message: |
    URL rewriting has significant security risks.
    Since session ID appears in the URL, it may be easily seen by third parties.
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#URL_REWRITING
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.url-rewriting.url-rewriting
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeURL(...);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeUrl(...);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeRedirectURL(...);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeRedirectUrl(...);
        ...
      }
  - pattern: |
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeURL(...);
        ...
      }
  - pattern: |
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeUrl(...);
        ...
      }
  - pattern: |
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeRedirectURL(...);
        ...
      }
  - pattern: |-
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeRedirectUrl(...);
        ...
      }
- id: java.lang.security.audit.weak-ssl-context.weak-ssl-context
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.weak-ssl-context.weak-ssl-context
  message: |
    An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use SSLContext.getInstance("TLSv1.2") for the best security.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not: SSLContext.getInstance("TLSv1.3")
  - pattern-not: SSLContext.getInstance("TLSv1.2")
  - pattern: SSLContext.getInstance("...")
  fix-regex:
    regex: (.*?)\.getInstance\(.*?\)
    replacement: \1.getInstance("TLSv1.2")
- id: java.lang.security.audit.xml-decoder.xml-decoder
  message: |
    XMLDecoder should not be used to parse untrusted data.
    Deserializing user input can lead to arbitrary code execution.
    Use an alternative and explicitly disable external entities.
    See https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html
    for alternatives and vulnerability prevention.
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XML_DECODER
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.xml-decoder.xml-decoder
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern: |
      $X $METHOD(...) {
        ...
        new XMLDecoder(...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        new XMLDecoder("...");
        ...
      }
  - pattern-not: |-
      $X $METHOD(...) {
        ...
        String $STR = "...";
        ...
        new XMLDecoder($STR);
        ...
      }
- id: java.lang.security.audit.xss.jsf.autoescape-disabled.autoescape-disabled
  message: |
    Detected an element with disabled HTML escaping. If external
    data can reach this, this is a cross-site scripting (XSS)
    vulnerability. Ensure no external data can reach here, or
    remove 'escape=false' from this element.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences'
    references:
    - https://stackoverflow.com/a/7442668
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.xss.jsf.autoescape-disabled.autoescape-disabled
  pattern-regex: .*escape.*?=.*?false.*
  paths:
    include:
    - '*.html'
    - '*.xhtml'
  languages:
  - regex
  severity: WARNING
- id: java.lang.security.audit.xss.jsp.no-scriptlets.no-scriptlets
  message: |
    JSP scriptlet detected. Scriptlets are difficult to use securely and
    are considered bad practice. See https://stackoverflow.com/a/3180202.
    Instead, consider migrating to JSF or using the Expression Language
    '${...}' with the escapeXml function in your JSP files.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    references:
    - https://stackoverflow.com/a/3180202
    - https://stackoverflow.com/a/4948856
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.xss.jsp.no-scriptlets.no-scriptlets
  pattern-regex: \<\%[^\@].*
  paths:
    include:
    - '*.jsp'
  languages:
  - regex
  severity: WARNING
- id: java.lang.security.audit.xss.jsp.use-escapexml.use-escapexml
  message: |
    Detected an Expression Language segment that does not escape
    output. This is dangerous because if any data in this expression
    can be controlled externally, it is a cross-site scripting
    vulnerability. Instead, use the 'escapeXml' function from
    the JSTL taglib. See https://www.tutorialspoint.com/jsp/jstl_function_escapexml.htm
    for more information.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    references:
    - https://www.tutorialspoint.com/jsp/jstl_function_escapexml.htm
    - https://stackoverflow.com/a/4948856
    - https://stackoverflow.com/a/3180202
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.xss.jsp.use-escapexml.use-escapexml
  pattern-regex: \$\{(?!.*escapeXml).*\}
  paths:
    include:
    - '*.jsp'
  languages:
  - regex
  severity: WARNING
- id: java.lang.security.audit.xss.jsp.use-jstl-escaping.use-jstl-escaping
  message: |
    Detected an Expression Language segment in a tag that does not escape
    output. This is dangerous because if any data in this expression
    can be controlled externally, it is a cross-site scripting
    vulnerability. Instead, use the 'out' tag from the JSTL taglib
    to escape this expression.
    See https://www.tutorialspoint.com/jsp/jstl_core_out_tag.htm
    for more information.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    references:
    - https://www.tutorialspoint.com/jsp/jstl_core_out_tag.htm
    - https://stackoverflow.com/a/4948856
    - https://stackoverflow.com/a/3180202
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.xss.jsp.use-jstl-escaping.use-jstl-escaping
  pattern-regex: <(?![A-Za-z0-9]+:out).*?\$\{.*?\}.*>
  paths:
    include:
    - '*.jsp'
  languages:
  - regex
  severity: WARNING
- id: java.lang.security.audit.xss.no-direct-response-writer.no-direct-response-writer
  patterns:
  - pattern-either:
    - pattern-inside: |
        $RETURN $METHOD(..., HttpServletResponse $RESP, ...) { ... }
    - pattern-inside: |
        HttpServletResponse $RESPONSE = ...;
        ...
  - pattern-either:
    - pattern: |
        (HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)
    - pattern: |
        (HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)
    - pattern: |
        (PrintWriter $WRITER).$WRITE(...)
    - pattern: |
        (ServletOutputStream $WRITER).$WRITE(...)
    - pattern: |
        (OutputStream $WRITER).$WRITE(...)
  - pattern-not: $WRITER.$WRITE("...", ...)
  - pattern-not: $WRITER.flush(...)
  - pattern-not: $WRITER.close(...)
  message: |
    Detected a direct write to the HTTP response. This bypasses any
    view or template environments, including HTML escaping, which may
    expose this application to cross-site scripting (XSS) vulnerabilities.
    Consider using a view technology such as JavaServer Faces (JSFs) which
    automatically escapes HTML views.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    references:
    - https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.xss.no-direct-response-writer.no-direct-response-writer
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_REQUEST_WRAPPER
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure
  message: |
    It looks like you're using an implementation of XSSRequestWrapper from dzone.
    (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html)
    The XSS filtering in this code is not secure and can be bypassed by malicious actors.
    It is recommended to use a stack that automatically escapes in your view or templates
    instead of filtering yourself.
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      class XSSRequestWrapper extends HttpServletRequestWrapper {
        ...
      }
  - pattern: |-
      $P = $X.compile("</script>", $X.CASE_INSENSITIVE);
      $V = $P.matcher(...).replaceAll("");
- id: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  patterns:
  - pattern-inside: |
      $RETURNTYPE $FUNC (..., HttpServletRequest $REQ, ...) {
        ...
      }
  - pattern-either:
    - pattern: |
        $VAR = ($TYPE)$REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
    - pattern: |
        $VAR = $REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
  severity: ERROR
  languages:
  - java
- id: java.lang.security.insecure-jms-deserialization.insecure-jms-deserialization
  severity: WARNING
  languages:
  - java
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.3 Insecue Deserialization
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention
      version: '4'
    references:
    - https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities-wp.pdf
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.insecure-jms-deserialization.insecure-jms-deserialization
  message: |
    JMS Object messages depend on Java Serialization for marshalling/unmarshalling of the message payload when ObjectMessage.getObject() is called.
    Deserialization of untrusted data can lead to security flaws; a remote attacker could via a crafted JMS ObjectMessage to execute
    arbitrary code with the permissions of the application listening/consuming JMS Messages.
    In this case, the JMS MessageListener consume an ObjectMessage type recieved inside
    the onMessage method, which may lead to arbitrary code execution when calling the $Y.getObject method.
  patterns:
  - pattern-inside: |
      public class $JMS_LISTENER implements MessageListener {
        ...
        public void onMessage(Message $JMS_MSG) {
            ...
        }
      }
  - pattern-either:
    - pattern-inside: $X = $Y.getObject(...);
    - pattern-inside: $X = ($Z) $Y.getObject(...);
- id: java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
  message: |
    Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User
    input was detected going directly from the HttpServletRequest into output. Ensure your
    data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
  severity: ERROR
  patterns:
  - pattern-inside: $TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }
  - pattern-inside: $VAR = $REQ.getParameter(...); ...
  - pattern-either:
    - pattern: $RESP.getWriter(...).write(..., $VAR, ...);
    - pattern: |
        $WRITER = $RESP.getWriter(...);
        ...
        $WRITER.write(..., $VAR, ...);
  languages:
  - java
- id: java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
  severity: ERROR
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.2 Insecue XML Deserialization
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention
      version: '4'
    references:
    - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
  message: |
    XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity
    attacks. Disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
  pattern: $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities",
    true);
  languages:
  - java
- id: java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe
  severity: WARNING
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.2 Insecue XML Deserialization
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention
      version: '4'
    references:
    - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xmlinputfactory-a-stax-parser
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe
  message: |
    XML external entities are not explicitly disabled for this XMLInputFactory. This could be vulnerable to XML external entity
    vulnerabilities. Explicitly disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
  patterns:
  - pattern-not-inside: |
      $RETURNTYPE $METHOD(...) {
        ...
        $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities", false);
        ...
      }
  - pattern-not-inside: |
      $RETURNTYPE $METHOD(...) {
        ...
        $XMLFACTORY.setProperty(java.xml.stream.XMLFactoryInput.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        ...
      }
  - pattern-either:
    - pattern: $XMLFACTORY = $W.newFactory(...);
    - pattern: $XMLFACTORY = new XMLInputFactory(...);
  languages:
  - java
- id: java.rmi.security.server-dangerous-class-deserialization.server-dangerous-class-deserialization
  severity: WARNING
  languages:
  - java
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/
    category: security
    technology:
    - rmi
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.rmi.security.server-dangerous-class-deserialization.server-dangerous-class-deserialization
  message: |
    Using a non-primitive class with Java RMI may be an insecure deserialization vulnerability. Depending
    on the underlying implementation. This object could be manipulated by a malicious actor allowing them to
    execute code on your system. Instead, use an integer ID to look up your object, or consider alternative
    serializiation schemes such as JSON.
  patterns:
  - pattern: |
      interface $INTERFACE extends Remote {
        $RETURNTYPE $METHOD($CLASS $PARAM) throws RemoteException;
      }
  - metavariable-regex:
      metavariable: $CLASS
      regex: (?!int|boolean|short|long|byte|char|float|double)
- id: java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
  severity: ERROR
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/
    - https://frohoff.github.io/appseccali-marshalling-pickles/
    category: security
    technology:
    - rmi
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
  message: |
    Using an arbitrary object ('Object $PARAM') with Java RMI is an insecure deserialization
    vulnerability. This object can be manipulated by a malicious actor allowing them to execute
    code on your system. Instead, use an integer ID to look up your object, or consider alternative
    serializiation schemes such as JSON.
  languages:
  - java
  pattern: |
    interface $INTERFACE extends Remote {
      $RETURNTYPE $METHOD(Object $PARAM) throws RemoteException;
    }
- id: javascript.bluebird.security.audit.tofastproperties-code-execution.tofastproperties-code-execution
  patterns:
  - pattern-either:
    - pattern: $UTIL.toFastProperties(...)
    - pattern: toFastProperties(...)
  - pattern-not: |
      $UTIL.toFastProperties("...",...)
  - pattern-not: |
      toFastProperties("...",...)
  - pattern-either:
    - pattern-inside: |
        $BB = require('bluebird');
        ...
    - pattern-inside: |
        import 'bluebird';
        ...
  message: |
    Potential arbitrary code execution, whatever is provided to `toFastProperties` is sent straight to eval()
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - bluebird
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.bluebird.security.audit.tofastproperties-code-execution.tofastproperties-code-execution
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.browser.security.dom-based-xss.dom-based-xss
  pattern-either:
  - pattern: document.write(<... document.location.$W ...>)
  - pattern: document.write(<... location.$W ...>)
  message: |
    Detected possible DOM-based XSS. This occurs because a portion of the URL is being used
    to construct an element added directly to the page. For example, a malicious actor could
    send someone a link like this: http://www.some.site/page.html?default=<script>alert(document.cookie)</script>
    which would add the script to the page.
    Consider allowlisting appropriate values or using an approach which does not involve the URL.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://owasp.org/www-community/attacks/DOM_Based_XSS
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.dom-based-xss.dom-based-xss
  severity: ERROR
  languages:
  - javascript
  - typescript
- id: javascript.browser.security.eval-detected.eval-detected
  patterns:
  - pattern-not: eval("...")
  - pattern: eval(...)
  message: |
    Detected the use of eval(). eval() can be dangerous if used to evaluate
    dynamic content. If this content can be input from outside the program, this
    may be a code injection vulnerability. Ensure evaluated content is not definable
    by external sources.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.2.4 Dynamic Code Execution Features
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing
      version: '4'
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.eval-detected.eval-detected
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.browser.security.insecure-document-method.insecure-document-method
  patterns:
  - pattern-either:
    - pattern: |
        $EL.innerHTML = $HTML;
    - pattern: |
        $EL.outerHTML = $HTML;
    - pattern: document.write(...)
  - pattern-not: |
      $EL.innerHTML = "...";
  - pattern-not: |
      $EL.outerHTML = "...";
  - pattern-not: document.write("...")
  message: |
    User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.insecure-document-method.insecure-document-method
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.browser.security.insecure-innerhtml.insecure-innerhtml
  patterns:
  - pattern: |
      $EL.innerHTML = $HTML;
  - pattern-not: |
      $EL.innerHTML = "...";
  message: |
    User controlled data in a `$EL.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.insecure-innerhtml.insecure-innerhtml
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.browser.security.insufficient-postmessage-origin-validation.insufficient-postmessage-origin-validation
  pattern-either:
  - patterns:
    - pattern: |
        window.addEventListener('message', $FUNC, ...)
    - metavariable-pattern:
        metavariable: $FUNC
        patterns:
        - pattern: |
            function($OBJ) { ... }
        - pattern-not: |
            function($OBJ) { ... if (<... $OBJ.origin ...>) { ... } ... }
  - patterns:
    - pattern-either:
      - pattern-inside: |
          function $FNAME($OBJ) { $CONTEXT }
          ...
      - pattern-inside: |
          $FNAME = (...) => { $CONTEXT }
          ...
    - pattern: |
        window.addEventListener('message', $FNAME,...)
    - metavariable-pattern:
        metavariable: $CONTEXT
        patterns:
        - pattern-not: |
            ... if (<... $OBJ.origin ...>) { ... } ...
  message: |
    No validation of origin is done by the addEventListener API. It may be possible to exploit this flaw to perform Cross Origin attacks such as Cross-Site Scripting(XSS).
  languages:
  - javascript
  - typescript
  severity: WARNING
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-345: Insufficient Verification of Data Authenticity'
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.insufficient-postmessage-origin-validation.insufficient-postmessage-origin-validation
- id: javascript.browser.security.new-function-detected.new-function-detected
  patterns:
  - pattern-not: |
      $FUNC = new Function('...');
      ...
      $FUNC();
  - pattern: |
      $FUNC = new Function(...);
      ...
      $FUNC();
  message: |
    Detected the use of new Function(), which can be dangerous if used to evaluate
    dynamic content. If this content can be input from outside the program, this
    may be a code injection vulnerability. Ensure evaluated content is not definable
    by external sources.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.new-function-detected.new-function-detected
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.browser.security.open-redirect.js-open-redirect
  message: |
    Possible open redirect
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (Open Redirect)'
    owasp: 'A1: Injection'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.1 Insecue Redirect
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation
      version: '4'
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.open-redirect.js-open-redirect
  languages:
  - javascript
  - typescript
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern: |
        window.location.replace($URL)
    - pattern: |
        location.replace($URL)
    - pattern: |
        window.location.href = $URL
    - pattern: |
        location.href = $URL
  - pattern-not: |
      window.location.href = "..."
  - pattern-not: |
      location.href = "..."
  - pattern-not: |
      location.replace("...")
  - pattern-not: window.location.replace("...")
- id: javascript.browser.security.raw-html-concat.raw-html-concat
  message: User controlled data in a HTML string may result in XSS
  languages:
  - javascript
  - typescript
  severity: WARNING
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://owasp.org/www-community/attacks/xss/
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.raw-html-concat.raw-html-concat
  patterns:
  - pattern-either:
    - patterns:
      - pattern: $STRING + $EXPR
      - pattern-not: $STRING + "..."
      - metavariable-pattern:
          metavariable: $STRING
          language: generic
          patterns:
          - pattern: <$TAG ...
    - patterns:
      - pattern: $EXPR + $STRING
      - pattern-not: '"..." + $STRING'
      - metavariable-pattern:
          metavariable: $STRING
          language: generic
          patterns:
          - pattern: '... </$TAG'
    - patterns:
      - pattern: '[..., $STRING, ...].join(...)'
      - metavariable-pattern:
          metavariable: $STRING
          language: generic
          patterns:
          - pattern: <$TAG ...
    - patterns:
      - pattern: '[..., $STRING, ...].join(...)'
      - metavariable-pattern:
          metavariable: $STRING
          language: generic
          patterns:
          - pattern: '... </$TAG'
    - patterns:
      - pattern: $VAR += $STRING
      - metavariable-pattern:
          metavariable: $STRING
          language: generic
          patterns:
          - pattern: <$TAG ...
    - patterns:
      - pattern: $VAR += $STRING
      - metavariable-pattern:
          metavariable: $STRING
          language: generic
          patterns:
          - pattern: '... </$TAG'
- id: javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration
  message: |
    The target origin of the window.postMessage() API is set to "*". This could allow for information disclosure due to the possibility of any origin allowed to receive the message.
  languages:
  - javascript
  - typescript
  severity: WARNING
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-345: Insufficient Verification of Data Authenticity'
    category: security
    technology:
    - browser
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration
  pattern: $OBJECT.postMessage(...,'*')
- id: javascript.chrome-remote-interface.security.audit.chrome-remote-interface-compilescript-injection.chrome-remote-interface-compilescript-injection
  message: |
    If unverified user data can reach the `compileScript` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - chrome-remote-interface
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.chrome-remote-interface.security.audit.chrome-remote-interface-compilescript-injection.chrome-remote-interface-compilescript-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('chrome-remote-interface');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern: |
      $RUNTIME.compileScript({expression: $INPUT},...)
  - pattern-not: '$RUNTIME.compileScript({expression: "..."},...)'
- id: javascript.chrome-remote-interface.security.audit.chrome-remote-interface-evaluate-injection.chrome-remote-interface-evaluate-injection
  message: |
    If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - chrome-remote-interface
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.chrome-remote-interface.security.audit.chrome-remote-interface-evaluate-injection.chrome-remote-interface-evaluate-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('chrome-remote-interface');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern: |
      $RUNTIME.evaluate({expression: $INPUT},...)
  - pattern-not: '$RUNTIME.evaluate({expression: "..."},...)'
- id: javascript.chrome-remote-interface.security.audit.chrome-remote-interface-navigate-injection.chrome-remote-interface-navigate-injection
  message: |
    If unverified user data can reach the `navigate` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - chrome-remote-interface
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.chrome-remote-interface.security.audit.chrome-remote-interface-navigate-injection.chrome-remote-interface-navigate-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('chrome-remote-interface');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern: |
      $PAGE.navigate({url: $INPUT},...)
  - pattern-not: '$PAGE.navigate({url: "..."},...)'
- id: javascript.chrome-remote-interface.security.audit.chrome-remote-interface-printtopdf-injection.chrome-remote-interface-printtopdf-injection
  message: |
    If unverified user data can reach the `printToPDF` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - chrome-remote-interface
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.chrome-remote-interface.security.audit.chrome-remote-interface-printtopdf-injection.chrome-remote-interface-printtopdf-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('chrome-remote-interface');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern-either:
    - pattern: |
        $RUNTIME.printToPDF({headerTemplate: $INPUT},...)
    - pattern: |
        $RUNTIME.printToPDF({footerTemplate: $INPUT},...)
  - pattern-not: |
      $RUNTIME.printToPDF({headerTemplate: "..."},...)
  - pattern-not: '$RUNTIME.printToPDF({footerTemplate: "..."},...)'
- id: javascript.chrome-remote-interface.security.audit.chrome-remote-interface-setdocumentcontent-injection.chrome-remote-interface-setdocumentcontent-injection
  message: |
    If unverified user data can reach the `setDocumentContent` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - chrome-remote-interface
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.chrome-remote-interface.security.audit.chrome-remote-interface-setdocumentcontent-injection.chrome-remote-interface-setdocumentcontent-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('chrome-remote-interface');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern: |
      $PAGE.setDocumentContent({html: $INPUT},...)
  - pattern-not: '$PAGE.setDocumentContent({html: "..."},...)'
- id: javascript.deno.security.audit.deno-dangerous-run.deno-dangerous-run
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - deno
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.deno.security.audit.deno-dangerous-run.deno-dangerous-run
  message: |
    Detected non-literal calls to Deno.run(). This could lead to a command
    injection vulnerability.
  pattern-either:
  - patterns:
    - pattern: |
        Deno.run({cmd: [$CMD,...]},...)
    - pattern-not-inside: |
        $CMD = "..."
        ...
    - pattern-not: |
        Deno.run({cmd: ["...",...]},...)
  - patterns:
    - pattern-either:
      - pattern: |
          Deno.run({cmd: ["=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",$ARG,...]},...)
      - patterns:
        - pattern: |
            Deno.run({cmd: [$CMD,"-c",$ARG,...]},...)
        - pattern-inside: |
            $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/"
            ...
    - pattern-not: |
        Deno.run({cmd: [$CMD,"-c","...",...]},...)
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.express.security.audit.express-cookie-settings.express-cookie-session-default-name
  message: "Don\u2019t use the default session cookie name\nUsing the default session
    cookie name can open your app to attacks.\nThe security issue posed is similar
    to X-Powered-By: a potential attacker can use it to fingerprint the server and
    target attacks accordingly.\n"
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://expressjs.com/en/advanced/best-practice-security.html
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-cookie-settings.express-cookie-session-default-name
  patterns:
  - pattern-either:
    - pattern-inside: |
        $SESSION = require('cookie-session');
        ...
    - pattern-inside: |
        $SESSION = require('express-session');
        ...
  - pattern: $SESSION(...)
  - pattern-not-inside: $SESSION(<... {name:...} ...>,...)
  - pattern-not-inside: |
      $OPTS = <... {name:...} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.name = ...;
      ...
      $SESSION($OPTS,...);
- id: javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-secure
  message: |
    Default session middleware settings: `secure` not set.
    It ensures the browser only sends the cookie over HTTPS.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://expressjs.com/en/advanced/best-practice-security.html
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-secure
  patterns:
  - pattern-either:
    - pattern-inside: |
        $SESSION = require('cookie-session');
        ...
    - pattern-inside: |
        $SESSION = require('express-session');
        ...
  - pattern: $SESSION(...)
  - pattern-not-inside: $SESSION(<... {cookie:{secure:true}} ...>,...)
  - pattern-not-inside: |
      $OPTS = <... {cookie:{secure:true}} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE = <... {secure:true} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie = <... {secure:true} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE.secure = true;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie.secure = true;
      ...
      $SESSION($OPTS,...);
- id: javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-httponly
  message: |
    Default session middleware settings: `httpOnly` not set.
    It ensures the cookie is sent only over HTTP(S), not client JavaScript, helping to protect against cross-site scripting attacks.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://expressjs.com/en/advanced/best-practice-security.html
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-httponly
  patterns:
  - pattern-either:
    - pattern-inside: |
        $SESSION = require('cookie-session');
        ...
    - pattern-inside: |
        $SESSION = require('express-session');
        ...
  - pattern: $SESSION(...)
  - pattern-not-inside: $SESSION(<... {cookie:{httpOnly:true}} ...>,...)
  - pattern-not-inside: |
      $OPTS = <... {cookie:{httpOnly:true}} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE = <... {httpOnly:true} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie = <... {httpOnly:true} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE.httpOnly = true;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie.httpOnly = true;
      ...
      $SESSION($OPTS,...);
- id: javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-domain
  message: |
    Default session middleware settings: `domain` not set.
    It indicates the domain of the cookie; use it to compare against the domain of the server in which the URL is being requested.
    If they match, then check the path attribute next.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://expressjs.com/en/advanced/best-practice-security.html
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-domain
  patterns:
  - pattern-either:
    - pattern-inside: |
        $SESSION = require('cookie-session');
        ...
    - pattern-inside: |
        $SESSION = require('express-session');
        ...
  - pattern: $SESSION(...)
  - pattern-not-inside: $SESSION(<... {cookie:{domain:...}} ...>,...)
  - pattern-not-inside: |
      $OPTS = <... {cookie:{domain:...}} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE = <... {domain:...} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie = <... {domain:...} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE.domain = ...;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie.domain = ...;
      ...
      $SESSION($OPTS,...);
- id: javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-path
  message: |
    Default session middleware settings: `path` not set.
    It indicates the path of the cookie; use it to compare against the request path. If this and domain match, then send the cookie in the request.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://expressjs.com/en/advanced/best-practice-security.html
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-path
  patterns:
  - pattern-either:
    - pattern-inside: |
        $SESSION = require('cookie-session');
        ...
    - pattern-inside: |
        $SESSION = require('express-session');
        ...
  - pattern: $SESSION(...)
  - pattern-not-inside: $SESSION(<... {cookie:{path:...}} ...>,...)
  - pattern-not-inside: |
      $OPTS = <... {cookie:{path:...}} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE = <... {path:...} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie = <... {path:...} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE.path = ...;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie.path = ...;
      ...
      $SESSION($OPTS,...);
- id: javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-expires
  message: |
    Default session middleware settings: `expires` not set.
    Use it to set expiration date for persistent cookies.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://expressjs.com/en/advanced/best-practice-security.html
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-expires
  patterns:
  - pattern-either:
    - pattern-inside: |
        $SESSION = require('cookie-session');
        ...
    - pattern-inside: |
        $SESSION = require('express-session');
        ...
  - pattern: $SESSION(...)
  - pattern-not-inside: $SESSION(<... {cookie:{expires:...}} ...>,...)
  - pattern-not-inside: |
      $OPTS = <... {cookie:{expires:...}} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE = <... {expires:...} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $OPTS.cookie = <... {expires:...} ...>;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |
      $OPTS = ...;
      ...
      $COOKIE.expires = ...;
      ...
      $SESSION($OPTS,...);
  - pattern-not-inside: |-
      $OPTS = ...;
      ...
      $OPTS.cookie.expires = ...;
      ...
      $SESSION($OPTS,...);
- id: javascript.express.security.audit.express-jwt-not-revoked.express-jwt-not-revoked
  message: |
    No token revoking configured for `express-jwt`. A leaked token could still be used and unable to be revoked.
    Consider using function as the `isRevoked` option.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/expirejwt.md
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.3 Insecue Stateless Session Tokens
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-jwt-not-revoked.express-jwt-not-revoked
  patterns:
  - pattern-inside: |
      $JWT = require('express-jwt');
      ...
  - pattern: $JWT(...)
  - pattern-not-inside: $JWT(<... {isRevoked:...} ...>,...)
  - pattern-not-inside: |-
      $OPTS = <... {isRevoked:...} ...>;
      ...
      $JWT($OPTS,...);
- id: javascript.express.security.audit.express-path-join-resolve-traversal.express-path-join-resolve-traversal
  message: |
    Possible writing outside of the destination,
    make sure that the target path is nested in the intended destination
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A5: Broken Access Control'
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (Path
      Traversal)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-path-join-resolve-traversal.express-path-join-resolve-traversal
  severity: WARNING
  patterns:
  - pattern-inside: |
      $PATH = require('path');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $PATH.join(...,<... $REQ.$BODY ...>,...)
    - pattern: $PATH.join(...,<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $PATH.join(...,<... $VAR ...>,...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PATH.join(...,<... $VAR ...>,...);
    - pattern: $PATH.resolve(...,<... $REQ.$BODY ...>,...)
    - pattern: $PATH.resolve(...,<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $PATH.resolve(...,<... $VAR ...>,...);
    - pattern: |-
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PATH.resolve(...,<... $VAR ...>,...);
- id: javascript.express.security.audit.express-xml2json-xxe-event.express-xml2json-xxe-event
  message: |
    Xml Parser is used inside Request Event.
    Make sure that unverified user data can not reach the XML Parser,
    as it can result in XML External or Internal Entity (XXE) Processing vulnerabilities
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.express-xml2json-xxe-event.express-xml2json-xxe-event
  severity: WARNING
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('xml2json');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern: $REQ.on('...', function(...) { ... $EXPAT.toJson($INPUT,...); ... })
- id: javascript.express.security.audit.possible-user-input-redirect.unknown-value-in-redirect
  patterns:
  - pattern-either:
    - pattern-inside: |
        $UNK = query.$B;
        ...
    - pattern-inside: |
        $UNK = $A.query.$B;
        ...
    - pattern-inside: |
        $UNK = req.$SOMETHING;
        ...
  - pattern: $RES.redirect(..., <... $UNK ...>, ...)
  message: |
    It looks like '$UNK' is read from user input and it is used to as a redirect. Ensure
    '$UNK' is not externally controlled, otherwise this is an open redirect.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.1 Insecue Redirect
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation
      version: '4'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.possible-user-input-redirect.unknown-value-in-redirect
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.express.security.audit.res-render-injection.res-render-injection
  message: |
    If an attacker controls the x in res.render(x) then they can cause code to load that was not intended to run on the server.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-706: Use of Incorrectly-Resolved Name or Reference'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.res-render-injection.res-render-injection
  patterns:
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $RES.render(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $RES.render(<... $REQ.$BODY ...>,...)
- id: javascript.express.security.audit.xss.direct-response-write.direct-response-write
  message: Detected direclty writing to a Response object. This bypasses any HTML
    escaping and may expose your app to a cross-site scripting (XSS) vulnerability.
    Instead, use 'resp.render()' to render safely escaped HTML.
  languages:
  - javascript
  - typescript
  severity: ERROR
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.direct-response-write.direct-response-write
  patterns:
  - pattern-either:
    - pattern-inside: function ($REQ, $RES) {...}
    - pattern-inside: function $FUNC($REQ, $RES) {...}
    - pattern-inside: function ($REQ, $RES, $NEXT) {...}
    - pattern-inside: function $FUNC($REQ, $RES, $NEXT) {...}
    - pattern-inside: $X = function $FUNC($REQ, $RES) {...}
    - pattern-inside: $X = function $FUNC($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-not: $RES.write("...")
  - pattern-not: $RES.send("...")
  - pattern-either:
    - pattern: $RES.write(...)
    - pattern: $RES.send(...)
- id: javascript.express.security.audit.xss.ejs.explicit-unescape.template-explicit-unescape
  message: |
    Detected an explicit unescape in an EJS template, using
    '<%- ... %>' If external data can reach these locations,
    your application is exposed to a cross-site scripting (XSS)
    vulnerability. Use '<%= ... %>' to escape this data. If you
    need escaping, ensure no external data can reach this location.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - http://www.managerjs.com/blog/2015/05/will-ejs-escape-save-me-from-xss-sorta/
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.ejs.explicit-unescape.template-explicit-unescape
  languages:
  - regex
  paths:
    include:
    - '*.ejs'
    - '*.html'
  severity: WARNING
  pattern-regex: <%-((?!include).)*?%>
  fix-regex:
    regex: <%-(.*?)%>
    replacement: <%=\1%>
- id: javascript.express.security.audit.xss.ejs.var-in-href.var-in-href
  message: |
    Detected a template variable used in an anchor tag with
    the 'href' attribute. This allows a malicious actor to
    input the 'javascript:' URI and is subject to cross-
    site scripting (XSS) attacks. If using a relative URL,
    start with a literal forward slash and concatenate the URL,
    like this: href='/<%= link %>'. You may also consider setting
    the Content Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI
    - https://github.com/pugjs/pug/issues/2952
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.ejs.var-in-href.var-in-href
  languages:
  - regex
  paths:
    include:
    - '*.ejs'
    - '*.html'
  severity: WARNING
  pattern-regex: <a.*href\s*=[^>]*?[^\/&=]<%.*?%>.*?>
- id: javascript.express.security.audit.xss.ejs.var-in-script-src.var-in-script-src
  message: Detected a template variable used as the 'src' in a script tag. Although
    template variables are HTML escaped, HTML escaping does not always prevent malicious
    URLs from being injected and could results in a cross-site scripting (XSS) vulnerability.
    Prefer not to dynamically generate the 'src' attribute and use static URLs instead.
    If you must do this, carefully check URLs against an allowlist and be sure to
    URL-encode the result.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough
    - https://github.com/ESAPI/owasp-esapi-js
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.ejs.var-in-script-src.var-in-script-src
  languages:
  - generic
  paths:
    include:
    - '*.ejs'
    - '*.html'
  severity: WARNING
  patterns:
  - pattern-inside: <script ...>
  - pattern-either:
    - pattern-inside: src = '...'
    - pattern-inside: src = "..."
  - pattern: <% ... >
- id: javascript.express.security.audit.xss.ejs.var-in-script-tag.var-in-script-tag
  message: Detected a template variable used in a script tag. Although template variables
    are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS)
    attacks when used directly in JavaScript. If you need this data on the rendered
    page, consider placing it in the HTML portion (outside of a script tag). Alternatively,
    use a JavaScript-specific encoder, such as the one available in OWASP ESAPI.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough
    - https://github.com/ESAPI/owasp-esapi-js
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.ejs.var-in-script-tag.var-in-script-tag
  languages:
  - generic
  paths:
    include:
    - '*.ejs'
    - '*.html'
  severity: WARNING
  patterns:
  - pattern-inside: <script ...> ... </script>
  - pattern-not-inside: <script ... $ATTR = "..." ...>
  - pattern-not-inside: <script ... $ATTR = '...' ...>
  - pattern: <% ... >
- id: javascript.express.security.audit.xss.mustache.escape-function-overwrite.escape-function-overwrite
  message: |
    The Mustache escape function is being overwritten. This could bypass
    HTML escaping safety measures built into the rendering engine, exposing
    your application to cross-site scripting (XSS) vulnerabilities. If you
    need unescaped HTML, use the triple brace operator in your template:
    '{{{ ... }}}'.
  languages:
  - javascript
  - typescript
  severity: WARNING
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://github.com/janl/mustache.js/#variables
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.mustache.escape-function-overwrite.escape-function-overwrite
  pattern-either:
  - pattern: Mustache.escape = ...
  - patterns:
    - pattern-inside: |
        $MUSTACHE = require("mustache");
        ...
    - pattern: $MUSTACHE.escape = ...
- id: javascript.express.security.audit.xss.mustache.explicit-unescape.template-explicit-unescape
  message: |
    Detected an explicit unescape in a Mustache template, using
    triple braces '{{{...}}}' or ampersand '&'. If external data
    can reach these locations,
    your application is exposed to a cross-site scripting (XSS)
    vulnerability. If you must do this, ensure no external data
    can reach this location.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://github.com/janl/mustache.js/#variables
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.mustache.explicit-unescape.template-explicit-unescape
  languages:
  - regex
  paths:
    include:
    - '*.mustache'
    - '*.hbs'
    - '*.html'
  severity: WARNING
  pattern-either:
  - pattern-regex: '{{{((?!include).)*?}}}'
  - pattern-regex: '{{[^}&]*&[^}&]*}}'
- id: javascript.express.security.audit.xss.mustache.var-in-href.var-in-href
  message: |
    Detected a template variable used in an anchor tag with
    the 'href' attribute. This allows a malicious actor to
    input the 'javascript:' URI and is subject to cross-
    site scripting (XSS) attacks. If using a relative URL,
    start with a literal forward slash and concatenate the URL,
    like this: href='/{{link}}'. You may also consider setting
    the Content Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI
    - https://github.com/pugjs/pug/issues/2952
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.mustache.var-in-href.var-in-href
  languages:
  - regex
  paths:
    include:
    - '*.mustache'
    - '*.hbs'
    - '*.html'
  severity: WARNING
  pattern-regex: <a.*href\s*=(\s|['"])*?{{.*?}}.*
- id: javascript.express.security.audit.xss.mustache.var-in-script-tag.var-in-script-tag
  message: Detected a template variable used in a script tag. Although template variables
    are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS)
    attacks when used directly in JavaScript. If you need this data on the rendered
    page, consider placing it in the HTML portion (outside of a script tag). Alternatively,
    use a JavaScript-specific encoder, such as the one available in OWASP ESAPI.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough
    - https://github.com/ESAPI/owasp-esapi-js
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.mustache.var-in-script-tag.var-in-script-tag
  languages:
  - generic
  paths:
    include:
    - '*.mustache'
    - '*.hbs'
    - '*.html'
  severity: WARNING
  patterns:
  - pattern-inside: <script ...> ... </script>
  - pattern: '{{ ... }}'
- id: javascript.express.security.audit.xss.pug.and-attributes.template-and-attributes
  message: |
    Detected a unescaped variables using '&attributes'.
    If external data can reach these locations,
    your application is exposed to a cross-site scripting (XSS)
    vulnerability. If you must do this, ensure no external data
    can reach this location.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://pugjs.org/language/attributes.html#attributes
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.pug.and-attributes.template-and-attributes
  languages:
  - regex
  paths:
    include:
    - '*.pug'
  severity: WARNING
  pattern-regex: .*&attributes.*
- id: javascript.express.security.audit.xss.pug.explicit-unescape.template-explicit-unescape
  message: |
    Detected an explicit unescape in a Pug template, using either
    '!=' or '!{...}'. If external data can reach these locations,
    your application is exposed to a cross-site scripting (XSS)
    vulnerability. If you must do this, ensure no external data
    can reach this location.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://pugjs.org/language/code.html#unescaped-buffered-code
    - https://pugjs.org/language/attributes.html#unescaped-attributes
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.pug.explicit-unescape.template-explicit-unescape
  languages:
  - regex
  paths:
    include:
    - '*.pug'
  severity: WARNING
  pattern-either:
  - pattern-regex: \w.*(!=)[^=].*
  - pattern-regex: '!{.*?}'
- id: javascript.express.security.audit.xss.pug.var-in-href.var-in-href
  message: |
    Detected a template variable used in an anchor tag with
    the 'href' attribute. This allows a malicious actor to
    input the 'javascript:' URI and is subject to cross-
    site scripting (XSS) attacks. If using a relative URL,
    start with a literal forward slash and concatenate the URL,
    like this: a(href='/'+url). You may also consider setting
    the Content Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://github.com/pugjs/pug/issues/2952
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.pug.var-in-href.var-in-href
  languages:
  - regex
  paths:
    include:
    - '*.pug'
  severity: WARNING
  pattern-regex: a\(.*href=[^'"].*\)
- id: javascript.express.security.audit.xss.pug.var-in-script-tag.var-in-script-tag
  message: |
    Detected a template variable used in a script tag.
    Although template variables are HTML escaped, HTML
    escaping does not always prevent cross-site scripting (XSS)
    attacks when used directly in JavaScript. If you need this
    data on the rendered page, consider placing it in the HTML
    portion (outside of a script tag). Alternatively, use a
    JavaScript-specific encoder, such as the one available
    in OWASP ESAPI.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough
    - https://github.com/ESAPI/owasp-esapi-js
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.audit.xss.pug.var-in-script-tag.var-in-script-tag
  languages:
  - regex
  paths:
    include:
    - '*.pug'
  severity: WARNING
  pattern-either:
  - pattern-regex: script\s*=[A-Za-z0-9]+
  - pattern-regex: script\s*=.*["']\s*\+.*
  - pattern-regex: script\s*=[^'"]+\+.*
  - pattern-regex: script\(.*?\)\s*=\s*[A-Za-z0-9]+
  - pattern-regex: script\(.*?\)\s*=\s*.*["']\s*\+.*
  - pattern-regex: script\(.*?\)\s*=\s*[^'"]+\+.*
- id: javascript.express.security.express-expat-xxe.express-expat-xxe
  mode: taint
  message: |
    Make sure that unverified user data can not reach the XML Parser,
    as it can result in XML External or Internal Entity (XXE) Processing vulnerabilities
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.2 Insecue XML Deserialization
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention
      version: '4'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-expat-xxe.express-expat-xxe
  severity: ERROR
  languages:
  - javascript
  - typescript
  pattern-sources:
  - patterns:
    - pattern-either:
      - pattern-inside: function ... ($REQ, $RES) {...}
      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
      - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
    - pattern-either:
      - pattern: $REQ.$QUERY
      - pattern: $REQ.$BODY.$PARAM
  pattern-sinks:
  - patterns:
    - pattern-inside: |
        require('node-expat');
        ...
    - pattern-either:
      - pattern-inside: |
          $PARSER = new $EXPAT.Parser(...);
          ...
      - pattern-inside: |
          $PARSER = new Parser(...);
          ...
    - pattern-either:
      - pattern: $PARSER.parse(...)
      - pattern: $PARSER.write(...)
- id: javascript.express.security.express-jwt-hardcoded-secret.express-jwt-hardcoded-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.2 Static API keys or secret
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-jwt-hardcoded-secret.express-jwt-hardcoded-secret
  patterns:
  - pattern-inside: |
      $JWT = require('express-jwt');
      ...
  - pattern-either:
    - pattern: |
        $JWT(<... {secret: "..."} ...>,...);
    - pattern: |
        $OPTS = <... {secret: "..."} ...>;
        ...
        $JWT($OPTS,...);
- id: javascript.express.security.express-phantom-injection.express-phantom-injection
  message: |
    If unverified user data can reach the `phantom` methods it can result in Server-Side Request Forgery vulnerabilities
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-phantom-injection.express-phantom-injection
  severity: ERROR
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('phantom');
      ...
  - pattern-inside: |
      require('express');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $PAGE.open(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.setContent(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.open(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.setContent(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.openUrl(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.openUrl(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.evaluateJavaScript(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.evaluateJavaScript(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.property("content",<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.property("content",<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.open(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.open(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.setContent(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.setContent(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.openUrl(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.openUrl(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.evaluateJavaScript(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.evaluateJavaScript(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.property("content",<... $INPUT ...>,...);
    - pattern: |-
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.property("content",<... $INPUT ...>,...);
- id: javascript.express.security.express-puppeteer-injection.express-puppeteer-injection
  message: |
    If unverified user data can reach the `puppeteer` methods it can result in Server-Side Request Forgery vulnerabilities
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-puppeteer-injection.express-puppeteer-injection
  severity: ERROR
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('puppeteer');
      ...
  - pattern-inside: |
      require('express');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $PAGE.goto(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.goto(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.setContent(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.setContent(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.evaluate(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.evaluate(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.evaluateHandle(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.evaluateHandle(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.evaluateOnNewDocument(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.evaluateOnNewDocument(<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.evaluate($CODE,<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.evaluate($CODE,<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.evaluateHandle($CODE,<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.evaluateHandle($CODE,<... $REQ.$BODY ...>,...)
    - pattern: $PAGE.evaluateOnNewDocument($CODE,<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $PAGE.evaluateOnNewDocument($CODE,<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.goto(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.goto(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.setContent(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.setContent(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.evaluate(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.evaluate(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.evaluateHandle(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.evaluateHandle(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.evaluateOnNewDocument(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.evaluateOnNewDocument(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.evaluate($CODE,<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.evaluate($CODE,<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.evaluateHandle($CODE,<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.evaluateHandle($CODE,<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $PAGE.evaluateOnNewDocument($CODE,<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $PAGE.evaluateOnNewDocument($CODE,<... $INPUT ...>,...);
- id: javascript.express.security.express-sandbox-injection.express-sandbox-code-injection
  mode: taint
  message: |
    Make sure that unverified user data can not reach `sandbox`.
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-sandbox-injection.express-sandbox-code-injection
  pattern-sources:
  - patterns:
    - pattern-either:
      - pattern-inside: function ... ($REQ, $RES) {...}
      - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
      - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
      - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
    - pattern-either:
      - pattern: $REQ.$QUERY
      - pattern: $REQ.$BODY.$PARAM
  pattern-sinks:
  - patterns:
    - pattern-inside: |
        $SANDBOX = require('sandbox');
        ...
    - pattern-either:
      - patterns:
        - pattern-inside: |
            $S = new $SANDBOX(...);
            ...
        - pattern: |
            $S.run(...)
      - pattern: |
          new $SANDBOX($OPTS).run(...)
      - pattern: |
          new $SANDBOX().run(...)
- id: javascript.express.security.express-vm2-injection.express-vm2-code-injection
  message: |
    Make sure that unverified user data can not reach `vm2`.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-vm2-injection.express-vm2-code-injection
  patterns:
  - pattern-inside: |
      require('vm2');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: |
        $VM = new VM(...);
        ...
        $VM.run(<... $REQ.$QUERY.$FOO ...>,...);
    - pattern: |
        $VM = new VM(...);
        ...
        $CODE = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.run(<... $CODE ...>,...);
    - pattern: |
        $CODE = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM = new VM(...);
        ...
        $VM.run(<... $CODE ...>,...);
    - pattern: |
        new VM(...).run(<... $REQ.$QUERY.$FOO ...>,...);
    - pattern: |
        $CODE = <... $REQ.$QUERY.$FOO ...>;
        ...
        new VM(...).run($CODE,...);
    - pattern: |
        $VM = new NodeVM(...);
        ...
        $VM.run(<... $REQ.$QUERY.$FOO ...>,...);
    - pattern: |
        $VM = new NodeVM(...);
        ...
        $CODE = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.run($CODE,...);
    - pattern: |
        $CODE = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM = new NodeVM(...);
        ...
        $VM.run($CODE,...);
    - pattern: |
        new NodeVM(...).run(<... $REQ.$QUERY.$FOO ...>,...);
    - pattern: |
        $CODE = <... $REQ.$QUERY.$FOO ...>;
        ...
        new NodeVM(...).run(<... $CODE ...>,...);
    - pattern: |
        $CODE = <... $REQ.$QUERY.$FOO ...>;
        ...
        new VMScript(<... $CODE ...>,...);
    - pattern: |
        $VM = new VM(...);
        ...
        $VM.run(<... $REQ.$BODY ...>,...);
    - pattern: |
        $VM = new VM(...);
        ...
        $CODE = <... $REQ.$BODY ...>;
        ...
        $VM.run(<... $CODE ...>,...);
    - pattern: |
        $CODE = <... $REQ.$BODY ...>;
        ...
        $VM = new VM(...);
        ...
        $VM.run(<... $CODE ...>,...);
    - pattern: |
        new VM(...).run(<... $REQ.$BODY ...>,...);
    - pattern: |
        $CODE = <... $REQ.$BODY ...>;
        ...
        new VM(...).run($CODE,...);
    - pattern: |
        $VM = new NodeVM(...);
        ...
        $VM.run(<... $REQ.$BODY ...>,...);
    - pattern: |
        $VM = new NodeVM(...);
        ...
        $CODE = <... $REQ.$BODY ...>;
        ...
        $VM.run($CODE,...);
    - pattern: |
        $CODE = <... $REQ.$BODY ...>;
        ...
        $VM = new NodeVM(...);
        ...
        $VM.run($CODE,...);
    - pattern: |
        new NodeVM(...).run(<... $REQ.$BODY ...>,...);
    - pattern: |
        $CODE = <... $REQ.$BODY ...>;
        ...
        new NodeVM(...).run(<... $CODE ...>,...);
    - pattern: |
        $CODE = <... $REQ.$BODY ...>;
        ...
        new VMScript(<... $CODE ...>,...);
- id: javascript.express.security.express-vm2-injection.express-vm2-context-injection
  message: |
    Make sure that unverified user data can not reach `vm2`.
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-vm2-injection.express-vm2-context-injection
  patterns:
  - pattern-inside: |
      require('vm2');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: |
        new VM({sandbox: <... $REQ.$QUERY.$FOO ...>},...);
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$QUERY.$FOO} ...>;
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $OPTS = {sandbox: <... $REQ.$QUERY.$FOO ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        new NodeVM({sandbox: <... $REQ.$QUERY.$FOO ...>},...);
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$QUERY.$FOO} ...>;
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $OPTS = {sandbox: <... $REQ.$QUERY.$FOO ...>};
        ...
        new NodeVM($OPTS,...);
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new NodeVM($OPTS,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new NodeVM($OPTS,...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new NodeVM($OPTS,...);
    - pattern: |
        new VM({sandbox: <... $REQ.$BODY ...>},...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$BODY} ...>;
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        new VM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $OPTS = {sandbox: <... $REQ.$BODY ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new VM($OPTS,...);
    - pattern: |
        new NodeVM({sandbox: <... $REQ.$BODY ...>},...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$BODY} ...>;
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        new NodeVM({sandbox: <... $CONTEXT ...>},...);
    - pattern: |
        $OPTS = {sandbox: <... $REQ.$BODY ...>};
        ...
        new NodeVM($OPTS,...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new NodeVM($OPTS,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new NodeVM($OPTS,...);
    - pattern: |-
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $OPTS = {sandbox: <... $CONTEXT ...>};
        ...
        new NodeVM($OPTS,...);
- id: javascript.express.security.express-vm-injection.express-vm-runincontext-context-injection
  message: |
    Make sure that unverified user data can not reach vm.runInContext.
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-vm-injection.express-vm-runincontext-context-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$QUERY.$FOO} ...>;
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$BODY} ...>;
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $VM.runInContext($CODE,<... $CONTEXT ...>,...);
- id: javascript.express.security.express-vm-injection.express-vm-runinnewcontext-context-injection
  message: |
    Make sure that unverified user data can not reach vm.runInNewContext.
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-vm-injection.express-vm-runinnewcontext-context-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: |
        $VM.runInNewContext($CODE,<... $REQ.$QUERY.$FOO ...>,...);
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$QUERY.$FOO} ...>;
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $VM.runInNewContext($CODE,<... $REQ.$BODY ...>,...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$BODY} ...>;
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
- id: javascript.express.security.express-vm-injection.express-vm-compilefunction-context-injection
  message: |
    Make sure that unverified user data can not reach vm.compileFunction.
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-vm-injection.express-vm-compilefunction-context-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: |
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $REQ.$QUERY.$FOO ...>},...);
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$QUERY.$FOO} ...>;
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $OPTS = {parsingContext: <... $REQ.$QUERY.$FOO ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
    - pattern: |
        $CONTEXT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $OPTS = {parsingContext: <... $CONTEXT ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$QUERY.$FOO ...>};
        ...
        $OPTS = {parsingContext: <... $CONTEXT ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
    - pattern: |
        $VAR = <... $REQ.$QUERY.$FOO ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $OPTS = {parsingContext: <... $CONTEXT ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
    - pattern: |
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $REQ.$BODY ...>},...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = <... {$NAME:$REQ.$BODY} ...>;
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
    - pattern: |
        $OPTS = {parsingContext: <... $REQ.$BODY ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
    - pattern: |
        $CONTEXT = <... $REQ.$BODY ...>;
        ...
        $OPTS = {parsingContext: <... $CONTEXT ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
    - pattern: |
        $CONTEXT = {$NAME: <... $REQ.$BODY ...>};
        ...
        $OPTS = {parsingContext: <... $CONTEXT ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
    - pattern: |
        $VAR = <... $REQ.$BODY ...>;
        ...
        $CONTEXT = {$NAME: <... $VAR ...>};
        ...
        $OPTS = {parsingContext: <... $CONTEXT ...>};
        ...
        $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
- id: javascript.express.security.express-vm-injection.express-vm-code-injection
  message: |
    Make sure that unverified user data can not reach vm instance.
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-vm-injection.express-vm-code-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $VM.runInContext(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $VM.runInContext(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.runInContext($INPUT,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $VM.runInContext($INPUT,...);
    - pattern: $VM.runInNewContext(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $VM.runInNewContext(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.runInNewContext($INPUT,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $VM.runInNewContext($INPUT,...);
    - pattern: $VM.runInThisContext(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $VM.runInThisContext(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.runInThisContext($INPUT,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $VM.runInThisContext($INPUT,...);
    - pattern: $VM.compileFunction(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $VM.compileFunction(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $VM.compileFunction($INPUT,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $VM.compileFunction($INPUT,...);
    - pattern: new $VM.Script(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: new $VM.Script(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        new $VM.Script($INPUT,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        new $VM.Script($INPUT,...);
- id: javascript.express.security.express-wkhtml-injection.express-wkhtmltoimage-injection
  message: |
    If unverified user data can reach the `phantom` methods it can result in Server-Side Request Forgery vulnerabilities
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-wkhtml-injection.express-wkhtmltoimage-injection
  severity: ERROR
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      $WK = require('wkhtmltoimage');
      ...
  - pattern-inside: |
      require('express');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $WK.generate(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $WK.generate(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $WK.generate(<... $INPUT ...>,...);
    - pattern: |
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $WK.generate(<... $INPUT ...>,...);
- id: javascript.express.security.express-wkhtml-injection.express-wkhtmltopdf-injection
  message: |
    If unverified user data can reach the `phantom` methods it can result in Server-Side Request Forgery vulnerabilities
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-wkhtml-injection.express-wkhtmltopdf-injection
  severity: ERROR
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      $WK = require('wkhtmltopdf');
      ...
  - pattern-inside: |
      require('express');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $WK(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $WK(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $WK(<... $INPUT ...>,...);
    - pattern: |-
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $WK(<... $INPUT ...>,...);
- id: javascript.express.security.express-xml2json-xxe.express-xml2json-xxe
  message: |
    Make sure that unverified user data can not reach the XML Parser,
    as it can result in XML External or Internal Entity (XXE) Processing vulnerabilities
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.2 Insecue XML Deserialization
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention
      version: '4'
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.express-xml2json-xxe.express-xml2json-xxe
  severity: ERROR
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('xml2json');
      ...
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: $EXPAT.toJson(<... $REQ.$QUERY.$FOO ...>,...)
    - pattern: $EXPAT.toJson(<... $REQ.$BODY ...>,...)
    - pattern: |
        $INPUT = <... $REQ.$QUERY.$FOO ...>;
        ...
        $EXPAT.toJson(<... $INPUT ...>,...);
    - pattern: |-
        $INPUT = <... $REQ.$BODY ...>;
        ...
        $EXPAT.toJson(<... $INPUT ...>,...);
- id: javascript.express.security.require-request.require-request
  message: |
    If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
  severity: ERROR
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-706: Use of Incorrectly-Resolved Name or Reference'
    source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
    category: security
    technology:
    - express
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.express.security.require-request.require-request
  patterns:
  - pattern-either:
    - pattern-inside: function ... ($REQ, $RES) {...}
    - pattern-inside: function ... ($REQ, $RES, $NEXT) {...}
    - pattern-inside: $APP.get(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.post(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.put(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.head(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.delete(..., function $FUNC($REQ, $RES) {...})
    - pattern-inside: $APP.options(..., function $FUNC($REQ, $RES) {...})
  - pattern-either:
    - pattern: require(<... $REQ.$QUERY.$FOO ...>)
    - pattern: require(<... $REQ.$BODY ...>)
- id: javascript.fbjs.security.audit.insecure-createnodesfrommarkup.insecure-createnodesfrommarkup
  patterns:
  - pattern-either:
    - pattern: createNodesFromMarkup(...)
    - pattern: $X.createNodesFromMarkup(...)
  - pattern-not: createNodesFromMarkup("...",...)
  - pattern-not: $X.createNodesFromMarkup("...",...)
  message: |
    User controlled data in a `createNodesFromMarkup` is an anti-pattern that can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - fbjs
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.fbjs.security.audit.insecure-createnodesfrommarkup.insecure-createnodesfrommarkup
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
  message: |
    Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine.
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    category: security
    technology:
    - grpc
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
  severity: ERROR
  languages:
  - javascript
  - typescript
  pattern-either:
  - pattern: |
      require('grpc');
      ...
      $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);
  - pattern: |-
      require('grpc');
      ...
      $CREDS = <... $CREDENTIALS.createInsecure() ...>;
      ...
      $GRPC($ADDR,...,$CREDS,...);
- id: javascript.jose.security.audit.jose-exposed-data.jose-exposed-data
  message: |
    The object is passed strictly to jose.JWT.sign(...)
    Make sure that sensitive information is not exposed through JWT token payload.
  severity: WARNING
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.2 Static API keys or secret
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jose
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jose.security.audit.jose-exposed-data.jose-exposed-data
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      require('jose');
      ...
  - pattern-either:
    - patterns:
      - pattern-inside: function (...,$INPUT,...) {...}
      - pattern-either:
        - pattern: $JOSE.JWT.sign($INPUT,...)
        - pattern: $JWT.sign($INPUT,...)
    - patterns:
      - pattern-inside: function $F(...,$INPUT,...) {...}
      - pattern-either:
        - pattern: $JOSE.JWT.sign($INPUT,...)
        - pattern: $JWT.sign($INPUT,...)
- id: javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.2 Static API keys or secret
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    references:
    - https://cwe.mitre.org/data/definitions/522.html
    category: security
    technology:
    - jose
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  severity: ERROR
  pattern-either:
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $T = JWT.sign({password:...},...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $T = JWT.sign({password:...},...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = {password:...};
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = {password:...};
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = {password:...};
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = {password:...};
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P.password = ...;
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P.password = ...;
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = Object.assign(...,{password:...},...);
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = Object.assign(...,{password:...},...);
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = Object.assign(...,{password:...},...);
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = Object.assign(...,{password:...},...);
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $T = JWT.sign(Object.assign(...,{password:...},...),...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $T = JWT.sign(Object.assign(...,{password:...},...),...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $T = JWT.sign({$U:{password:...}},...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $T = JWT.sign({$U:{password:...}},...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = {$U:{password:...}};
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = {$U:{password:...}};
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = {$U:{password:...}};
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = {$U:{password:...}};
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P.$U.password = ...;
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P.$U.password = ...;
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = Object.assign(...,{$U:{password:...}},...);
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $P = Object.assign(...,{$U:{password:...}},...);
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = Object.assign(...,{$U:{password:...}},...);
      ...
      var $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $P = Object.assign(...,{$U:{password:...}},...);
      ...
      $T = JWT.sign($P,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
- id: javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.2 Static API keys or secret
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jose
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
  languages:
  - javascript
  - typescript
  severity: ERROR
  pattern-either:
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      JWT.verify($P, "...", ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $T = JWT.sign($P, "...", ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $T = JWT.verify($P, "...", ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      JWT.verify($P, JWK.asKey("..."), ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $KEY = JWK.asKey("...");
      ...
      JWT.verify($P, $KEY, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $T = JWT.sign($P, JWK.asKey("..."), ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $T = JWT.verify($P, JWK.asKey("..."), ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $KEY = JWK.asKey("...");
      ...
      var $T = JWT.sign($P, $KEY, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $KEY = JWK.asKey("...");
      ...
      var $T = JWT.verify($P, $KEY, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      JWT.verify($P, $SECRET, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      var $T = JWT.sign($P, $SECRET, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      var $T = JWT.verify($P, $SECRET, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      JWT.verify($P, JWK.asKey($SECRET), ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      var $KEY = JWK.asKey($SECRET);
      ...
      JWT.verify($P, $KEY, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      var $T = JWT.sign($P, JWK.asKey($SECRET), ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      var $KEY = JWK.asKey($SECRET);
      ...
      var $T = JWT.sign($P, $KEY, ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      var $T = JWT.verify($P, JWK.asKey($SECRET), ...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $SECRET = "...";
      ...
      var $KEY = JWK.asKey($SECRET);
      ...
      var $T = JWT.verify($P, $KEY, ...);
- id: javascript.jose.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.3 Insecue Stateless Session Tokens
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jose
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jose.security.jwt-none-alg.jwt-none-alg
  languages:
  - javascript
  - typescript
  severity: ERROR
  pattern-either:
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      var $T = JWT.verify($P, JWK.None,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      $T = JWT.verify($P, JWK.None,...);
  - pattern: |
      var $JOSE = require("jose");
      ...
      var { JWK, JWT } = $JOSE;
      ...
      JWT.verify($P, JWK.None,...);
- id: javascript.jquery.security.audit.jquery-insecure-method.jquery-insecure-method
  message: User controlled data in a jQuery's `.$METHOD(...)` is an anti-pattern that
    can lead to XSS vulnerabilities
  languages:
  - javascript
  - typescript
  severity: WARNING
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://owasp.org/www-community/attacks/xss/
    - https://bugs.jquery.com/ticket/9521
    category: security
    technology:
    - jquery
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jquery.security.audit.jquery-insecure-method.jquery-insecure-method
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern: $.$METHOD($VAR,...)
      - pattern: $(...).$METHOD($VAR,...)
      - pattern: jQuery.$METHOD($VAR,...)
      - pattern: jQuery(...).$METHOD($VAR,...)
    - pattern-not: $.$METHOD("...",...)
    - pattern-not: $(...).$METHOD("...",...)
    - pattern-not: jQuery.$METHOD("...",...)
    - pattern-not: jQuery(...).$METHOD("...",...)
    - metavariable-regex:
        metavariable: $METHOD
        regex: ^(html|append|prepend|wrap|wrapInner|wrapAll|before|after|globalEval|getScript)$
  - patterns:
    - pattern-either:
      - pattern: $(...).$METHOD($VAR,...)
      - pattern: jQuery(...).$METHOD($VAR,...)
    - pattern-not: $("...",...).$METHOD(...)
    - pattern-not: jQuery("...",...).$METHOD(...)
    - metavariable-regex:
        metavariable: $METHOD
        regex: ^(appendTo|insertAfter|insertBefore|prependTo)$
- id: javascript.jquery.security.audit.jquery-insecure-selector.jquery-insecure-selector
  message: User controlled data in a `$(...)` is an anti-pattern that can lead to
    XSS vulnerabilities
  languages:
  - javascript
  - typescript
  severity: WARNING
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://owasp.org/www-community/attacks/xss/
    - https://bugs.jquery.com/ticket/9521
    category: security
    technology:
    - jquery
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jquery.security.audit.jquery-insecure-selector.jquery-insecure-selector
  patterns:
  - pattern-either:
    - pattern: |
        $(<... window ...>)
    - pattern: |
        $(<... location ...>)
    - pattern: |
        $X = <... window ...>;
        ...
        $(<... $X ...>);
    - pattern: |
        $X = <... location ...>;
        ...
        $(<... $X ...>);
    - patterns:
      - pattern-either:
        - pattern-inside: |
            function $FUNC(..., $Y, ...) {
              ...
            }
        - pattern-inside: |
            function (..., $Y, ...) {
              ...
            }
        - pattern-inside: |
            function $FUNC(...,$Z,...) {
              ...
              $Y = <... $Z ...>;
              ...
            }
        - pattern-inside: |
            function (...,$Z,...) {
              ...
              $Y = <... $Z ...>;
              ...
            }
      - pattern-either:
        - pattern: |
            $(<... $Y ...>)
        - pattern: |
            $("..." + (<... $Y ...>))
        - pattern: |
            $((<... $Y ...>) + "...")
      - pattern-not-inside: |
          $JQUERY.each(function($INDEX, $Y) {
            ...
          })
  - pattern-not: |
      $(window)
  - pattern-not: |
      $(document)
  - pattern-not: |
      $(this)
- id: javascript.jquery.security.audit.prohibit-jquery-html.prohibit-jquery-html
  patterns:
  - pattern: |
      $X.html(...)
  - pattern-not: |
      $X.html("...",...)
  message: |
    JQuery's html function can lead to XSS. If the string is plain test, use the text function instead.
    Otherwise, use a function that escapes html such as edx's HtmlUtils.setHtml.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss.html#javascript-concat-html
    - https://stackoverflow.com/questions/8318581/html-vs-innerhtml-jquery-javascript-xss-attacks
    category: security
    technology:
    - jquery
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jquery.security.audit.prohibit-jquery-html.prohibit-jquery-html
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.jsonwebtoken.security.audit.jwt-decode-without-verify.jwt-decode-without-verify
  message: |
    Detected the decoding of a JWT token without a verify step.
    JWT tokens must be verified before use, otherwise the token's
    integrity is unknown. This means a malicious actor could forge
    a JWT token with any claims. Call '.verify()' before using the token.
  metadata:
    cwe: 'CWE-345: Insufficient Verification of Data Authenticity'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.3 Insecue Stateless Session Tokens
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jsonwebtoken.security.audit.jwt-decode-without-verify.jwt-decode-without-verify
  languages:
  - javascript
  - typescript
  severity: WARNING
  patterns:
  - pattern-inside: |
      $JWT = require('jsonwebtoken');
      ...
  - pattern-either:
    - pattern: |
        $JWT.decode(...)
    - pattern: |
        $JWT.decode(...).$PARAM
  - pattern-not-inside: |
      ...
      $JWT.verify(...)
      ...
- id: javascript.jsonwebtoken.security.audit.jwt-exposed-data.jwt-exposed-data
  message: |
    The object is passed strictly to jsonwebtoken.sign(...)
    Make sure that sensitive information is not exposed through JWT token payload.
  severity: WARNING
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.3 Insecue Stateless Session Tokens
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jsonwebtoken.security.audit.jwt-exposed-data.jwt-exposed-data
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      $JWT = require('jsonwebtoken');
      ...
  - pattern-either:
    - pattern-inside: function (...,$INPUT,...) {...}
    - pattern-inside: function $F(...,$INPUT,...) {...}
  - pattern: $JWT.sign($INPUT,...)
- id: javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  - typescript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.2 Static API keys or secret
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    references:
    - https://cwe.mitre.org/data/definitions/522.html
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  severity: ERROR
  patterns:
  - pattern-inside: |
      $JWT = require("jsonwebtoken");
      ...
  - pattern-either:
    - pattern: |
        $JWT.sign({password:...},...);
    - pattern: |
        $P = {password:...};
        ...
        $JWT.sign($P,...);
    - pattern: |
        $P.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        $P = Object.assign(...,{password:...},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        $JWT.sign({$U:{password:...}},...);
    - pattern: |
        $P = {$U:{password:...}};
        ...
        $JWT.sign($P,...);
    - pattern: |
        $P.$U.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
- id: javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.2 Static API keys or secret
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
  languages:
  - javascript
  - typescript
  severity: ERROR
  patterns:
  - pattern-inside: |
      $JWT = require("jsonwebtoken");
      ...
  - pattern-either:
    - pattern: |
        $JWT.sign($P, "...", ...);
    - pattern: |
        $JWT.verify($P, "...", ...);
    - patterns:
      - pattern-inside: |
          $SECRET = "...";
          ...
      - pattern-either:
        - pattern: $JWT.sign($P, $SECRET, ...)
        - pattern: $JWT.verify($P, $SECRET, ...)
- id: javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.3 Insecue Stateless Session Tokens
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
  languages:
  - javascript
  - typescript
  severity: ERROR
  patterns:
  - pattern-inside: |
      $JWT = require("jsonwebtoken");
      ...
  - pattern: $JWT.verify($P, $X, {algorithms:[...,'none',...]},...)
- id: javascript.lang.security.audit.dangerous-spawn-shell.dangerous-spawn-shell
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.dangerous-spawn-shell.dangerous-spawn-shell
  message: |
    Detected non-literal calls to $EXEC(). This could lead to a command
    injection vulnerability.
  patterns:
  - pattern-either:
    - pattern: spawn(...)
    - pattern: spawnSync(...)
    - pattern: $CP.spawn(...)
    - pattern: $CP.spawnSync(...)
  - pattern-either:
    - patterns:
      - pattern-either:
        - pattern: |
            $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",["-c", $ARG, ...],...)
        - patterns:
          - pattern: $EXEC($CMD,["-c", $ARG, ...],...)
          - pattern-inside: |
              $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/"
              ...
      - pattern-not: |
          $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",["-c", "...", ...],...)
    - patterns:
      - pattern-either:
        - pattern: |
            $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",[$ARG, ...],...)
        - patterns:
          - pattern: $EXEC($CMD,[$ARG, ...],...)
          - pattern-inside: |
              $CMD = "=~/(sh|bash|ksh|csh|tcsh|zsh)/"
              ...
      - pattern-not: |
          $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",["...", ...],...)
  - pattern-not-inside: |
      $ARG = "..."
      ...
  - pattern-either:
    - pattern-inside: |
        require('child_process')
        ...
    - pattern-inside: |
        import 'child_process'
        ...
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.audit.non-constant-sql-query.non-constant-sql-query
  patterns:
  - pattern: $DB.sequelize.query(...)
  - pattern-not: $DB.sequelize.query("...")
  message: |
    Non-constant SQL query detected. Ensure this is not controlled
    by external data, otherwise this is a SQL injection.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    category: security
    technology:
    - sequelize
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.non-constant-sql-query.non-constant-sql-query
  severity: INFO
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.audit.path-traversal.path-join-resolve-traversal.path-join-resolve-traversal
  patterns:
  - pattern-inside: |
      ...
      $PATH = require('path');
      ...
  - pattern-either:
    - pattern-inside: function $FUNC(...,$INPUT,...) {...}
    - pattern-inside: function (...,$INPUT,...) {...}
  - pattern-either:
    - pattern: $PATH.join(...,<... $INPUT ...>,...)
    - pattern: $PATH.join(...,<... $INPUT.$FOO ...>,...)
    - pattern: $PATH.join(...,<... $INPUT.$FOO.$BAR ...>,...)
    - pattern: |
        $VAR = <... $INPUT ...>;
        ...
        $PATH.join(...,<... $VAR ...>,...);
    - pattern: |
        $VAR = <... $INPUT.$FOO ...>;
        ...
        $PATH.join(...,<... $VAR ...>,...);
    - pattern: |
        $VAR = <... $INPUT.$FOO.$BAR ...>;
        ...
        $PATH.join(...,<... $VAR ...>,...);
    - pattern: $PATH.resolve(...,<... $INPUT ...>,...)
    - pattern: $PATH.resolve(...,<... $INPUT.$FOO ...>,...)
    - pattern: $PATH.resolve(...,<... $INPUT.$FOO.$BAR ...>,...)
    - pattern: |
        $VAR = <... $INPUT ...>;
        ...
        $PATH.resolve(...,<... $VAR ...>,...);
    - pattern: |
        $VAR = <... $INPUT.$FOO ...>;
        ...
        $PATH.resolve(...,<... $VAR ...>,...);
    - pattern: |
        $VAR = <... $INPUT.$FOO.$BAR ...>;
        ...
        $PATH.resolve(...,<... $VAR ...>,...);
  message: |
    Possible writing outside of the destination,
    make sure that the target path is nested in the intended destination
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A5: Broken Access Control'
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (Path
      Traversal)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.path-traversal.path-join-resolve-traversal.path-join-resolve-traversal
  severity: WARNING
- id: javascript.lang.security.audit.spawn-shell-true.spawn-shell-true
  patterns:
  - pattern-either:
    - pattern: |
        spawn(...,{shell: $SHELL})
    - pattern: |
        spawnSync(...,{shell: $SHELL})
    - pattern: |
        $CP.spawn(...,{shell: $SHELL})
    - pattern: |
        $CP.spawnSync(...,{shell: $SHELL})
  - pattern-not: |
      spawn(...,{shell: false})
  - pattern-not: |
      spawnSync(...,{shell: false})
  - pattern-not: |
      $CP.spawn(...,{shell: false})
  - pattern-not: |
      $CP.spawnSync(...,{shell: false})
  message: |
    Found '$SPAWN' with '{shell: $SHELL}'. This is dangerous because this call will spawn
    the command using a shell process. Doing so propagates current shell settings and variables, which
    makes it much easier for a malicious actor to execute commands. Use '{shell: false}' instead.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.spawn-shell-true.spawn-shell-true
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.audit.unknown-value-with-script-tag.unknown-value-with-script-tag
  patterns:
  - pattern-inside: |
      $UNK = $ANYFUNC(...);
      ...
      $OTHERFUNC(..., <... $UNK ...>, ...);
  - pattern: $OTHERFUNC(..., <... "=~/.*<script.*/" ...>, ...)
  message: |
    Cannot determine what '$UNK' is and it is used with a '<script>' tag. This
    could be susceptible to cross-site scripting (XSS). Ensure '$UNK' is not
    externally controlled, or sanitize this data.
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://www.developsec.com/2017/11/09/xss-in-a-script-tag/
    - https://github.com/bkimminich/juice-shop/blob/master/routes/videoHandler.js#L64
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.unknown-value-with-script-tag.unknown-value-with-script-tag
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.audit.vm-injection.vm-runincontext-context-injection
  message: |
    Make sure that unverified user data can not reach vm.runInContext.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-runincontext-context-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern-either:
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $VM.runInContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
- id: javascript.lang.security.audit.vm-injection.vm-runinnewcontext-context-injection
  message: |
    Make sure that unverified user data can not reach vm.runInNewContext.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-runinnewcontext-context-injection
  patterns:
  - pattern-inside: |
      ...
      $VM = require('vm');
      ...
  - pattern-either:
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VM.runInNewContext($CODE,<... $INPUT ...>,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $VM.runInNewContext($CODE,<... $INPUT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
    - pattern: |
        function $FUNC(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $VM.runInNewContext($CODE,<... $CONTEXT ...>,...);
          ...
        }
- id: javascript.lang.security.audit.vm-injection.vm-compilefunction-context-injection
  message: |
    Make sure that unverified user data can not reach vm.compileFunction.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-compilefunction-context-injection
  patterns:
  - pattern-inside: |
      ...
      $VM = require('vm');
      ...
  - pattern-either:
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $INPUT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $OPTS = {parsingContext: <... $INPUT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $OPTS = {parsingContext: <... $CONTEXT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $OPTS = {parsingContext: <... $CONTEXT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $OPTS = {parsingContext: <... $CONTEXT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $INPUT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,{parsingContext: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $OPTS = {parsingContext: <... $INPUT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $OPTS = {parsingContext: <... $CONTEXT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $OPTS = {parsingContext: <... $CONTEXT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $OPTS = {parsingContext: <... $CONTEXT ...>};
          ...
          $VM.compileFunction($CODE,$PARAMS,$OPTS,...);
          ...
        }
- id: javascript.lang.security.audit.vm-injection.vm-script-code-injection
  message: |
    Make sure that unverified user data can not reach vm.Script.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-script-code-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern: new $VM.Script($CODE,...)
  - pattern-not: new $VM.Script("...",...)
  - pattern-not-inside: |-
      $CODE = "...";
      ...
- id: javascript.lang.security.audit.vm-injection.vm-sourcetextmodule-code-injection
  message: |
    Make sure that unverified user data can not reach vm.SourceTextModule.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-sourcetextmodule-code-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern: new $VM.SourceTextModule($CODE,...)
  - pattern-not: new $VM.SourceTextModule("...",...)
  - pattern-not-inside: |-
      $CODE = "...";
      ...
- id: javascript.lang.security.audit.vm-injection.vm-runincontext-code-injection
  message: |
    Make sure that unverified user data can not reach vm.runInContext.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-runincontext-code-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern: $VM.runInContext($CODE,...)
  - pattern-not: $VM.runInContext("...",...)
  - pattern-not-inside: |
      $CODE = "...";
      ...
- id: javascript.lang.security.audit.vm-injection.vm-runinnewcontext-code-injection
  message: |
    Make sure that unverified user data can not reach vm.runInNewContext.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-runinnewcontext-code-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern: $VM.runInNewContext($CODE,...)
  - pattern-not: $VM.runInNewContext("...",...)
  - pattern-not-inside: |
      $CODE = "...";
      ...
- id: javascript.lang.security.audit.vm-injection.vm-runinthiscontext-code-injection
  message: |
    Make sure that unverified user data can not reach vm.runInThisContext.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-runinthiscontext-code-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern: $VM.runInThisContext($CODE,...)
  - pattern-not: $VM.runInThisContext("...",...)
  - pattern-not-inside: |
      $CODE = "...";
      ...
- id: javascript.lang.security.audit.vm-injection.vm-compilefunction-code-injection
  message: |
    Make sure that unverified user data can not reach vm.compileFunction.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.audit.vm-injection.vm-compilefunction-code-injection
  patterns:
  - pattern-inside: |
      $VM = require('vm');
      ...
  - pattern: $VM.compileFunction($CODE,...)
  - pattern-not: $VM.compileFunction("...",...)
  - pattern-not-inside: |-
      $CODE = "...";
      ...
- id: javascript.lang.security.detect-child-process.detect-child-process
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.detect-child-process.detect-child-process
  message: |
    Detected non-literal calls to $EXEC(). This could lead to a command
    injection vulnerability.
  patterns:
  - pattern-either:
    - pattern: exec($CMD,...)
    - pattern: execSync($CMD,...)
    - pattern: spawn($CMD,...)
    - pattern: spawnSync($CMD,...)
  - pattern-not-inside: $EXEC("...",...)
  - pattern-not-inside: $EXEC(["...",...],...)
  - pattern-not-inside: |
      $CMD = "..."
      ...
  - pattern-not-inside: |
      $CMD = ["...",...]
      ...
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-disable-mustache-escape.detect-disable-mustache-escape
  metadata:
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-disable-mustache-escape.js
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.detect-disable-mustache-escape.detect-disable-mustache-escape
  message: |
    Markup escaping disabled. This can be used with some template engines to escape
    disabling of HTML entities, which can lead to XSS attacks.
  pattern: $OBJ.escapeMarkup = false
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-eval-with-expression.detect-eval-with-expression
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-eval-with-expression.js
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.detect-eval-with-expression.detect-eval-with-expression
  message: |
    Detected eval(variable), which could allow a malicious actor to run arbitrary code.
  patterns:
  - pattern-either:
    - pattern: eval($OBJ)
    - pattern: window.eval($OBJ)
    - pattern: Function(...,$OBJ)
    - pattern: new Function(...,$OBJ)
  - pattern-not: eval("...")
  - pattern-not: window.eval("...")
  - pattern-not: Function(...,"...")
  - pattern-not: new Function(...,"...")
  - pattern-not-inside: |
      $OBJ = "..."
      ...
      $SOMETHING(..., $OBJ, ...)
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-non-literal-require.detect-non-literal-require
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-require.js
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.detect-non-literal-require.detect-non-literal-require
  message: |
    Detected the use of require(variable). Calling require with a non-literal argument might
    allow an attacker to load an run arbitrary code, or access arbitrary files.
  patterns:
  - pattern: require($OBJ)
  - pattern-not: require('...')
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.spawn-git-clone.spawn-git-clone
  message: |
    Git allows shell commands to be specified in ext URLs for remote repositories.
    For example, git clone 'ext::sh -c whoami% >&2' will execute the whoami command to try to connect to a remote repository.
    Make sure that the URL is not controlled by external input.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.lang.security.spawn-git-clone.spawn-git-clone
  languages:
  - javascript
  - typescript
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: spawn('git', ['clone',...,$F])
    - pattern: $X.spawn('git', ['clone',...,$F])
    - pattern: spawn('git', ['clone',...,$P,$F])
    - pattern: $X.spawn('git', ['clone',...,$P,$F])
  - pattern-not: spawn('git', ['clone',...,"..."])
  - pattern-not: $X.spawn('git', ['clone',...,"..."])
  - pattern-not: spawn('git', ['clone',...,"...","..."])
  - pattern-not: $X.spawn('git', ['clone',...,"...","..."])
- id: javascript.node-expat.security.audit.expat-xxe.expat-xxe
  message: |
    If unverified user data can reach the XML Parser it can result in XML External or
    Internal Entity (XXE) Processing vulnerabilities
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    category: security
    technology:
    - node-expat
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.node-expat.security.audit.expat-xxe.expat-xxe
  severity: WARNING
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-either:
    - pattern: |
        var $EXPAT = require('node-expat');
        ...
        new $EXPAT.Parser(...);
        ...
        $PARSER.parse(...);
    - pattern: |
        var $EXPAT = require('node-expat');
        ...
        new $EXPAT.Parser(...);
        ...
        $PARSER.write(...);
    - pattern: |
        require('node-expat');
        ...
        new Parser(...);
        ...
        $PARSER.parse(...);
    - pattern: |
        require('node-expat');
        ...
        new Parser(...);
        ...
        $PARSER.write(...);
  - pattern-not: |
      var $EXPAT = require('node-expat');
      ...
      new $EXPAT.Parser(...);
      ...
      $PARSER.parse("...");
  - pattern-not: |
      var $EXPAT = require('node-expat');
      ...
      new $EXPAT.Parser(...);
      ...
      $PARSER.write("...");
  - pattern-not: |
      require('node-expat');
      ...
      new Parser(...);
      ...
      $PARSER.parse("...");
  - pattern-not: |
      require('node-expat');
      ...
      new Parser(...);
      ...
      $PARSER.write("...");
  - pattern-not: |
      $X = "...";
      ...
      $PARSER.parse($X);
  - pattern-not: |-
      $X = "...";
      ...
      $PARSER.write($X);
- id: javascript.passport-jwt.security.passport-hardcode.hardcoded-passport-secret
  message: |
    Hardcoded secret used for Passport Strategy.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.5.2 Static API keys or secret
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management
      version: '4'
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.passport-jwt.security.passport-hardcode.hardcoded-passport-secret
  languages:
  - javascript
  - typescript
  severity: ERROR
  pattern-either:
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      new $F({clientSecret: "..."}, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      var $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      var $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      var $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-auth0").Strategy;
      ...
      $S = "...";
      ...
      $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      new $F({clientSecret: "..."}, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      var $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      var $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      var $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth2").Strategy;
      ...
      $S = "...";
      ...
      $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      new $F({secretOrKey: "..."}, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      var $P = {};
      ...
      $P.secretOrKey = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      var $P = {secretOrKey: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      var $S = "...";
      ...
      new $F({secretOrKey: $S}, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.secretOrKey = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {secretOrKey: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      $P = {};
      ...
      $P.secretOrKey = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      $P = {secretOrKey: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      $S = "...";
      ...
      new $F({secretOrKey: $S}, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.secretOrKey = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      $S = "...";
      ...
      var $P = {secretOrKey: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.secretOrKey = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-jwt").Strategy;
      ...
      $S = "...";
      ...
      $P = {secretOrKey: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      new $F({consumerSecret: "..."}, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      var $P = {};
      ...
      $P.consumerSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      var $P = {consumerSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      var $S = "...";
      ...
      new $F({consumerSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      $P = {};
      ...
      $P.consumerSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      $P = {consumerSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      $S = "...";
      ...
      new $F({consumerSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      $S = "...";
      ...
      var $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-google-oauth1").Strategy;
      ...
      $S = "...";
      ...
      $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      new $F({clientSecret: "..."}, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      var $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      var $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      var $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth2").Strategy;
      ...
      $S = "...";
      ...
      $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      new $F({clientSecret: "..."}, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      var $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      var $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      var $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      $P = {};
      ...
      $P.clientSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      $P = {clientSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      $S = "...";
      ...
      new $F({clientSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      $S = "...";
      ...
      var $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.clientSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-facebook").Strategy;
      ...
      $S = "...";
      ...
      $P = {clientSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      new $F({consumerSecret: "..."}, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      var $P = {};
      ...
      $P.consumerSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      var $P = {consumerSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      var $S = "...";
      ...
      new $F({consumerSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      $P = {};
      ...
      $P.consumerSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      $P = {consumerSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      $S = "...";
      ...
      new $F({consumerSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      $S = "...";
      ...
      var $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-twitter").Strategy;
      ...
      $S = "...";
      ...
      $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      new $F({consumerSecret: "..."}, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      var $P = {};
      ...
      $P.consumerSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      var $P = {consumerSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      var $S = "...";
      ...
      new $F({consumerSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      var $S = "...";
      ...
      var $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      $P = {};
      ...
      $P.consumerSecret = "...";
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      $P = {consumerSecret: "..."};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      $S = "...";
      ...
      new $F({consumerSecret: $S}, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      $S = "...";
      ...
      var $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      $S = "...";
      ...
      var $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
  - pattern: |
      var $F = require("passport-oauth1").Strategy;
      ...
      $S = "...";
      ...
      $P = {};
      ...
      $P.consumerSecret = $S;
      ...
      new $F($P, ...);
  - pattern: |-
      var $F = require("passport-oauth1").Strategy;
      ...
      $S = "...";
      ...
      $P = {consumerSecret: $S};
      ...
      new $F($P, ...);
- id: javascript.phantom.security.audit.phantom-injection.phantom-injection
  message: |
    If unverified user data can reach the `phantom` page methods it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - phantom
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.phantom.security.audit.phantom-injection.phantom-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      $PHANTOM = require('phantom');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern-either:
    - pattern: $PAGE.open($INPUT,...)
    - pattern: $PAGE.property("content",$INPUT,...)
    - pattern: $PAGE.setContent($INPUT,...)
    - pattern: $PAGE.openUrl($INPUT,...)
    - pattern: $PAGE.evaluateJavaScript($INPUT,...)
  - pattern-not: $PAGE.open("...",...)
  - pattern-not: $PAGE.property("content","...",...)
  - pattern-not: $PAGE.setContent("...",...)
  - pattern-not: $PAGE.openUrl("...",...)
  - pattern-not: $PAGE.evaluateJavaScript("...",...)
- id: javascript.playwright.security.audit.playwright-addinitscript-code-injection.playwright-addinitscript-code-injection
  message: |
    If unverified user data can reach the `addInitScript` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - playwright
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.playwright.security.audit.playwright-addinitscript-code-injection.playwright-addinitscript-code-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('playwright');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = function $FNAME(...){...};
      ...
  - pattern: $CONTEXT.addInitScript($INPUT,...)
  - pattern-not: $CONTEXT.addInitScript("...",...)
  - pattern-not: $CONTEXT.addInitScript(function(...){...},...)
- id: javascript.playwright.security.audit.playwright-evaluate-arg-injection.playwright-evaluate-arg-injection
  message: |
    If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - playwright
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.playwright.security.audit.playwright-evaluate-arg-injection.playwright-evaluate-arg-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('playwright');
      ...
  - pattern-either:
    - pattern-inside: function $FUNC (...,$INPUT,...) {...}
    - pattern-inside: function (...,$INPUT,...) {...}
  - pattern-either:
    - pattern: $PAGE.evaluate($CODE,...,<... $INPUT ...>,...)
    - pattern: $PAGE.evaluateHandle($CODE,...,<... $INPUT ...>,...)
- id: javascript.playwright.security.audit.playwright-evaluate-code-injection.playwright-evaluate-code-injection
  message: |
    If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - playwright
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.playwright.security.audit.playwright-evaluate-code-injection.playwright-evaluate-code-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('playwright');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = function $FNAME(...){...};
      ...
  - pattern-either:
    - pattern: $PAGE.evaluate($INPUT,...)
    - pattern: $PAGE.evaluateHandle($INPUT,...)
    - pattern: $PAGE.evaluateOnNewDocument($INPUT,...)
  - pattern-not: $PAGE.evaluate("...",...)
  - pattern-not: $PAGE.evaluate(function(...){...},...)
  - pattern-not: $PAGE.evaluateHandle("...",...)
  - pattern-not: $PAGE.evaluateHandle(function(...){...},...)
  - pattern-not: $PAGE.evaluateOnNewDocument("...",...)
  - pattern-not: $PAGE.evaluateOnNewDocument(function(...){...},...)
- id: javascript.playwright.security.audit.playwright-exposed-chrome-devtools.playwright-exposed-chrome-devtools
  message: |
    Remote debugging protocol does not perform any authentication, so exposing it too widely can be a security risk.
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - playwright
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.playwright.security.audit.playwright-exposed-chrome-devtools.playwright-exposed-chrome-devtools
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('playwright');
      ...
  - pattern-either:
    - pattern-regex: --remote-debugging-address
    - pattern-regex: --remote-debugging-port
    - pattern-regex: --remote-debugging-socket-name
    - pattern-regex: --remote-debugging-targets
- id: javascript.playwright.security.audit.playwright-goto-injection.playwright-goto-injection
  message: |
    If unverified user data can reach the `goto` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - playwright
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.playwright.security.audit.playwright-goto-injection.playwright-goto-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('playwright');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern: $PAGE.goto($INPUT,...)
  - pattern-not: $PAGE.goto("...",...)
- id: javascript.playwright.security.audit.playwright-setcontent-injection.playwright-setcontent-injection
  message: |
    If unverified user data can reach the `setContent` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - playwright
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.playwright.security.audit.playwright-setcontent-injection.playwright-setcontent-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('playwright');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern: $PAGE.setContent($INPUT,...)
  - pattern-not: $PAGE.setContent("...",...)
- id: javascript.puppeteer.security.audit.puppeteer-evaluate-arg-injection.puppeteer-evaluate-arg-injection
  message: |
    If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - puppeteer
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.puppeteer.security.audit.puppeteer-evaluate-arg-injection.puppeteer-evaluate-arg-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('puppeteer');
      ...
  - pattern-either:
    - pattern-inside: function $FUNC (...,$INPUT,...) {...}
    - pattern-inside: function (...,$INPUT,...) {...}
  - pattern-either:
    - pattern: $PAGE.evaluate($CODE,...,<... $INPUT ...>,...)
    - pattern: $PAGE.evaluateHandle($CODE,...,<... $INPUT ...>,...)
    - pattern: $PAGE.evaluateOnNewDocument($CODE,...,<... $INPUT ...>,...)
- id: javascript.puppeteer.security.audit.puppeteer-evaluate-code-injection.puppeteer-evaluate-code-injection
  message: |
    If unverified user data can reach the `evaluate` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - puppeteer
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.puppeteer.security.audit.puppeteer-evaluate-code-injection.puppeteer-evaluate-code-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('puppeteer');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = function $FNAME(...){...};
      ...
  - pattern-either:
    - pattern: $PAGE.evaluate($INPUT,...)
    - pattern: $PAGE.evaluateHandle($INPUT,...)
    - pattern: $PAGE.evaluateOnNewDocument($INPUT,...)
  - pattern-not: $PAGE.evaluate("...",...)
  - pattern-not: $PAGE.evaluate(function(...){...},...)
  - pattern-not: $PAGE.evaluateHandle("...",...)
  - pattern-not: $PAGE.evaluateHandle(function(...){...},...)
  - pattern-not: $PAGE.evaluateOnNewDocument("...",...)
  - pattern-not: $PAGE.evaluateOnNewDocument(function(...){...},...)
- id: javascript.puppeteer.security.audit.puppeteer-exposed-chrome-devtools.puppeteer-exposed-chrome-devtools
  message: |
    Remote debugging protocol does not perform any authentication, so exposing it too widely can be a security risk.
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - puppeteer
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.puppeteer.security.audit.puppeteer-exposed-chrome-devtools.puppeteer-exposed-chrome-devtools
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('puppeteer');
      ...
  - pattern-either:
    - pattern-regex: --remote-debugging-address
    - pattern-regex: --remote-debugging-port
    - pattern-regex: --remote-debugging-socket-name
    - pattern-regex: --remote-debugging-targets
- id: javascript.puppeteer.security.audit.puppeteer-goto-injection.puppeteer-goto-injection
  message: |
    If unverified user data can reach the `goto` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - puppeteer
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.puppeteer.security.audit.puppeteer-goto-injection.puppeteer-goto-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('puppeteer');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern: $PAGE.goto($INPUT,...)
  - pattern-not: $PAGE.goto("...",...)
- id: javascript.puppeteer.security.audit.puppeteer-setcontent-injection.puppeteer-setcontent-injection
  message: |
    If unverified user data can reach the `setContent` method it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - puppeteer
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.puppeteer.security.audit.puppeteer-setcontent-injection.puppeteer-setcontent-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('puppeteer');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern: $PAGE.setContent($INPUT,...)
  - pattern-not: $PAGE.setContent("...",...)
- id: javascript.sandbox.security.audit.sandbox-code-injection.sandbox-code-injection
  message: |
    Make sure that unverified user data can not reach `sandbox`.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - sandbox
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.sandbox.security.audit.sandbox-code-injection.sandbox-code-injection
  patterns:
  - pattern-inside: |
      ...
      $SANDBOX = require('sandbox');
      ...
  - pattern-not-inside: |
      $CODE = "...";
      ...
  - pattern-either:
    - patterns:
      - pattern-inside: |
          $S = new $SANDBOX(...);
          ...
      - pattern: $S.run($CODE,...);
    - pattern: |
        new $SANDBOX(...).run($CODE,...);
  - pattern-not-inside: |
      $S = new $SANDBOX(...);
      ...
      $S.run("...",...);
  - pattern-not-inside: new $SANDBOX(...).run("...",...);
- id: javascript.sax.security.audit.sax-xxe.sax-xxe
  message: |
    Use of 'ondoctype' in 'sax' library detected. By default, 'sax'
    won't do anything with custom DTD entity definitions. If you're
    implementing a custom DTD entity definition, be sure not to introduce
    XML External Entity (XXE) vulnerabilities, or be absolutely sure that
    external entities received from a trusted source while processing XML.
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    references:
    - https://github.com/Leonidas-from-XIV/node-xml2js/issues/415
    - https://github.com/isaacs/sax-js
    category: security
    technology:
    - sax
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.sax.security.audit.sax-xxe.sax-xxe
  severity: WARNING
  languages:
  - javascript
  - typescript
  pattern-either:
  - pattern: |
      require('sax');
      ...
      $PARSER.ondoctype = ...;
  - pattern: |-
      require('sax');
      ...
      $PARSER.on('doctype',...);
- id: javascript.sequelize.security.audit.sequelize-enforce-tls.sequelize-enforce-tls
  message: |
    If TLS is disabled on server side (Postgresql server), Sequelize establishes connection without TLS and no error will be thrown. To prevent MITN (Man In The Middle) attack, TLS must be enforce by Sequelize. Set "ssl: true" or define settings "ssl: {...}"
  metadata:
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://node-postgres.com/features/ssl
    - https://nodejs.org/api/tls.html#tls_class_tls_tlssocket
    - https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options
    - https://nodejs.org/api/tls.html#tls_tls_default_min_version
    category: security
    technology:
    - sequelize
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.sequelize.security.audit.sequelize-enforce-tls.sequelize-enforce-tls
  severity: WARNING
  languages:
  - javascript
  - typescript
  patterns:
  - pattern: |
      {
        host: $HOST,
        database: $DATABASE,
        dialect: $DIALECT
       }
  - pattern-not: |
      {
        host: $HOST,
        database: $DATABASE,
        dialect: "postgres",
        dialectOptions: {
            ssl: true
        }
      }
  - pattern-not: |
      {
        host: $HOST,
        database: $DATABASE,
        dialect: $DIALECT,
        dialectOptions: {
          ssl: { ... }
        }
      }
  - metavariable-regex:
      metavariable: $DIALECT
      regex: '[''"](mariadb|mysql|postgres)[''"]'
- id: javascript.sequelize.security.audit.sequelize-raw-query.sequelize-raw-query
  message: |
    Avoiding SQL string concatenation: untrusted input concatinated with raw SQL query can result in SQL Injection. Data replacement or data binding should be used. See https://sequelize.org/master/manual/raw-queries.html
  metadata:
    category: security
    technology:
    - sequelize
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://sequelize.org/master/manual/raw-queries.html
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.sequelize.security.audit.sequelize-raw-query.sequelize-raw-query
  severity: WARNING
  languages:
  - javascript
  - typescript
  pattern-either:
  - pattern: |
      $DATABASE.sequelize.query(`...${...}...`, ...)
  - pattern: |
      $QUERY = `...${...}...`
      ...
      $DATABASE.sequelize.query($QUERY, ...)
  - pattern: |
      $DATABASE.sequelize.query($SQL + $VALUE, ...)
  - pattern: |
      $QUERY = $SQL + $VALUE
      ...
      $DATABASE.sequelize.query($QUERY, ...)
- id: javascript.sequelize.security.audit.sequelize-tls-disabled-cert-validation.sequelize-tls-disabled-cert-validation
  message: |
    Set "rejectUnauthorized" to false is a convenient way to resolve certificate error. But this method is unsafe because it disables the server certificate verification, making the Node app open to MITM attack. "rejectUnauthorized" option must be alway set to True (default value). With self -signed certificat or custom CA, use "ca" option to define Root Certicate. This rule checks TLS configuration only for Postgresql, MariaDB and MySQL. SQLite is not really concerned by TLS configuration. This rule could be extended for MSSQL, but the dialectOptions is specific for Tedious.
  metadata:
    cwe: |
      CWE-295: Improper Certificate Validation
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://node-postgres.com/features/ssl
    - https://nodejs.org/api/tls.html#tls_class_tls_tlssocket
    - https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options
    category: security
    technology:
    - sequelize
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.sequelize.security.audit.sequelize-tls-disabled-cert-validation.sequelize-tls-disabled-cert-validation
  severity: ERROR
  languages:
  - javascript
  - typescript
  patterns:
  - pattern: |
      {
        host: $HOST,
        database: $DATABASE,
        dialect: $DIALECT,
        dialectOptions: {
          ssl: {
            rejectUnauthorized: false
          }
        }
       }
  - metavariable-regex:
      metavariable: $DIALECT
      regex: '[''"](mariadb|mysql|postgres)[''"]'
- id: javascript.sequelize.security.audit.sequelize-weak-tls-version.sequelize-weak-tls-version
  message: |
    TLS1.0 and TLS1.1 are deprecated and should be used anymore. By default, NodeJS used TLSv1.2. So, TLS min version must not be downgrade to TLS1.0 or TLS1.1. Enforce TLS1.3 is hightly recommanded This rule checks TLS configuration only for Postgresql, MariaDB and MySQL. SQLite is not really concerned by TLS configuration. This rule could be extended for MSSQL, but the dialectOptions is specific for Tedious.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://node-postgres.com/features/ssl
    - https://nodejs.org/api/tls.html#tls_class_tls_tlssocket
    - https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options
    - https://nodejs.org/api/tls.html#tls_tls_default_min_version
    category: security
    technology:
    - sequelize
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.sequelize.security.audit.sequelize-weak-tls-version.sequelize-weak-tls-version
  severity: WARNING
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      {
        host: $HOST,
        database: $DATABASE,
        dialect: $DIALECT,
        dialectOptions:
          { ssl: ... }
       }
  - pattern-either:
    - pattern: |
        {
          minVersion: 'TLSv1'
        }
    - pattern: |
        {
          minVersion: 'TLSv1.1'
        }
  - metavariable-regex:
      metavariable: $DIALECT
      regex: '[''"](mariadb|mysql|postgres)[''"]'
- id: javascript.serialize-javascript.security.audit.unsafe-serialize-javascript.unsafe-serialize-javascript
  message: |
    `serialize-javascript` used with `unsafe` parameter, this could be vulnerable to XSS.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page'
    category: security
    technology:
    - serialize-javascript
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.serialize-javascript.security.audit.unsafe-serialize-javascript.unsafe-serialize-javascript
  patterns:
  - pattern-inside: |
      ...
      $S = require('serialize-javascript');
      ...
  - pattern-not-inside: escape(...)
  - pattern-not-inside: encodeURI(...)
  - pattern: |
      $S(..., {unsafe: true});
- id: javascript.shelljs.security.shelljs-exec-injection.shelljs-exec-injection
  message: |
    If unverified user data can reach the `exec` method it can result in Remote Code Execution
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (OS Command Injection)'
    category: security
    technology:
    - shelljs
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.shelljs.security.shelljs-exec-injection.shelljs-exec-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      require('shelljs');
      ...
  - pattern-not-inside: |
      ...
      var $INPUT = "...";
      ...
  - pattern: $SHELL.exec($INPUT,...)
  - pattern-not: $SHELL.exec("...",...)
- id: javascript.thenify.security.audit.multiargs-code-execution.multiargs-code-execution
  patterns:
  - pattern-either:
    - pattern: |
        $THENIFY($FN, {multiArgs: ...},...)
    - pattern: |
        $OPTS = {multiArgs: ...};
        ...
        $THENIFY($FN,$OPTS,...);
  - pattern-not: |
      $THENIFY($FN, {multiArgs: false},...)
  - pattern-not: |
      $OPTS = {multiArgs: false};
      ...
      $THENIFY($FN,$OPTS,...)
  - pattern-either:
    - pattern-inside: |
        $THENIFY = require('thenify');
        ...
    - pattern-inside: |
        import 'thenify';
        ...
  message: |
    Potential arbitrary code execution, piped to eval
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - thenify
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.thenify.security.audit.multiargs-code-execution.multiargs-code-execution
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: javascript.vm2.security.audit.vm2-code-injection.vm2-code-injection
  message: |
    Make sure that unverified user data can not reach `vm2`.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - vm2
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.vm2.security.audit.vm2-code-injection.vm2-code-injection
  patterns:
  - pattern-inside: |
      ...
      require('vm2');
      ...
  - pattern-not-inside: |
      $CODE = "...";
      ...
  - pattern-not-inside: |
      ...
      $CODE = new VMScript(...);
      ...
  - pattern-either:
    - pattern: |
        $VM = new VM(...);
        ...
        $VM.run($CODE,...);
    - pattern: |
        new VM(...).run($CODE,...);
    - pattern: |
        $VM = new NodeVM(...);
        ...
        $VM.run($CODE,...);
    - pattern: |
        new NodeVM(...).run($CODE,...);
    - pattern: |
        new VMScript($CODE,...);
  - pattern-not: |
      $VM = new VM(...);
      ...
      $VM.run("...",...);
  - pattern-not: |
      $VM = new NodeVM(...);
      ...
      $VM.run("...",...);
  - pattern-not: |
      (new VM(...)).run("...",...);
  - pattern-not: |
      (new NodeVM(...)).run("...",...);
  - pattern-not: new VMScript("...",...);
- id: javascript.vm2.security.audit.vm2-context-injection.vm2-context-injection
  message: |
    Make sure that unverified user data can not reach `vm2`.
  severity: WARNING
  languages:
  - javascript
  - typescript
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-94: Improper Control of Generation of Code (Code Injection)'
    category: security
    technology:
    - vm2
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.vm2.security.audit.vm2-context-injection.vm2-context-injection
  patterns:
  - pattern-inside: |
      ...
      $VM = require('vm2');
      ...
  - pattern-either:
    - pattern: |
        function (...,$INPUT,...) {
          ...
          new VM({sandbox: <... $INPUT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $OPTS = {sandbox: <... $INPUT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          new VM({sandbox: <... $INPUT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          new VM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $OPTS = {sandbox: <... $INPUT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new VM($OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          new NodeVM({sandbox: <... $INPUT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $OPTS = {sandbox: <... $INPUT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
    - pattern: |
        function (...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          new NodeVM({sandbox: <... $INPUT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... {$NAME:$INPUT} ...>;
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          new NodeVM({sandbox: <... $CONTEXT ...>},...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $OPTS = {sandbox: <... $INPUT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = <... $INPUT ...>;
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
    - pattern: |
        function $F(...,$INPUT,...) {
          ...
          $CONTEXT = {$NAME: <... $INPUT ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
    - pattern: |-
        function $F(...,$INPUT,...) {
          ...
          $VAR = <... $INPUT ...>;
          ...
          $CONTEXT = {$NAME: <... $VAR ...>};
          ...
          $OPTS = {sandbox: <... $CONTEXT ...>};
          ...
          new NodeVM($OPTS,...);
          ...
        }
- id: javascript.wkhtmltoimage.security.audit.wkhtmltoimage-injection.wkhtmltoimage-injection
  message: |
    If unverified user data can reach the `wkhtmltoimage` it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - wkhtmltoimage
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.wkhtmltoimage.security.audit.wkhtmltoimage-injection.wkhtmltoimage-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      $WK = require('wkhtmltoimage');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern: $WK.generate($INPUT,...)
  - pattern-not: $WK.generate("...",...)
- id: javascript.wkhtmltopdf.security.audit.wkhtmltopdf-injection.wkhtmltopdf-injection
  message: |
    If unverified user data can reach the `wkhtmltopdf` it can result in Server-Side Request Forgery vulnerabilities
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    category: security
    technology:
    - wkhtmltopdf
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.wkhtmltopdf.security.audit.wkhtmltopdf-injection.wkhtmltopdf-injection
  languages:
  - javascript
  - typescript
  patterns:
  - pattern-inside: |
      ...
      $WK = require('wkhtmltopdf');
      ...
  - pattern-not-inside: |
      var $INPUT = "...";
      ...
  - pattern: $WK($INPUT,...)
  - pattern-not: $WK("...",...)
- id: javascript.xml2json.security.audit.xml2json-xxe.xml2json-xxe
  message: |
    If unverified user data can reach the XML Parser it can result in XML External or
    Internal Entity (XXE) Processing vulnerabilities
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    asvs:
      section: V5 Validation, Sanitization and Encoding
      control_id: 5.5.2 Insecue XML Deserialization
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention
      version: '4'
    category: security
    technology:
    - xml2json
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/javascript.xml2json.security.audit.xml2json-xxe.xml2json-xxe
  severity: WARNING
  languages:
  - javascript
  - typescript
  patterns:
  - pattern: |
      var $XML = require('xml2json');
      ...
      $XML.toJson(...);
  - pattern-not: |
      var $XML = require('xml2json');
      ...
      $XML.toJson("...",...);
  - pattern-not: |-
      var $XML = require('xml2json');
      ...
      var $S = "...";
      ...
      $XML.toJson($S,...);
- id: java.spring.security.audit.spel-injection.spel-injection
  message: |
    A Spring expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPEL_INJECTION
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.spring.security.audit.spel-injection.spel-injection
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS {
          ...
          ExpressionParser $PARSER;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          ExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          ExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          SpelExpressionParser $PARSER;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          SpelExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          SpelExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          TemplateAwareExpressionParser $PARSER;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          TemplateAwareExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          TemplateAwareExpressionParser $PARSER = ...;
          ...
        }
  - pattern: |
      $X $METHOD(...) {
        ...
        $PARSER.parseExpression(...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $PARSER.parseExpression("...");
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $PARSER.parseExpression($S);
        ...
      }
- id: java.spring.security.audit.spring-actuator-fully-enabled.spring-actuator-fully-enabled
  pattern: management.endpoints.web.exposure.include=*
  message: |
    Spring Boot Actuator is fully enabled. This exposes sensitive endpoints such as /actuator/env, /actuator/logfile, /actuator/heapdump and others.
    Unless you have Spring Security enabled or another means to protect these endpoints, this functionality is available without authentication, causing a severe security risk.
  severity: WARNING
  languages:
  - generic
  paths:
    include:
    - '*properties'
  metadata:
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints-exposing-endpoints
    - https://medium.com/walmartglobaltech/perils-of-spring-boot-actuators-misconfiguration-185c43a0f785
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.spring.security.audit.spring-actuator-fully-enabled.spring-actuator-fully-enabled
- id: java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled
  message: |
    CSRF is disabled for this configuration. This is a security risk.
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_PROTECTION_DISABLED
    asvs:
      section: V4 Access Control
      control_id: 4.2.2 CSRF
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V4-Access-Control.md#v42-operation-level-access-control
      version: '4'
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled
  severity: WARNING
  languages:
  - java
  pattern: $OBJ.csrf(...).disable(...)
- id: java.spring.security.audit.spring-jsp-eval.spring-jsp-eval
  pattern: |
    <spring:eval ... expression=...>
  message: |
    A Spring expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  severity: WARNING
  languages:
  - generic
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#JSP_SPRING_EVAL
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.spring.security.audit.spring-jsp-eval.spring-jsp-eval
  paths:
    include:
    - '*.jsp'
- id: java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect
  message: |
    Application redirects a user to a destination URL specified by a user supplied parameter that is not validated.
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        return "redirect:" + $URL;
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        String $REDIR = "redirect:" + $URL;
        ...
        return $REDIR;
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        new ModelAndView("redirect:" + $URL);
        ...
      }
  - pattern: |-
      $X $METHOD(...,String $URL,...) {
        ...
        String $REDIR = "redirect:" + $URL;
        ...
        new ModelAndView($REDIR);
        ...
      }
- id: java.spring.security.unrestricted-request-mapping.unrestricted-request-mapping
  patterns:
  - pattern: |
      @RequestMapping(...)
      $RETURNTYPE $METHOD(...) { ... }
  - pattern-not-inside: |
      @RequestMapping(..., method = $X, ...)
      $RETURNTYPE $METHOD(...) { ... }
  message: Detected a method annotated with 'RequestMapping' that does not specify
    the HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or OPTIONS,
    and by default all HTTP methods are allowed when the HTTP method is not explicitly
    specified. This means that a method that performs state changes could be vulnerable
    to CSRF attacks. To mitigate, add the 'method' field and specify the HTTP method
    (such as 'RequestMethod.POST').
  severity: WARNING
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
    references:
    - https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/java.spring.security.unrestricted-request-mapping.unrestricted-request-mapping
  languages:
  - java
- id: problem-based-packs.insecure-transport.go-stdlib.bypass-tls-verification.bypass-tls-verification
  message: |
    Checks for disabling of TLS/SSL certificate verification.
     This should only be used for debugging purposes because it leads to vulnerability to MTM attacks.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://stackoverflow.com/questions/12122159/how-to-do-a-https-request-with-bad-certificate
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.bypass-tls-verification.bypass-tls-verification
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: |
      tls.Config{..., InsecureSkipVerify: true, ...}
  - pattern: |
      $CONFIG = &tls.Config{...}
      ...
      $CONFIG.InsecureSkipVerify = true
- id: problem-based-packs.insecure-transport.go-stdlib.disallow-old-tls-versions.disallow-old-tls-versions
  patterns:
  - pattern-either:
    - pattern: |
        tls.Config{..., MinVersion: $TLS.$VERSION, ...}
    - pattern: |
        $CONFIG = &tls.Config{...}
        ...
        $CONFIG.MinVersion = $TLS.$VERSION
  - metavariable-regex:
      metavariable: $VERSION
      regex: (VersionTLS10|VersionTLS11|VersionSSL30)
  message: |
    Detects creations of tls configuration objects with an insecure MinVersion of TLS.
    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.disallow-old-tls-versions.disallow-old-tls-versions
  severity: WARNING
  languages:
  - go
- id: problem-based-packs.insecure-transport.go-stdlib.ftp-request.ftp-request
  message: |
    Checks for outgoing connections to ftp servers with the ftp package. FTP does not encrypt traffic, possibly
    leading to PII being sent plaintext over the network. Instead, connect via the SFTP protocol.
  fix-regex:
    regex: '[fF][tT][pP]://'
    replacement: sftp://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://godoc.org/github.com/jlaffaye/ftp#Dial
    - https://github.com/jlaffaye/ftp
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.ftp-request.ftp-request
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: |
      ftp.Dial("=~/^[fF][tT][pP]://.*/", ...)
  - pattern: |
      ftp.DialTimeout("=~/^[fF][tT][pP]://.*/", ...)
  - pattern: |
      ftp.Connect("=~/^[fF][tT][pP]://.*/")
  - pattern: |
      $URL = "=~/^[fF][tT][pP]://.*/"
      ...
      ftp.Dial($URL, ...)
  - pattern: |
      $URL = "=~/^[fF][tT][pP]://.*/"
      ...
      ftp.DialTimeout($URL, ...)
  - pattern: |
      $URL = "=~/^[fF][tT][pP]://.*/"
      ...
      ftp.Connect($URL)
- id: problem-based-packs.insecure-transport.go-stdlib.gorequest-http-request.gorequest-http-request
  message: |
    Checks for requests to http (unencrypted) sites using gorequest, a popular HTTP client library.
    This is dangerous because it could result in plaintext PII being passed around the network.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://github.com/parnurzeal/gorequest
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.gorequest-http-request.gorequest-http-request
  severity: WARNING
  languages:
  - go
  pattern-either:
  - patterns:
    - pattern-inside: |
        $REQ = gorequest.New()
        ...
        $RES = ...
    - pattern: |
        $REQ.$FUNC("=~/[hH][tT][tT][pP]://.*/")
    - metavariable-regex:
        metavariable: $FUNC
        regex: (Get|Post|Delete|Head|Put|Patch)
  - patterns:
    - pattern: gorequest.New().$FUNC("=~/[hH][tT][tT][pP]://.*/")
    - metavariable-regex:
        metavariable: $FUNC
        regex: (Get|Post|Delete|Head|Put|Patch)
- id: problem-based-packs.insecure-transport.go-stdlib.grequests-http-request.grequests-http-request
  patterns:
  - pattern-either:
    - pattern: |
        grequests.$FUNC(...,"=~/[hH][tT][tT][pP]://.*/", ...)
    - pattern: |
        $FUNC(...,"=~/[hH][tT][tT][pP]://.*/", ...)
  - metavariable-regex:
      metavariable: $FUNC
      regex: (Get|Head|Post|Put|Delete|Patch|Options|Req|DoRegularRequest)
  message: |
    Checks for requests to http (unencrypted) sites using grequests, a popular HTTP client library.
    This is dangerous because it could result in plaintext PII being passed around the network.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://godoc.org/github.com/levigross/grequests#DoRegularRequest
    - https://github.com/levigross/grequests
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.grequests-http-request.grequests-http-request
  severity: WARNING
  languages:
  - go
- id: problem-based-packs.insecure-transport.go-stdlib.http-customized-request.http-customized-request
  pattern: |
    http.NewRequest(..., "=~/[hH][tT][tT][pP]://.*/", ...)
  message: |
    Checks for requests sent via http.NewRequest to http:// URLS. This is dangerous because
    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead,    send requests only to
    https:// URLS.
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://golang.org/pkg/net/http/#NewRequest
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.http-customized-request.http-customized-request
  languages:
  - go
  severity: WARNING
- id: problem-based-packs.insecure-transport.go-stdlib.http-request.http-request
  patterns:
  - pattern-either:
    - pattern: |
        http.$FUNC("=~/[hH][tT][tT][pP]://.*/", ...)
    - pattern: |
        $CLIENT := &http.Client{...}
        ...
        client.$FUNC("=~/[hH][tT][tT][pP]://.*/", ...)
  - metavariable-regex:
      metavariable: $FUNC
      regex: (Get|Post|Head|PostForm)
  message: |
    Checks for requests sent via http.$FUNC to http:// URLS. This is dangerous because
    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead, send requests only to
    https:// URLS.
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://golang.org/pkg/net/http/#Get
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.http-request.http-request
  languages:
  - go
  severity: WARNING
- id: problem-based-packs.insecure-transport.go-stdlib.sling-http-request.sling-http-request
  message: |
    Checks for requests to http (unencrypted) sites using gorequest, a popular HTTP client library.
    This is dangerous because it could result in plaintext PII being passed around the network.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://godoc.org/github.com/dghubble/sling#Sling.Add
    - https://github.com/dghubble/sling
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.sling-http-request.sling-http-request
  severity: WARNING
  languages:
  - go
  pattern-either:
  - patterns:
    - pattern-inside: |
        $REQ = sling.New()
        ...
        $RES = ...
    - pattern: |
        $REQ.$FUNC("=~/[hH][tT][tT][pP]://.*/")
    - metavariable-regex:
        metavariable: $FUNC
        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)
  - patterns:
    - pattern: sling.New().$FUNC("=~/[hH][tT][tT][pP]://.*/")
    - metavariable-regex:
        metavariable: $FUNC
        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)
  - patterns:
    - pattern-inside: |
        $REQ = sling.New()
        ...
        $URL = "=~/[hH][tT][tT][pP]://.*/"
        ...
        $RES = ...
    - pattern: |
        $REQ.$FUNC($URL)
    - metavariable-regex:
        metavariable: $FUNC
        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)
  - patterns:
    - pattern-inside: |
        $URL = "=~/[hH][tT][tT][pP]://.*/"
        ...
        $RES = ...
    - pattern: |
        sling.New().$FUNC($URL)
    - metavariable-regex:
        metavariable: $FUNC
        regex: (Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)
- id: problem-based-packs.insecure-transport.go-stdlib.telnet-request.telnet-request
  pattern: |
    telnet.DialToAndCall(...)
  message: |
    Checks for attempts to connect to an insecure telnet server using the package telnet.
    This is bad because it can lead to man in the middle attacks.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://godoc.org/github.com/reiver/go-telnet
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.go-stdlib.telnet-request.telnet-request
  languages:
  - go
  severity: WARNING
- id: problem-based-packs.insecure-transport.java-spring.bypass-tls-verification.bypass-tls-verification
  message: |
    Checks for redefinitions of functions that check TLS/SSL certificate verification. This can lead to vulnerabilities,
    as simple errors in the code can result in lack of proper certificate validation.
    This should only be used for debugging purposes because it leads to vulnerability to MTM attacks.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://stackoverflow.com/questions/4072585/disabling-ssl-certificate-validation-in-spring-resttemplate
    - https://stackoverflow.com/questions/35530558/how-to-fix-unsafe-implementation-of-x509trustmanager-in-android-app?rq=1
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-spring.bypass-tls-verification.bypass-tls-verification
  languages:
  - java
  severity: WARNING
  pattern-either:
  - pattern: |
      new HostnameVerifier() {
        ...
        public boolean verify(String hostname, SSLSession session) {
          ...
        }
        ...
      };
  - pattern: |
      public RestTemplate restTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {
        ...
        TrustStrategy $FUNCNAME = (X509Certificate[] chain, String authType) -> ...;
        ...
      }
  - pattern: |
      TrustStrategy $FUNCNAME= new TrustStrategy() {
        ...
        public boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
          ...
        }
        ...
      };
- id: problem-based-packs.insecure-transport.java-spring.spring-ftp-request.spring-ftp-request
  message: |
    Checks for outgoing connections to ftp servers via Spring plugin ftpSessionFactory. FTP does not encrypt traffic, possibly
    leading to PII being sent plaintext over the network.
  fix-regex:
    regex: '[fF][tT][pP]://'
    replacement: sftp://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/session/AbstractFtpSessionFactory.html#setClientMode-int-
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-spring.spring-ftp-request.spring-ftp-request
  languages:
  - java
  severity: WARNING
  pattern-either:
  - pattern: |
      $SF = new DefaultFtpSessionFactory(...);
      ...
      $SF.setHost("=~/^[fF][tT][pP]://.*/");
      ...
      $SF.$FUNC(...);
  - pattern: |
      $SF = new DefaultFtpSessionFactory(...);
      ...
      String $URL = "=~/^[fF][tT][pP]://.*/";
      ...
      $SF.setHost($URL);
      ...
      $SF.$FUNC(...);
- id: problem-based-packs.insecure-transport.java-spring.spring-http-request.spring-http-request
  patterns:
  - pattern-either:
    - pattern: |
        $RESTTEMP = new RestTemplate(...);
        ...
        $RESTTEMP.$FUNC("=~/[hH][tT][tT][pP]://.*/", ...);
    - pattern: |
        $RESTTEMP = new RestTemplate(...);
        ...
        String $URL = "=~/[hH][tT][tT][pP]://.*/";
        ...
        $RESTTEMP.$FUNC($URL, ...);
    - pattern: |
        $RESTTEMP = new RestTemplate(...);
        ...
        $URL = new URI(..., "=~/[hH][tT][tT][pP]://.*/", ...);
        ...
        $RESTTEMP.$FUNC($URL, ...);
  - metavariable-regex:
      metavariable: $FUNC
      regex: (delete|doExecute|exchange|getForEntity|getForObject|headForHeaders|optionsForAllow|patchForObject|postForEntity|postForLocation|postForObject|put)
  message: |
    Checks for requests sent via Java Spring RestTemplate API to http:// URLS. This is dangerous because
    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead, send requests only to
    https:// URLS.
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html#delete-java.lang.String-java.util.Map-
    - https://www.baeldung.com/rest-template
    category: security
    technology:
    - spring
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-spring.spring-http-request.spring-http-request
  languages:
  - java
  severity: WARNING
- id: problem-based-packs.insecure-transport.java-stdlib.bypass-tls-verification.bypass-tls-verification
  patterns:
  - pattern: |
      new X509TrustManager() {
        ...
        public void checkClientTrusted(X509Certificate[] certs, String authType) {...}
        ...
      }
  - pattern-not: |
      new X509TrustManager() {
        ...
        public void checkServerTrusted(X509Certificate[] certs, String authType) {
          ...
          throw new CertificateException(...);
          ...
        }
        ...
      }
  - pattern-not: |
      new X509TrustManager() {
        ...
        public void checkServerTrusted(X509Certificate[] certs, String authType) {
          ...
          throw new IllegalArgumentException(...);
          ...
        }
        ...
      }
  message: |
    Checks for redefinitions of the checkServerTrusted function in the X509TrustManager class that disables TLS/SSL certificate verification.
    This should only be used for debugging purposes because it leads to vulnerability to MTM attacks.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://riptutorial.com/java/example/16517/temporarily-disable-ssl-verification--for-testing-purposes-
    - https://stackoverflow.com/questions/35530558/how-to-fix-unsafe-implementation-of-x509trustmanager-in-android-app?rq=1
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.bypass-tls-verification.bypass-tls-verification
  languages:
  - java
  severity: WARNING
- id: problem-based-packs.insecure-transport.java-stdlib.disallow-old-tls-versions1.disallow-old-tls-versions1
  patterns:
  - pattern: |
      new SSLConnectionSocketFactory(...);
  - pattern-not: |
      new SSLConnectionSocketFactory(..., new String[] {"TLSv1.2", "TLSv1.3"}, ...);
  - pattern-not: |
      new SSLConnectionSocketFactory(..., new String[] {"TLSv1.3", "TLSv1.2"}, ...);
  - pattern-not: |
      new SSLConnectionSocketFactory(..., new String[] {"TLSv1.3"}, ...);
  - pattern-not: |
      new SSLConnectionSocketFactory(..., new String[] {"TLSv1.2"}, ...);
  message: |
    Detects direct creations of SSLConnectionSocketFactories that don't disallow SSL v2, SSL v3, and TLS v1.
    SSLSocketFactory can be used to validate the identity of the HTTPS server against a list of trusted certificates.
    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.disallow-old-tls-versions1.disallow-old-tls-versions1
  severity: WARNING
  languages:
  - java
- id: problem-based-packs.insecure-transport.java-stdlib.disallow-old-tls-versions2.disallow-old-tls-versions2
  patterns:
  - pattern: |
      java.lang.System.setProperty("jdk.tls.client.protocols", "...");
  - pattern-not: |
      java.lang.System.setProperty("jdk.tls.client.protocols", "TLSv1.2,TLSv1.3");
  - pattern-not: |
      java.lang.System.setProperty("jdk.tls.client.protocols", "TLSv1.3,TLSv1.2");
  - pattern-not: |
      java.lang.System.setProperty("jdk.tls.client.protocols", "TLSv1.3");
  - pattern-not: |
      java.lang.System.setProperty("jdk.tls.client.protocols", "TLSv1.2");
  message: |
    Detects setting client protocols to insecure versions of TLS and SSL.
    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://stackoverflow.com/questions/26504653/is-it-possible-to-disable-sslv3-for-all-java-applications
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.disallow-old-tls-versions2.disallow-old-tls-versions2
  severity: WARNING
  languages:
  - java
- id: problem-based-packs.insecure-transport.java-stdlib.ftp-request.ftp-request
  message: |
    Checks for outgoing connections to ftp servers. FTP does not encrypt traffic, possibly
    leading to PII being sent plaintext over the network.
  fix-regex:
    regex: '[fF][tT][pP]://'
    replacement: sftp://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://www.codejava.net/java-se/ftp/connect-and-login-to-a-ftp-server
    - https://commons.apache.org/proper/commons-net/apidocs/org/apache/commons/net/ftp/FTPClient.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.ftp-request.ftp-request
  languages:
  - java
  severity: WARNING
  pattern-either:
  - pattern: |
      FTPClient $FTPCLIENT = new FTPClient();
      ...
      $FTPCLIENT.connect(...);
  - pattern: |
      URL $URL = new URL("=~/^[fF][tT][pP]://.*/");
      ...
      URLConnection $CONN = $URL.openConnection(...);
- id: problem-based-packs.insecure-transport.java-stdlib.httpclient-http-request.httpclient-http-request
  pattern-either:
  - patterns:
    - pattern: |
        URI.create("=~/[hH][tT][tT][pP]://.*/", ...)
    - pattern-inside: |
        HttpClient $CLIENT = ...;
        ...
        HttpRequest $REQ = ...;
        ...
        $CLIENT.sendAsync(...);
  - patterns:
    - pattern: |
        URI.create("=~/[hH][tT][tT][pP]://.*/", ...)
    - pattern-inside: |
        HttpClient $CLIENT = ...;
        ...
        HttpRequest $REQ = ...;
        ...
        $CLIENT.send(...);
  - patterns:
    - pattern: |
        URI.create($URI)
    - pattern-inside: |
        String $URI = "=~/[hH][tT][tT][pP]://.*/";
        ...
        HttpClient $CLIENT = ...;
        ...
        HttpRequest $REQ = ...;
        ...
        $CLIENT.send(...);
  - patterns:
    - pattern: |
        URI.create($URI)
    - pattern-inside: |
        String $URI = "=~/[hH][tT][tT][pP]://.*/";
        ...
        HttpClient $CLIENT = ...;
        ...
        HttpRequest $REQ = ...;
        ...
        $CLIENT.sendAsync(...);
  message: |
    Checks for requests sent via HttpClient to http:// URLS. This is dangerous because
    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead, send requests only to
    https:// URLS.
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://openjdk.java.net/groups/net/httpclient/intro.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.httpclient-http-request.httpclient-http-request
  languages:
  - java
  severity: WARNING
- id: problem-based-packs.insecure-transport.java-stdlib.http-components-request.http-components-request
  message: |
    Checks for requests sent via Apache HTTP Components to http:// URLS. This is dangerous because
    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead, send requests only to
    https:// URLS.
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://hc.apache.org/httpcomponents-client-ga/quickstart.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.http-components-request.http-components-request
  languages:
  - java
  severity: WARNING
  pattern-either:
  - pattern: |
      $HTTPCLIENT = HttpClients.$CREATE(...);
      ...
      $HTTPREQ = new $HTTPFUNC("=~/[hH][tT][tT][pP]://.*/");
      ...
      $RESPONSE = $HTTPCLIENT.execute($HTTPREQ);
  - pattern: |
      $HTTPCLIENT = HttpClients.$CREATE(...);
      ...
      $RESPONSE = $HTTPCLIENT.execute(new $HTTPFUNC("=~/[hH][tT][tT][pP]://.*/"));
- id: problem-based-packs.insecure-transport.java-stdlib.httpurlconnection-http-request.httpurlconnection-http-request
  message: |
    Checks for requests sent via HttpURLConnection and URLObj to http:// URLS. This is dangerous because
    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead, send requests only to
    https:// URLS.
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html
    - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html#openConnection()
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.httpurlconnection-http-request.httpurlconnection-http-request
  languages:
  - java
  severity: WARNING
  pattern-either:
  - pattern: |
      URL $URL = new URL ("=~/[Hh][Tt][Tt][Pp]://.*/", ...);
      ...
      $CON = (HttpURLConnection) $URL.openConnection(...);
      ...
      $CON.$FUNC(...);
  - pattern: |
      URL $URL = new URL ("=~/[Hh][Tt][Tt][Pp]://.*/", ...);
      ...
      $CON = $URL.openConnection(...);
      ...
      $CON.$FUNC(...);
- id: problem-based-packs.insecure-transport.java-stdlib.socket-request.socket-request
  message: |
    Insecure transport rules to catch socket connections to http, telnet, and ftp servers.
    This is dangerous because these are protocols that do not encrypt traffic.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.socket-request.socket-request
  languages:
  - java
  severity: WARNING
  pattern-either:
  - pattern: |
      $SOCKET = new Socket("=~/[tT][eE][lL][nN][eE][tT]://.*/", ...);
      ...
      $OUT = new PrintWriter($SOCKET.getOutputStream(...), ...);
      ...
      $OUT.$FUNC(...);
  - pattern: |
      $SOCKET = new Socket("=~/^[fF][tT][pP]://.*/", ...);
      ...
      $OUT = new PrintWriter($SOCKET.getOutputStream(...), ...);
      ...
      $OUT.$FUNC(...);
  - pattern: |
      $SOCKET = new Socket("=~/[hH][tT][tT][pP]://.*/", ...);
      ...
      $OUT = new PrintWriter($SOCKET.getOutputStream(...), ...);
      ...
      $OUT.$FUNC(...);
- id: problem-based-packs.insecure-transport.java-stdlib.telnet-request.telnet-request
  pattern: |
    $TELNETCLIENT = new TelnetClient(...);
    ...
    $TELNETCLIENT.connect(...);
  message: |
    Checks for attempts to connect through telnet. This is insecure as the telnet protocol supports
    no encryption, and data passes through unencrypted.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://commons.apache.org/proper/commons-net/javadocs/api-3.6/org/apache/commons/net/telnet/TelnetClient.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.telnet-request.telnet-request
  languages:
  - java
  severity: WARNING
- id: problem-based-packs.insecure-transport.java-stdlib.tls-renegotiation.tls-renegotiation
  pattern: |
    java.lang.System.setProperty("sun.security.ssl.allowUnsafeRenegotiation", true);
  message: |
    Checks for cases where java applications are allowing unsafe renegotiation.
    This leaves the application vulnerable to a man-in-the-middle attack where chosen plain text is injected as prefix to a TLS connection.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://www.oracle.com/java/technologies/javase/tlsreadme.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.tls-renegotiation.tls-renegotiation
  languages:
  - java
  severity: WARNING
- id: problem-based-packs.insecure-transport.java-stdlib.unirest-http-request.unirest-http-request
  message: |
    Checks for requests sent via Unirest to http:// URLS. This is dangerous because
    the server is attempting to connect to a website that does not encrypt traffic with TLS. Instead, send requests only to
    https:// URLS.
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://kong.github.io/unirest-java/#requests
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.java-stdlib.unirest-http-request.unirest-http-request
  languages:
  - java
  severity: WARNING
  pattern-either:
  - pattern: |
      Unirest.get("=~/[hH][tT][tT][pP]://.*/")
  - pattern: |
      Unirest.post("=~/[hH][tT][tT][pP]://.*/")
- id: problem-based-packs.insecure-transport.js-node.bypass-tls-verification.bypass-tls-verification
  message: |
    Checks for setting the environment variable NODE_TLS_REJECT_UNAUTHORIZED to 0, which disables TLS verification.
    This should only be used for debugging purposes. Setting the option rejectUnauthorized to false bypasses verification
    against the list of trusted CAs, which also leads to insecure transport. These options lead to vulnerability
    to MTM attacks, and should not be used.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://nodejs.org/api/https.html#https_https_request_options_callback
    - https://stackoverflow.com/questions/20433287/node-js-request-cert-has-expired#answer-29397100
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.bypass-tls-verification.bypass-tls-verification
  severity: WARNING
  languages:
  - javascript
  - typescript
  pattern-either:
  - pattern: |
      process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = 0;
  - pattern: |
      {rejectUnauthorized:false}
- id: problem-based-packs.insecure-transport.js-node.disallow-old-tls-versions1.disallow-old-tls-versions1
  patterns:
  - pattern-either:
    - pattern-inside: |
        $CONST = require('crypto');
        ...
    - pattern-inside: |
        $CONST = require('constants');
        ...
  - pattern-inside: |
      $HTTPS = require('https');
      ...
  - pattern: |
      $HTTPS.createServer(...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 }, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_SSLv3 }, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_SSLv3 |$CONST.SSL_OP_NO_TLSv1 }, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3}, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions:$CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_TLSv1}, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions:$CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1| $CONST.SSL_OP_NO_SSLv2}, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 }, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_SSLv3 }, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_SSLv3 |$CONST.SSL_OP_NO_TLSv1 }, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3}, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions:$CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_TLSv1}, ...).$FUNC(...);
  - pattern-not: |
      $HTTPS.createServer({secureOptions:$CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1| $CONST.SSL_OP_NO_SSLv2}, ...).$FUNC(...);
  message: |
    Detects direct creations of $HTTPS servers that don't disallow SSL v2, SSL v3, and TLS v1. These protocols are deprecated due to
    POODLE, man in the middle attacks, and other vulnerabilities.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://us-cert.cisa.gov/ncas/alerts/TA14-290A
    - https://stackoverflow.com/questions/40434934/how-to-disable-the-ssl-3-0-and-tls-1-0-in-nodejs
    - https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.disallow-old-tls-versions1.disallow-old-tls-versions1
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: problem-based-packs.insecure-transport.js-node.disallow-old-tls-versions2.disallow-old-tls-versions2
  patterns:
  - pattern-either:
    - pattern-inside: |
        $CONST = require('crypto');
        ...
    - pattern-inside: |
        $CONST = require('constants');
        ...
  - pattern-inside: |
      $HTTPS = require('https');
      ...
  - pattern: |
      $OPTIONS = {};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_SSLv3};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv2  | $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_TLSv1};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_SSLv3};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv2  | $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_TLSv1};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  - pattern-not: |
      $OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2};
      ...
      $HTTPS.createServer($OPTIONS, ...);
  message: |
    Detects creations of $HTTPS servers from option objects that don't disallow SSL v2, SSL v3, and TLS v1.
    These protocols are deprecated due to POODLE, man in the middle attacks, and other vulnerabilities.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://us-cert.cisa.gov/ncas/alerts/TA14-290A
    - https://stackoverflow.com/questions/40434934/how-to-disable-the-ssl-3-0-and-tls-1-0-in-nodejs
    - https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.disallow-old-tls-versions2.disallow-old-tls-versions2
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: problem-based-packs.insecure-transport.js-node.ftp-request.ftp-request
  patterns:
  - pattern-inside: |
      $X = require('ftp');
      ...
      $C = new $X();
      ...
  - pattern-not-inside: |
      $OPTIONS = {secure: true};
      ...
  - pattern: |
      $C.connect($OPTIONS,...);
  - pattern-not: |
      $C.connect({...,secure: true});
  message: |
    Checks for lack of usage of the "secure: true" option when sending ftp requests through the nodejs ftp module.
    This leads to unencrypted traffic being sent to the ftp server. There are other options
    such as "implicit" that still does not encrypt all traffic. ftp is the most utilized npm ftp module.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://www.npmjs.com/package/ftp
    - https://openbase.io/js/ftp
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.ftp-request.ftp-request
  languages:
  - javascript
  - typescript
  severity: WARNING
- id: problem-based-packs.insecure-transport.js-node.http-request.http-request
  patterns:
  - pattern-inside: |
      $HTTP = require('http');
      ...
  - pattern-either:
    - pattern: |
        $HTTP.request("=~/http://.*/",...);
    - pattern: |
        $HTTP.get("=~/http://.*/", ...)
    - pattern: |
        $VAR = new URL("=~/http://.*/");
        ...
        $HTTP.request($VAR, ...);
    - pattern: |
        $VAR = {...,hostname: "..."};
        ...
        $HTTP.request(..., $VAR, ...);
    - pattern: |
        $HTTP.request(..., {...,hostname: "..."}, ...);
  - pattern-not: |
      $VAR = {...,protocol: "https"};
      ...
      $HTTP.request(..., $VAR, ...);
  - pattern-not: |
      $HTTP.request(..., {...,protocol: "https"}, ...);
  message: |
    Checks for requests sent to http:// URLs. This is dangerous as the server is attempting to connect to a website
    that does not encrypt traffic with TLS. Instead, only send requests to https:// URLs.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://nodejs.org/api/http.html#http_http_request_options_callback
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.http-request.http-request
  languages:
  - javascript
  severity: WARNING
- id: problem-based-packs.insecure-transport.js-node.rest-http-client-support.rest-http-client-support
  message: |
    Checks for requests to http (unencrypted) sites using some of node js's most popular REST/HTTP libraries,
    including node-rest-client, axios, and got.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://www.npmjs.com/package/axios
    - https://www.npmjs.com/package/got
    - https://www.npmjs.com/package/node-rest-client
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.rest-http-client-support.rest-http-client-support
  severity: WARNING
  languages:
  - javascript
  patterns:
  - pattern-either:
    - pattern-inside: |
        $CLIENT = require('node-rest-client').Client;
        ...
        $C = new $CLIENT();
        ...
    - pattern-inside: |
        $C = require('axios');
        ...
    - pattern-inside: |
        $C = require('got');
        ...
  - pattern-either:
    - pattern: |
        $C.$REQ("=~/http://.*/", ...)
    - pattern: |
        $C("=~/http://.*/", ...)
    - pattern: |
        $C({...,url: "=~/http://.*/"})
    - pattern: |
        $C.$REQ({...,url: "=~/http://.*/"})
- id: problem-based-packs.insecure-transport.js-node.telnet-request.telnet-request
  message: |
    Checks for creation of telnet servers or attempts to connect through telnet. This is insecure as the telnet protocol supports
    no encryption, and data passes through unencrypted.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://www.npmjs.com/package/telnet
    - https://www.npmjs.com/package/telnet-client
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.telnet-request.telnet-request
  languages:
  - javascript
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern-inside: |
        $TEL = require('telnet-client');
        ...
        $SERVER = new $TEL();
        ...
    - pattern-inside: |
        $SERVER = require('telnet');
        ...
  - pattern-either:
    - pattern: |
        $SERVER.on(...)
    - pattern: |
        $SERVER.connect(...)
    - pattern: |
        $SERVER.createServer(...)
- id: problem-based-packs.insecure-transport.js-node.using-http-server.using-http-server
  message: |
    Checks for any usage of http servers instead of https servers. Encourages the usage of https protocol instead of
    http, which does not have TLS and is therefore unencrypted. Using http can lead to man-in-the-middle attacks
    in which the attacker is able to read sensitive information.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://nodejs.org/api/http.html#http_class_http_agent
    - https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY
    category: security
    technology:
    - node.js
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.js-node.using-http-server.using-http-server
  languages:
  - javascript
  severity: WARNING
  patterns:
  - pattern-inside: |
      $HTTP = require('http');
      ...
  - pattern-either:
    - pattern: |
        $HTTP.$FUNC(...);
    - pattern: |
        new $HTTP.$FUNC2(...);
- id: problem-based-packs.insecure-transport.ruby-stdlib.http-client-requests.http-client-requests
  message: |
    Checks for requests to http (unencrypted) sites using some of ruby's most popular REST/HTTP       libraries,
    including httparty and restclient.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://github.com/rest-client/rest-client
    - https://github.com/jnunemaker/httparty/tree/master/docs
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.ruby-stdlib.http-client-requests.http-client-requests
  severity: WARNING
  languages:
  - ruby
  pattern-either:
  - pattern: |
      HTTParty.$PARTYVERB("=~/[hH][tT][tT][pP]://.*/", ...)
  - pattern: |
      $STRING = "=~/[hH][tT][tT][pP]://.*/"
      ...
      HTTParty.$PARTYVERB($STRING, ...)
  - pattern: |
      RestClient.$RESTVERB "=~/[hH][tT][tT][pP]://.*/", ...
  - pattern: |
      RestClient::Request.execute(..., url: "=~/[hH][tT][tT][pP]://.*/", ...)
- id: problem-based-packs.insecure-transport.ruby-stdlib.net-ftp-request.net-ftp-request
  message: |
    Checks for outgoing connections to ftp servers with the 'net/ftp' package. FTP does not encrypt traffic,   possibly
    leading to PII being sent plaintext over the network. Instead, connect via the SFTP protocol.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.ruby-lang.org/en/2.0.0/Net/FTP.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.ruby-stdlib.net-ftp-request.net-ftp-request
  languages:
  - ruby
  severity: WARNING
  pattern-either:
  - pattern: |
      $FTP = Net::FTP.new('...')
      ...
      $FTP.login
  - pattern: |
      Net::FTP.open('...') do |ftp|
        ...
        ftp.login
      end
- id: problem-based-packs.insecure-transport.ruby-stdlib.net-http-request.net-http-request
  patterns:
  - pattern-either:
    - pattern: |
        $URI = URI('=~/[hH][tT][tT][pP]://.*/')
        ...
        Net::HTTP::$FUNC.new $URI
    - pattern: |
        $URI = URI('=~/[hH][tT][tT][pP]://.*/')
        ...
        Net::HTTP.$FUNC($URI, ...)
    - pattern: |
        Net::HTTP.$FUNC(URI('=~/[hH][tT][tT][pP]://.*/'), ...)
  - metavariable-regex:
      metavariable: $FUNC
      regex: ([gG]et|post_form|[pP]ost|get_response|get_print|Head|Patch|Put|Proppatch|Lock|Unlock|Options|Propfind|Delete|Move|Copy|Trace|Mkcol)
  languages:
  - ruby
  message: |
    Checks for requests sent to http:// URLs. This is dangerous as the server is attempting to connect to a website
    that does not encrypt traffic with TLS. Instead, only send requests to https:// URLs.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://ruby-doc.org/stdlib-2.6.5/libdoc/net/http/rdoc/Net/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.ruby-stdlib.net-http-request.net-http-request
  severity: WARNING
- id: problem-based-packs.insecure-transport.ruby-stdlib.net-telnet-request.net-telnet-request
  message: |
    Checks for creation of telnet servers or attempts to connect through telnet. This is insecure as     the telnet protocol supports
    no encryption, and data passes through unencrypted.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.ruby-lang.org/en/2.2.0/Net/Telnet.html
    - https://www.rubydoc.info/gems/net-ssh-telnet2/0.1.0/Net/SSH/Telnet
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.ruby-stdlib.net-telnet-request.net-telnet-request
  languages:
  - ruby
  severity: WARNING
  pattern-either:
  - pattern: |
      Net::Telnet::new(...)
  - pattern: |
      Net::SSH::Telnet.new(...)
- id: problem-based-packs.insecure-transport.ruby-stdlib.openuri-request.openuri-request
  message: |
    Checks for requests to http and ftp (unencrypted) sites using OpenURI.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://ruby-doc.org/stdlib-2.6.3/libdoc/open-uri/rdoc/OpenURI.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/problem-based-packs.insecure-transport.ruby-stdlib.openuri-request.openuri-request
  severity: WARNING
  languages:
  - ruby
  pattern-either:
  - pattern: |
      URI.open('=~/[hH][tT][tT][pP]://.*/', ...)
  - pattern: |
      $URI = URI.parse('=~/[hH][tT][tT][pP]://.*/', ...)
      ...
      $URI.open
  - pattern: |
      URI.open('=~/^[fF][tT][pP]://.*/', ...)
  - pattern: |
      $URI = URI.parse('=~/^[fF][tT][pP]://.*/', ...)
      ...
      $URI.open
- id: python.airflow.security.audit.formatted-string-bashoperator.formatted-string-bashoperator
  message: |
    Found a formatted string in BashOperator: $CMD.
    This could be vulnerable to injection.
    Be extra sure your variables are not controllable by external sources.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - airflow
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.airflow.security.audit.formatted-string-bashoperator.formatted-string-bashoperator
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: |
      airflow.operators.bash_operator.BashOperator(..., bash_command="..." + $CONCAT, ...)
  - pattern: |
      airflow.operators.bash_operator.BashOperator(..., bash_command="...".format(...), ...)
  - pattern: |
      airflow.operators.bash_operator.BashOperator(..., bash_command=f"...", ...)
  - pattern: |
      airflow.operators.bash_operator.BashOperator(..., bash_command="..." % $PARAMS, ...)
  - pattern: |
      $CMD = "..." % $PARAMS
      ...
      airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
  - pattern: |
      $CMD = $STR.format(...)
      ...
      airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
  - pattern: |
      $CMD = f"..."
      ...
      airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
  - pattern: |
      $CMD = "..." + $CONCAT
      ...
      airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
  - pattern: |
      $CMD = "..."
      ...
      $CMD += $CONCAT
      ...
      airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
- id: python.boto3.security.hardcoded-token.hardcoded-token
  message: |
    Hardcoded AWS access token detected. Use environment variables
    to access tokens (e.g., os.environ.get(...)) or use non version-controlled
    configuration files.
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-boto3/
    references:
    - https://bento.dev/checks/boto3/hardcoded-access-token/
    - https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/
    category: security
    technology:
    - boto3
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.boto3.security.hardcoded-token.hardcoded-token
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: $W(..., aws_secret_access_key="=~/^[A-Za-z0-9/+=]+$/", ...)
  - pattern: $W(..., aws_access_key_id="=~/^AKI/", ...)
  - pattern: $W(..., aws_session_token="...", ...)
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.ARC4(...)
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L94
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.Blowfish(...)
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L96
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.IDEA(...)
  message: |
    Detected IDEA cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
  pattern: cryptography.hazmat.primitives.ciphers.modes.ECB(...)
  message: |
    Detected ECB cipher mode which is considered insecure. The algorithm can
    potentially leak information about the plaintext. Use CBC mode instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B305
    references:
    - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: cryptography.hazmat.primitives.hashes.MD5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: cryptography.hazmat.primitives.hashes.SHA1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insufficient-dsa-key-size.insufficient-dsa-key-size
  patterns:
  - pattern-either:
    - pattern: cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key(...,
        key_size=$SIZE, ...)
    - pattern: cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key($SIZE,
        ...)
  - metavariable-comparison:
      metavariable: $SIZE
      comparison: $SIZE < 2048
  message: |
    Detected an insufficient key size for DSA. NIST recommends
    a key size of 2048 or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insufficient-dsa-key-size.insufficient-dsa-key-size
  languages:
  - python
  severity: WARNING
- id: python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
  patterns:
  - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)
  - pattern-either:
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECP192R1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163K1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163R2
  message: |
    Detected an insufficient curve size for EC. NIST recommends
    a key size of 224 or higher. For example, use 'ec.SECP256R1'.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
  languages:
  - python
  severity: WARNING
- id: python.cryptography.security.insufficient-rsa-key-size.insufficient-rsa-key-size
  patterns:
  - pattern-either:
    - pattern: cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key(...,
        key_size=$SIZE, ...)
    - pattern: cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key($EXP,
        $SIZE, ...)
  - metavariable-comparison:
      metavariable: $SIZE
      comparison: $SIZE < 2048
  message: |
    Detected an insufficient key size for RSA. NIST recommends
    a key size of 2048 or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    category: security
    technology:
    - cryptography
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.cryptography.security.insufficient-rsa-key-size.insufficient-rsa-key-size
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
  message: Avoid using insecure deserialization library, backed by `pickle`, `_pickle`,
    `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code
    execution vulnerabilities.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      def $X(..., request, ...):
        ...
  - pattern-either:
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        pickle.$FUNC(<... $VAR ...>)
    - pattern: pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        _pickle.$FUNC(<... $VAR ...>)
    - pattern: _pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        cPickle.$FUNC(<... $VAR ...>)
    - pattern: cPickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        dill.$FUNC(<... $VAR ...>)
    - pattern: dill.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        shelve.$FUNC(<... $VAR ...>)
    - pattern: shelve.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        yaml.$FUNC(<... $VAR ...>)
    - pattern: yaml.$FUNC(<... request.$Y.get(...) ...>)
- id: python.django.security.audit.avoid-mark-safe.avoid-mark-safe
  patterns:
  - pattern-not-inside: django.utils.html.format_html(...)
  - pattern-not: django.utils.safestring.mark_safe("...")
  - pattern: django.utils.safestring.mark_safe(...)
  message: |
    'mark_safe()' is used to mark a string as "safe" for HTML output.
    This disables escaping and could therefore subject the content to
    XSS attacks. Use 'django.utils.html.format_html()' to build HTML
    for rendering instead.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.safestring.mark_safe
    - https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.html.format_html
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.avoid-mark-safe.avoid-mark-safe
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.csrf-exempt.no-csrf-exempt
  pattern: |
    @django.views.decorators.csrf.csrf_exempt
    def $R(...):
      ...
  message: There is rarely a good reason to use @csrf_exempt as is used for `$R`.
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.csrf-exempt.no-csrf-exempt
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.custom-expression-as-sql.custom-expression-as-sql
  languages:
  - python
  message: Detected a Custom Expression ''$EXPRESSION'' calling ''as_sql(...).'' Ensure
    no user input enters this function because it is susceptible to SQL injection.
    See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql
    for more information.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.custom-expression-as-sql.custom-expression-as-sql
  pattern: $EXPRESSION.as_sql(...)
  severity: WARNING
- id: python.django.security.audit.django-ratelimit.missing-ratelimit.missing-ratelimit
  patterns:
  - pattern: |
      def $FUNC(..., request, ...):
        ...
  - pattern-not: |
      @ratelimit.decorators.ratelimit(...)
      def $FUNC(..., request, ...):
        ...
  message: |
    Function '$FUNC' is missing a rate-limiting decorator.
    High volume traffic to this function could starve application
    resources. Consider adding rate limiting from a library such
    as 'django-ratelimit'.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-400: Uncontrolled Resource Consumption'
    references:
    - https://github.com/jsocol/django-ratelimit/blob/main/docs/index.rst#quickstart
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.django-ratelimit.missing-ratelimit.missing-ratelimit
  severity: WARNING
  languages:
  - python
- id: python.django.security.audit.django-rest-framework.missing-throttle-config.missing-throttle-config
  patterns:
  - pattern-not-inside: |
      REST_FRAMEWORK = {
        ...,
        "DEFAULT_THROTTLE_RATES": ...
      }
  - pattern: |
      REST_FRAMEWORK = ...
  message: |
    Django REST framework configuration is missing default rate-
    limiting options. This could inadvertently allow resource
    starvation or Denial of Service (DoS) attacks. Add
    'DEFAULT_THROTTLE_CLASSES' and 'DEFAULT_THROTTLE_RATES'
    to add rate-limiting to your application.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-400: Uncontrolled Resource Consumption'
    references:
    - https://www.django-rest-framework.org/api-guide/throttling/#setting-the-throttling-policy
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.django-rest-framework.missing-throttle-config.missing-throttle-config
  severity: WARNING
  languages:
  - python
- id: python.django.security.audit.extends-custom-expression.extends-custom-expression
  languages:
  - python
  message: |
    Found extension of custom expression: $CLASS. Extending expressions
    in this way could inadvertently expose a SQL injection vulnerability.
    See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#avoiding-sql-injection
    for more information.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#avoiding-sql-injection
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.extends-custom-expression.extends-custom-expression
  severity: WARNING
  pattern-either:
  - pattern: |
      class $CLASS(..., django.db.models.Func, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Func, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Expression, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Expression, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Value, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Value, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.DurationValue, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.DurationValue, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.RawSQL, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.RawSQL, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Star, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Star, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Random, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Random, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Col, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Col, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Ref, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Ref, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.ExpressionList, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.ExpressionList, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.ExpressionWrapper, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.ExpressionWrapper, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.When, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.When, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Case, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Case, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Subquery, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Subquery, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Exists, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Exists, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.Window, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.Window, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.WindowFrame, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.WindowFrame, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.RowRange, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.RowRange, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.ValueRange, ...):
          ...
  - pattern: |
      class $CLASS(..., django.db.models.expressions.ValueRange, ...):
          ...
- id: python.django.security.audit.query-set-extra.avoid-query-set-extra
  message: This is a last resort. You should be careful when using QuerySet.extra
    due to SQLi https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.query-set-extra.avoid-query-set-extra
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: $X.objects.$FUNC(...).extra(...)
  - pattern: $X.objects.$FUNC(...).$FILTER(...).extra(...)
  - pattern: $X.objects.$FUNC(...).$FILTER(...).$UPDATE(...).extra(...)
- id: python.django.security.audit.raw-query.avoid-raw-sql
  message: You should be very careful whenever you write raw SQL. Consider using Django
    ORM before raw SQL. See https://docs.djangoproject.com/en/3.0/topics/db/sql/#passing-parameters-into-raw
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#raw-sql-expressions
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.raw-query.avoid-raw-sql
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: $MODEL.objects.raw($QUERY, ...)
    - pattern: django.db.models.expressions.RawSQL(...)
  - pattern-not: $MODEL.objects.raw("...")
  - pattern-not: django.db.models.expressions.RawSQL("...")
- id: python.django.security.audit.secure-cookies.django-secure-set-cookie
  patterns:
  - pattern-either:
    - pattern-inside: |
        import django.http.HttpResponse
        ...
    - pattern-inside: |
        import django.shortcuts.render
        ...
  - pattern-not-inside: |
      LANGUAGE_QUERY_PARAMETER = 'language'
      ...
      def set_language(request):
          ...
      # Exclude vendored contrib/messages/storage/cookie.py
  - pattern-not-inside: |
      class CookieStorage(django.contrib.messages.storage.base.BaseStorage):
          ...
      # Exclude cookies handled by vendored middleware
  - pattern-not: response.set_cookie(django.conf.settings.SESSION_COOKIE_NAME, ...)
  - pattern-not: response.set_cookie(django.conf.settings.CSRF_COOKIE_NAME, ...)
  - pattern-not: response.set_cookie(django.conf.settings.LANGUAGE_COOKIE_NAME, ...)
  - pattern-not: response.set_cookie(rest_framework_jwt.settings.api_settings.JWT_AUTH_COOKIE,
      ...)
  - pattern-not: response.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)
  - pattern-not: response.set_cookie(..., **$A)
  - pattern: response.set_cookie(...)
  message: |
    Django cookies should be handled securely by setting secure=True, httponly=True, and samesite='Lax' in
    response.set_cookie(...). If your situation calls for different settings, explicitly disable the setting.
    If you want to send the cookie over http, set secure=False.  If you want to let client-side JavaScript
    read the cookie, set httponly=False. If you want to attach cookies to requests for external sites,
    set samesite=None.
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    asvs:
      section: 'V3: Session Management Verification Requirements'
      control_id: 3.4 Missing Cookie Attributes
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management
      version: '4'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/request-response/#django.http.HttpResponse.set_cookie
    - https://blog.r2c.dev/2020/bento-check-keeping-cookies-safe-in-flask/
    - https://bento.dev/checks/flask/secure-set-cookie/
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.secure-cookies.django-secure-set-cookie
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.templates.debug-template-tag.debug-template-tag
  languages:
  - generic
  severity: WARNING
  message: |
    Detected a debug template tag in a Django template. This dumps
    debugging information to the page when debug mode is enabled.
    Showing debug information to users is dangerous because it may
    reveal information about your environment that malicious actors
    can use to gain access to the system. Remove the debug tag.
  pattern: '{% debug %}'
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-489: Active Debug Code'
    references:
    - https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#debug
    - https://stackoverflow.com/questions/2213977/django-debug-display-all-variables-of-a-page
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.templates.debug-template-tag.debug-template-tag
- id: python.django.security.audit.unvalidated-password.unvalidated-password
  patterns:
  - pattern-not-inside: |
      if <... django.contrib.auth.password_validation.validate_password(...) ...>:
          ...
  - pattern-not-inside: |
      django.contrib.auth.password_validation.validate_password(...)
      ...
  - pattern-not-inside: |
      try:
        ...
        django.contrib.auth.password_validation.validate_password(...)
        ...
      except $EX:
        ...
      ...
  - pattern-not-inside: |
      try:
        ...
        django.contrib.auth.password_validation.validate_password(...)
        ...
      except $EX as $E:
        ...
      ...
  - pattern-not: UserModel().set_password($X)
  - pattern: $MODEL.set_password($X)
  fix: |
    if django.contrib.auth.password_validation.validate_password($X, user=$MODEL):
        $MODEL.set_password($X)
  message: |
    The password on '$MODEL' is being set without validating the password.
    Call django.contrib.auth.password_validation.validate_password() with
    validation functions before setting the password. See
    https://docs.djangoproject.com/en/3.0/topics/auth/passwords/
    for more information.
  metadata:
    cwe: 'CWE-521: Weak Password Requirements'
    owasp: 'A2: Broken Authentication'
    references:
    - https://docs.djangoproject.com/en/3.0/topics/auth/passwords/#module-django.contrib.auth.password_validation
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.unvalidated-password.unvalidated-password
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.xss.class-extends-safestring.class-extends-safestring
  message: |
    Found a class extending 'SafeString', 'SafeText' or 'SafeData'. These classes are
    for bypassing the escaping enging built in to Django and should not be
    used directly. Improper use of this class exposes your application to
    cross-site scripting (XSS) vulnerabilities. If you need this functionality,
    use 'mark_safe' instead and ensure no user data can reach it.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/howto/custom-template-tags/#filters-and-auto-escaping
    - https://github.com/django/django/blob/f138e75910b1e541686c4dce3d8f467f6fc234cb/django/utils/safestring.py#L11
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.class-extends-safestring.class-extends-safestring
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: |
      class $CLASS(django.utils.safestring.SafeString):
        ...
  - pattern: |
      class $CLASS(django.utils.safestring.SafeText):
        ...
  - pattern: |-
      class $CLASS(django.utils.safestring.SafeData):
        ...
- id: python.django.security.audit.xss.context-autoescape-off.context-autoescape-off
  message: |
    Detected a Context with autoescape diabled. If you are
    rendering any web pages, this exposes your application to cross-site
    scripting (XSS) vulnerabilities. Remove 'autoescape: False' or set it
    to 'True'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/ref/settings/#templates
    - https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.context-autoescape-off.context-autoescape-off
  languages:
  - python
  severity: WARNING
  fix-regex:
    regex: (autoescape.*?)False
    replacement: \1True
  pattern-either:
  - pattern: '{..., "autoescape": False, ...}'
  - pattern: $D["autoescape"] = False
- id: python.django.security.audit.xss.direct-use-of-httpresponse.direct-use-of-httpresponse
  message: |
    Detected data rendered directly to the end user via 'HttpResponse'
    or a similar object. This bypasses Django's built-in cross-site scripting
    (XSS) defenses and could result in an XSS vulnerability. Use Django's
    template engine to safely render HTML.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/intro/tutorial03/#a-shortcut-render
    - https://docs.djangoproject.com/en/3.1/topics/http/shortcuts/#render
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.direct-use-of-httpresponse.direct-use-of-httpresponse
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-not: django.http.$ANY("...", ...)
  - pattern-not: django.http.$ANY()
  - pattern-not: django.http.$ANY(..., content=None, ...)
  - pattern-not: django.http.$ANY(status=...)
  - pattern-not: django.http.HttpResponseNotAllowed([...])
  - pattern-either:
    - pattern: django.http.HttpResponse(...)
    - pattern: django.http.HttpResponseBadRequest(...)
    - pattern: django.http.HttpResponseNotFound(...)
    - pattern: django.http.HttpResponseForbidden(...)
    - pattern: django.http.HttpResponseNotAllowed(...)
    - pattern: django.http.HttpResponseGone(...)
    - pattern: django.http.HttpResponseServerError(...)
- id: python.django.security.audit.xss.filter-with-is-safe.filter-with-is-safe
  message: |
    Detected Django filters flagged with 'is_safe'. 'is_safe' tells Django
    not to apply escaping on the value returned by this filter (although the
    input is escaped). Used improperly, 'is_safe' could expose your application
    to cross-site scripting (XSS) vulnerabilities. Ensure this filter does not
    1) add HTML characters, 2) remove characters, or 3) use external data in
    any way. Consider instead removing 'is_safe' and explicitly marking safe
    content with 'mark_safe()'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/topics/security/#cross-site-scripting-xss-protection
    - https://docs.djangoproject.com/en/3.1/howto/custom-template-tags/#filters-and-auto-escaping
    - https://stackoverflow.com/questions/7665512/why-use-is-safe
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.filter-with-is-safe.filter-with-is-safe
  languages:
  - python
  severity: WARNING
  pattern: |-
    @register.filter(..., is_safe=True, ...)
    def $FILTER(...):
      ...
- id: python.django.security.audit.xss.global-autoescape-off.global-autoescape-off
  message: |
    Autoescape is globally disbaled for this Django application. If you are
    rendering any web pages, this exposes your application to cross-site
    scripting (XSS) vulnerabilities. Remove 'autoescape: False' or set it
    to 'True'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/ref/settings/#templates
    - https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.global-autoescape-off.global-autoescape-off
  languages:
  - python
  severity: WARNING
  pattern: |
    {..., 'BACKEND': ..., 'OPTIONS': {..., 'autoescape': False, ...}, ...}
  fix-regex:
    regex: (autoescape.*?)False
    replacement: \1True
- id: python.django.security.audit.xss.html-magic-method.html-magic-method
  message: |
    The `__html__` method indicates to the Django template engine that the
    value is 'safe' for rendering. This means that normal HTML escaping will
    not be applied to the return value. This exposes your application to
    cross-site scripting (XSS) vulnerabilities. If you need to render raw HTML,
    consider instead using `mark_safe()` which more clearly marks the intent
    to render raw HTML than a class with a magic method.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.0/_modules/django/utils/html/#conditional_escape
    - https://gist.github.com/minusworld/7885d8a81dba3ea2d1e4b8fd3c218ef5
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.html-magic-method.html-magic-method
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      class $CLASS(...):
        ...
  - pattern: |
      def __html__(...):
        ...
- id: python.django.security.audit.xss.html-safe.html-safe
  message: |
    `html_safe()` add the `__html__` magic method to the provided class.
    The `__html__` method indicates to the Django template engine that the
    value is 'safe' for rendering. This means that normal HTML escaping will
    not be applied to the return value. This exposes your application to
    cross-site scripting (XSS) vulnerabilities. If you need to render raw HTML,
    consider instead using `mark_safe()` which more clearly marks the intent
    to render raw HTML than a class with a magic method.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.0/_modules/django/utils/html/#html_safe
    - https://gist.github.com/minusworld/7885d8a81dba3ea2d1e4b8fd3c218ef5
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.html-safe.html-safe
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: django.utils.html.html_safe(...)
  - pattern: |
      @django.utils.html.html_safe
      class $CLASS(...):
        ...
- id: python.django.security.audit.xss.template-autoescape-off.template-autoescape-off
  message: |
    Detected a template block where autoescaping is explicitly
    disabled with '{% autoescape off %}'. This allows rendering of raw HTML
    in this segment. Turn autoescaping on to prevent cross-site scripting (XSS).
    If you must do this, consider instead, using `mark_safe` in Python code.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#autoescape
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.template-autoescape-off.template-autoescape-off
  languages:
  - regex
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{%\s+autoescape\s+off\s+%}'
- id: python.django.security.audit.xss.template-blocktranslate-no-escape.template-blocktranslate-no-escape
  languages:
  - generic
  severity: INFO
  message: |
    Translated strings will not be escaped when rendered in a template.
    This leads to a vulnerability where translators could include malicious script tags in their translations.
    Consider using `force_escape` to explicitly escape a translated text.
  patterns:
  - pattern-either:
    - pattern: |
        {% blocktranslate...%}
    - pattern: |
        {% blocktrans...%}
  - pattern-not-inside: |
      {%...filter...force_escape...%}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {%...endfilter...%}
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
    - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.template-blocktranslate-no-escape.template-blocktranslate-no-escape
- id: python.django.security.audit.xss.template-href-var.template-href-var
  message: |
    Detected a template variable used in an anchor tag with
    the 'href' attribute. This allows a malicious actor to
    input the 'javascript:' URI and is subject to cross-
    site scripting (XSS) attacks. Use the 'url' template tag
    to safely generate a URL. You may also consider setting
    the Content Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
    - https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#url
    - https://content-security-policy.com/
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.template-href-var.template-href-var
  languages:
  - regex
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: .*href\s*=\s*[\"\']?{{\s*.*
- id: python.django.security.audit.xss.template-translate-as-no-escape.template-translate-as-no-escape
  languages:
  - generic
  severity: INFO
  message: |
    Translated strings will not be escaped when rendered in a template.
    This leads to a vulnerability where translators could include malicious script tags in their translations.
    Consider using `force_escape` to explicitly escape a transalted text.
  patterns:
  - pattern-either:
    - pattern: |
        {% translate ... as $TRANS ... %}
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        {{ ... $TRANS ... }}
    - pattern: |
        {% trans ... as $TRANS ... %}
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        {{ ... $TRANS ... }}
  - pattern-not: |
      {% translate ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... | ... force_escape ... }}
  - pattern-not: |
      {% trans ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... | ... force_escape ... }}
  - pattern-not: |
      {% translate ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {% filter force_escape %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... }}
  - pattern-not: |
      {% trans ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {% filter force_escape %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... }}
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
    - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.template-translate-as-no-escape.template-translate-as-no-escape
- id: python.django.security.audit.xss.template-translate-no-escape.template-translate-no-escape
  languages:
  - generic
  severity: INFO
  message: |
    Translated strings will not be escaped when rendered in a template.
    This leads to a vulnerability where translators could include malicious script tags in their translations.
    Consider using `force_escape` to explicitly escape a transalted text.
  patterns:
  - pattern-either:
    - pattern: |
        {% translate...%}
    - pattern: |
        {% trans...%}
  - pattern-not: |
      {% translate...as...%}
  - pattern-not: |
      {% trans...as...%}
  - pattern-not-inside: |
      {%...filter...force_escape...%}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {%...endfilter...%}
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
    - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.template-translate-no-escape.template-translate-no-escape
- id: python.django.security.audit.xss.template-var-unescaped-with-safeseq.template-var-unescaped-with-safeseq
  message: |
    Detected a template variable where autoescaping is explicitly
    disabled with '| safeseq' filter. This allows rendering of raw HTML
    in this segment. Ensure no user data is rendered here, otherwise this
    is a cross-site scripting (XSS) vulnerability. If you must do this,
    use `mark_safe` in your Python code.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/templates/builtins/#safeseq
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.template-var-unescaped-with-safeseq.template-var-unescaped-with-safeseq
  languages:
  - regex
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{{.*?\|\s+safeseq(\s+}})?'
- id: python.django.security.audit.xss.var-in-script-tag.var-in-script-tag
  languages:
  - generic
  severity: ERROR
  message: Detected a template variable used in a script tag. Although template variables
    are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS)
    attacks when used directly in JavaScript. If you need this data on the rendered
    page, consider placing it in the HTML portion (outside of a script tag). Alternatively,
    use a JavaScript-specific encoder, such as the one available in OWASP ESAPI. For
    Django, you may also consider using the 'json_script' template tag and retrieving
    the data in your script by using the element ID (e.g., `document.getElementById`).
  patterns:
  - pattern-inside: <script ...> ... </script>
  - pattern: '{{ ... }}'
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://adamj.eu/tech/2020/02/18/safely-including-data-for-javascript-in-a-django-template/?utm_campaign=Django%2BNewsletter&utm_medium=rss&utm_source=Django_Newsletter_12A
    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough
    - https://github.com/ESAPI/owasp-esapi-js
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.audit.xss.var-in-script-tag.var-in-script-tag
- id: python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
  message: |
    Found request data as an index to 'globals()'. This is extremely
    dangerous because it allows an attacker to execute arbitrary code
    on the system. Refactor your code not to use 'globals()'.
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
- id: python.django.security.injection.code.user-eval-format-string.user-eval-format-string
  message: |
    Found user data in a call to 'eval'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.code.user-eval-format-string.user-eval-format-string
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: eval(..., $STR % request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        eval(..., $STR % $V, ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        $S = $STR % $V
        ...
        eval(..., $S, ...)
    - pattern: eval(..., "..." % request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        eval(..., $STR % $V, ...)
    - pattern: |
        $V = request.$W(...)
        ...
        $S = $STR % $V
        ...
        eval(..., $S, ...)
    - pattern: eval(..., $STR % request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        eval(..., $STR % $V, ...)
    - pattern: |
        $V = request.$W[...]
        ...
        $S = $STR % $V
        ...
        eval(..., $S, ...)
    - pattern: eval(..., $STR.format(..., request.$W.get(...), ...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        eval(..., $STR.format(..., $V, ...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        $S = $STR.format(..., $V, ...)
        ...
        eval(..., $S, ...)
    - pattern: eval(..., $STR.format(..., request.$W(...), ...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        eval(..., $STR.format(..., $V, ...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        $S = $STR.format(..., $V, ...)
        ...
        eval(..., $S, ...)
    - pattern: eval(..., $STR.format(..., request.$W[...], ...), ...)
    - pattern: |
        $V = request.$W[...]
        ...
        eval(..., $STR.format(..., $V, ...), ...)
    - pattern: |
        $V = request.$W[...]
        ...
        $S = $STR.format(..., $V, ...)
        ...
        eval(..., $S, ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        eval(..., f"...{$V}...", ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        $S = f"...{$V}..."
        ...
        eval(..., $S, ...)
    - pattern: |
        $V = request.$W(...)
        ...
        eval(..., f"...{$V}...", ...)
    - pattern: |
        $V = request.$W(...)
        ...
        $S = f"...{$V}..."
        ...
        eval(..., $S, ...)
    - pattern: |
        $V = request.$W[...]
        ...
        eval(..., f"...{$V}...", ...)
    - pattern: |
        $V = request.$W[...]
        ...
        $S = f"...{$V}..."
        ...
        eval(..., $S, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.code.user-eval.user-eval
  message: |
    Found user data in a call to 'eval'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.code.user-eval.user-eval
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: eval(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        eval(..., $V, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.code.user-exec-format-string.user-exec-format-string
  message: |
    Found user data in a call to 'exec'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.code.user-exec-format-string.user-exec-format-string
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: exec(..., $STR % request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        exec(..., $STR % $V, ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        $S = $STR % $V
        ...
        exec(..., $S, ...)
    - pattern: exec(..., "..." % request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        exec(..., $STR % $V, ...)
    - pattern: |
        $V = request.$W(...)
        ...
        $S = $STR % $V
        ...
        exec(..., $S, ...)
    - pattern: exec(..., $STR % request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        exec(..., $STR % $V, ...)
    - pattern: |
        $V = request.$W[...]
        ...
        $S = $STR % $V
        ...
        exec(..., $S, ...)
    - pattern: exec(..., $STR.format(..., request.$W.get(...), ...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        exec(..., $STR.format(..., $V, ...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        $S = $STR.format(..., $V, ...)
        ...
        exec(..., $S, ...)
    - pattern: exec(..., $STR.format(..., request.$W(...), ...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        exec(..., $STR.format(..., $V, ...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        $S = $STR.format(..., $V, ...)
        ...
        exec(..., $S, ...)
    - pattern: exec(..., $STR.format(..., request.$W[...], ...), ...)
    - pattern: |
        $V = request.$W[...]
        ...
        exec(..., $STR.format(..., $V, ...), ...)
    - pattern: |
        $V = request.$W[...]
        ...
        $S = $STR.format(..., $V, ...)
        ...
        exec(..., $S, ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        exec(..., f"...{$V}...", ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        $S = f"...{$V}..."
        ...
        exec(..., $S, ...)
    - pattern: |
        $V = request.$W(...)
        ...
        exec(..., f"...{$V}...", ...)
    - pattern: |
        $V = request.$W(...)
        ...
        $S = f"...{$V}..."
        ...
        exec(..., $S, ...)
    - pattern: |
        $V = request.$W[...]
        ...
        exec(..., f"...{$V}...", ...)
    - pattern: |
        $V = request.$W[...]
        ...
        $S = f"...{$V}..."
        ...
        exec(..., $S, ...)
    - pattern: exec(..., base64.decodestring($S.format(..., request.$W.get(...), ...),
        ...), ...)
    - pattern: exec(..., base64.decodestring($S % request.$W.get(...), ...), ...)
    - pattern: exec(..., base64.decodestring(f"...{request.$W.get(...)}...", ...),
        ...)
    - pattern: exec(..., base64.decodestring(request.$W.get(...), ...), ...)
    - pattern: exec(..., base64.decodestring(bytes($S.format(..., request.$W.get(...),
        ...), ...), ...), ...)
    - pattern: exec(..., base64.decodestring(bytes($S % request.$W.get(...), ...),
        ...), ...)
    - pattern: exec(..., base64.decodestring(bytes(f"...{request.$W.get(...)}...",
        ...), ...), ...)
    - pattern: exec(..., base64.decodestring(bytes(request.$W.get(...), ...), ...),
        ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        exec(..., base64.decodestring($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = base64.decodestring($DATA, ...)
        ...
        exec(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        exec(..., base64.decodestring(bytes($DATA, ...), ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = base64.decodestring(bytes($DATA, ...), ...)
        ...
        exec(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        exec(..., base64.decodestring($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = base64.decodestring($DATA, ...)
        ...
        exec(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        exec(..., base64.decodestring(bytes($DATA, ...), ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = base64.decodestring(bytes($DATA, ...), ...)
        ...
        exec(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        exec(..., base64.decodestring($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = base64.decodestring($DATA, ...)
        ...
        exec(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        exec(..., base64.decodestring(bytes($DATA, ...), ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = base64.decodestring(bytes($DATA, ...), ...)
        ...
        exec(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        exec(..., base64.decodestring($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = base64.decodestring($DATA, ...)
        ...
        exec(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        exec(..., base64.decodestring(bytes($DATA, ...), ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = base64.decodestring(bytes($DATA, ...), ...)
        ...
        exec(..., $INTERM, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.code.user-exec.user-exec
  message: |
    Found user data in a call to 'exec'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.code.user-exec.user-exec
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: exec(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        exec(..., $V, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.command.command-injection-os-system.command-injection-os-system
  message: Request data detected in os.system. This could be vulnerable to a command
    injection and should be avoided. If this must be done, use the 'subprocess' module
    instead and pass the arguments as a list. See https://owasp.org/www-community/attacks/Command_Injection
    for more information.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Command_Injection
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.command.command-injection-os-system.command-injection-os-system
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: os.system(..., request.$W.get(...), ...)
    - pattern: os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: os.system(..., $S % request.$W.get(...), ...)
    - pattern: os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W.get(...), ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: $A = os.system(..., $S % request.$W.get(...), ...)
    - pattern: $A = os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: return os.system(..., request.$W.get(...), ...)
    - pattern: return os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: return os.system(..., $S % request.$W.get(...), ...)
    - pattern: return os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: os.system(..., request.$W(...), ...)
    - pattern: os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: os.system(..., $S % request.$W(...), ...)
    - pattern: os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W(...), ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: $A = os.system(..., $S % request.$W(...), ...)
    - pattern: $A = os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: return os.system(..., request.$W(...), ...)
    - pattern: return os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: return os.system(..., $S % request.$W(...), ...)
    - pattern: return os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: os.system(..., request.$W[...], ...)
    - pattern: os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: os.system(..., $S % request.$W[...], ...)
    - pattern: os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W[...], ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: $A = os.system(..., $S % request.$W[...], ...)
    - pattern: $A = os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: return os.system(..., request.$W[...], ...)
    - pattern: return os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: return os.system(..., $S % request.$W[...], ...)
    - pattern: return os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: os.system(..., request.$W, ...)
    - pattern: os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: os.system(..., $S % request.$W, ...)
    - pattern: os.system(..., f"...{request.$W}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W, ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: $A = os.system(..., $S % request.$W, ...)
    - pattern: $A = os.system(..., f"...{request.$W}...", ...)
    - pattern: return os.system(..., request.$W, ...)
    - pattern: return os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: return os.system(..., $S % request.$W, ...)
    - pattern: return os.system(..., f"...{request.$W}...", ...)
- id: python.django.security.injection.email.xss-html-email-body.xss-html-email-body
  message: |
    Found request data in an EmailMessage that is set to use HTML.
    This is dangerous because HTML emails are susceptible to XSS.
    An attacker could inject data into this HTML email, causing XSS.
  metadata:
    cwe: 'CWE-74: Improper Neutralization of Special Elements in Output Used by a
      Downstream Component (''Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://www.damonkohler.com/2008/12/email-injection.html
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.email.xss-html-email-body.xss-html-email-body
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
        $EMAIL.content_subtype = "html"
        ...
  - pattern-either:
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W, ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W, ...)
- id: python.django.security.injection.email.xss-send-mail-html-message.xss-send-mail-html-message
  message: |
    Found request data in 'send_mail(...)' that uses 'html_message'.
    This is dangerous because HTML emails are susceptible to XSS.
    An attacker could inject data into this HTML email, causing XSS.
  metadata:
    cwe: 'CWE-74: Improper Neutralization of Special Elements in Output Used by a
      Downstream Component (''Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://www.damonkohler.com/2008/12/email-injection.html
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.email.xss-send-mail-html-message.xss-send-mail-html-message
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W.get(...),
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W.get(...),
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W(...),
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W(...),
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W[...],
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W[...],
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W, ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W, ...)
- id: python.django.security.injection.mass-assignment.mass-assignment
  languages:
  - python
  severity: WARNING
  message: |
    Mass assignment detected. This can result in assignment to
    model fields that are unintended and can be exploited by
    an attacker. Instead of using '**request.$W', assign each field you
    want to edit individually to prevent mass assignment. You can read
    more about mass assignment at
    https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    owaspapi: 'API6: Mass Assignment'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.mass-assignment.mass-assignment
  pattern-either:
  - pattern: $MODEL.objects.create(**request.$W)
  - pattern: |
      $OBJ.update(**request.$W)
      ...
      $OBJ.save()
- id: python.django.security.injection.open-redirect.open-redirect
  message: |
    Data from request ($DATA) is passed to redirect(). This is an open redirect and could be exploited.
    Ensure you are redirecting to safe URLs by using django.utils.http.is_safe_url().
    See https://cwe.mitre.org/data/definitions/601.html for more information.
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    owasp: 'A1: Injection'
    references:
    - https://www.djm.org.uk/posts/djangos-little-protections-word-redirect-dangers/
    - https://github.com/django/django/blob/d1b7bd030b1db111e1a3505b1fc029ab964382cc/django/utils/http.py#L231
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.open-redirect.open-redirect
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-not-inside: |
      def $FUNC(...):
        ...
        django.utils.http.is_safe_url(...)
        ...
  - pattern-not-inside: |
      def $FUNC(...):
        ...
        if <... django.utils.http.is_safe_url(...) ...>:
          ...
  - pattern-either:
    - pattern: django.shortcuts.redirect(..., request.$W.get(...), ...)
    - pattern: django.shortcuts.redirect(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: django.shortcuts.redirect(..., $S % request.$W.get(...), ...)
    - pattern: django.shortcuts.redirect(..., f"...{request.$W.get(...)}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.shortcuts.redirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.shortcuts.redirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.shortcuts.redirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.shortcuts.redirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: $A = django.shortcuts.redirect(..., request.$W.get(...), ...)
    - pattern: $A = django.shortcuts.redirect(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: $A = django.shortcuts.redirect(..., $S % request.$W.get(...), ...)
    - pattern: $A = django.shortcuts.redirect(..., f"...{request.$W.get(...)}...",
        ...)
    - pattern: return django.shortcuts.redirect(..., request.$W.get(...), ...)
    - pattern: return django.shortcuts.redirect(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: return django.shortcuts.redirect(..., $S % request.$W.get(...), ...)
    - pattern: return django.shortcuts.redirect(..., f"...{request.$W.get(...)}...",
        ...)
    - pattern: django.shortcuts.redirect(..., request.$W(...), ...)
    - pattern: django.shortcuts.redirect(..., $S.format(..., request.$W(...), ...),
        ...)
    - pattern: django.shortcuts.redirect(..., $S % request.$W(...), ...)
    - pattern: django.shortcuts.redirect(..., f"...{request.$W(...)}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.shortcuts.redirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.shortcuts.redirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.shortcuts.redirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.shortcuts.redirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: $A = django.shortcuts.redirect(..., request.$W(...), ...)
    - pattern: $A = django.shortcuts.redirect(..., $S.format(..., request.$W(...),
        ...), ...)
    - pattern: $A = django.shortcuts.redirect(..., $S % request.$W(...), ...)
    - pattern: $A = django.shortcuts.redirect(..., f"...{request.$W(...)}...", ...)
    - pattern: return django.shortcuts.redirect(..., request.$W(...), ...)
    - pattern: return django.shortcuts.redirect(..., $S.format(..., request.$W(...),
        ...), ...)
    - pattern: return django.shortcuts.redirect(..., $S % request.$W(...), ...)
    - pattern: return django.shortcuts.redirect(..., f"...{request.$W(...)}...", ...)
    - pattern: django.shortcuts.redirect(..., request.$W[...], ...)
    - pattern: django.shortcuts.redirect(..., $S.format(..., request.$W[...], ...),
        ...)
    - pattern: django.shortcuts.redirect(..., $S % request.$W[...], ...)
    - pattern: django.shortcuts.redirect(..., f"...{request.$W[...]}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.shortcuts.redirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.shortcuts.redirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.shortcuts.redirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.shortcuts.redirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: $A = django.shortcuts.redirect(..., request.$W[...], ...)
    - pattern: $A = django.shortcuts.redirect(..., $S.format(..., request.$W[...],
        ...), ...)
    - pattern: $A = django.shortcuts.redirect(..., $S % request.$W[...], ...)
    - pattern: $A = django.shortcuts.redirect(..., f"...{request.$W[...]}...", ...)
    - pattern: return django.shortcuts.redirect(..., request.$W[...], ...)
    - pattern: return django.shortcuts.redirect(..., $S.format(..., request.$W[...],
        ...), ...)
    - pattern: return django.shortcuts.redirect(..., $S % request.$W[...], ...)
    - pattern: return django.shortcuts.redirect(..., f"...{request.$W[...]}...", ...)
    - pattern: django.shortcuts.redirect(..., request.$W, ...)
    - pattern: django.shortcuts.redirect(..., $S.format(..., request.$W, ...), ...)
    - pattern: django.shortcuts.redirect(..., $S % request.$W, ...)
    - pattern: django.shortcuts.redirect(..., f"...{request.$W}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.shortcuts.redirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.shortcuts.redirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.shortcuts.redirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.shortcuts.redirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.shortcuts.redirect(..., $INTERM, ...)
    - pattern: $A = django.shortcuts.redirect(..., request.$W, ...)
    - pattern: $A = django.shortcuts.redirect(..., $S.format(..., request.$W, ...),
        ...)
    - pattern: $A = django.shortcuts.redirect(..., $S % request.$W, ...)
    - pattern: $A = django.shortcuts.redirect(..., f"...{request.$W}...", ...)
    - pattern: return django.shortcuts.redirect(..., request.$W, ...)
    - pattern: return django.shortcuts.redirect(..., $S.format(..., request.$W, ...),
        ...)
    - pattern: return django.shortcuts.redirect(..., $S % request.$W, ...)
    - pattern: return django.shortcuts.redirect(..., f"...{request.$W}...", ...)
    - pattern: django.http.HttpResponseRedirect(..., request.$W.get(...), ...)
    - pattern: django.http.HttpResponseRedirect(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: django.http.HttpResponseRedirect(..., $S % request.$W.get(...), ...)
    - pattern: django.http.HttpResponseRedirect(..., f"...{request.$W.get(...)}...",
        ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseRedirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseRedirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseRedirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseRedirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., request.$W.get(...), ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S % request.$W.get(...),
        ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., f"...{request.$W.get(...)}...",
        ...)
    - pattern: return django.http.HttpResponseRedirect(..., request.$W.get(...), ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S % request.$W.get(...),
        ...)
    - pattern: return django.http.HttpResponseRedirect(..., f"...{request.$W.get(...)}...",
        ...)
    - pattern: django.http.HttpResponseRedirect(..., request.$W(...), ...)
    - pattern: django.http.HttpResponseRedirect(..., $S.format(..., request.$W(...),
        ...), ...)
    - pattern: django.http.HttpResponseRedirect(..., $S % request.$W(...), ...)
    - pattern: django.http.HttpResponseRedirect(..., f"...{request.$W(...)}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseRedirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseRedirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseRedirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseRedirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., request.$W(...), ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W(...),
        ...), ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S % request.$W(...), ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., f"...{request.$W(...)}...",
        ...)
    - pattern: return django.http.HttpResponseRedirect(..., request.$W(...), ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S.format(..., request.$W(...),
        ...), ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S % request.$W(...),
        ...)
    - pattern: return django.http.HttpResponseRedirect(..., f"...{request.$W(...)}...",
        ...)
    - pattern: django.http.HttpResponseRedirect(..., request.$W[...], ...)
    - pattern: django.http.HttpResponseRedirect(..., $S.format(..., request.$W[...],
        ...), ...)
    - pattern: django.http.HttpResponseRedirect(..., $S % request.$W[...], ...)
    - pattern: django.http.HttpResponseRedirect(..., f"...{request.$W[...]}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseRedirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseRedirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseRedirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseRedirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., request.$W[...], ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W[...],
        ...), ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S % request.$W[...], ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., f"...{request.$W[...]}...",
        ...)
    - pattern: return django.http.HttpResponseRedirect(..., request.$W[...], ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S.format(..., request.$W[...],
        ...), ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S % request.$W[...],
        ...)
    - pattern: return django.http.HttpResponseRedirect(..., f"...{request.$W[...]}...",
        ...)
    - pattern: django.http.HttpResponseRedirect(..., request.$W, ...)
    - pattern: django.http.HttpResponseRedirect(..., $S.format(..., request.$W, ...),
        ...)
    - pattern: django.http.HttpResponseRedirect(..., $S % request.$W, ...)
    - pattern: django.http.HttpResponseRedirect(..., f"...{request.$W}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseRedirect(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseRedirect(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseRedirect(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseRedirect(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseRedirect(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., request.$W, ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W,
        ...), ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., $S % request.$W, ...)
    - pattern: $A = django.http.HttpResponseRedirect(..., f"...{request.$W}...", ...)
    - pattern: return django.http.HttpResponseRedirect(..., request.$W, ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S.format(..., request.$W,
        ...), ...)
    - pattern: return django.http.HttpResponseRedirect(..., $S % request.$W, ...)
    - pattern: return django.http.HttpResponseRedirect(..., f"...{request.$W}...",
        ...)
  - metavariable-regex:
      metavariable: $W
      regex: (?!get_full_path)
- id: python.django.security.injection.path-traversal.path-traversal-file-name.path-traversal-file-name
  message: |
    Data from request is passed to a file name `$FILE`.
    This is a path traversal vulnerability: https://owasp.org/www-community/attacks/Path_Traversal
    To mitigate, consider using os.path.abspath or os.path.realpath or Path library.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.path-traversal.path-traversal-file-name.path-traversal-file-name
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-not: |
      ...
      os.path.realpath(...)
      ...
  - pattern-not: |
      ...
      os.path.abspath(...)
      ...
  - pattern-either:
    - pattern: |
        $V = request.$W.get($X)
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W[$X]
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W($X)
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W
        ...
        $FILE % ($V)
        # match format use cases
    - pattern: |
        $V = request.$W.get($X)
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W[$X]
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W($X)
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W
        ...
        $FILE.format(..., $V, ...)
  - metavariable-regex:
      metavariable: $FILE
      regex: .*\.(log|zip|txt|csv|xml|html).*
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.path-traversal.path-traversal-join.path-traversal-join
  message: |
    Data from request is passed to os.path.join() and to open().
    This is a path traversal vulnerability: https://owasp.org/www-community/attacks/Path_Traversal
    To mitigate, consider using os.path.abspath or os.path.realpath or Path library.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.path-traversal.path-traversal-join.path-traversal-join
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-not: |
      ...
      os.path.abspath(...)
      ...
  - pattern-not: |
      ...
      os.path.realpath(...)
      ...
  - pattern-either:
    - pattern: open(os.path.join(..., request.$W.get(...), ...), ...)
    - pattern: open(os.path.join(..., request.$W(...), ...), ...)
    - pattern: open(os.path.join(..., request.$W, ...), ...)
    - pattern: open(os.path.join(..., request.$W[...], ...), ...)
    - pattern: |
        $P = os.path.join(..., request.$W.get(...), ...)
        ...
        open($P, ...)
    - pattern: |
        $P = os.path.join(..., request.$W(...), ...)
        ...
        open($P, ...)
    - pattern: |
        $P = os.path.join(..., request.$W, ...)
        ...
        open($P, ...)
    - pattern: |
        $P = os.path.join(..., request.$W[...], ...)
        ...
        open($P, ...)
    - pattern: |
        $V = request.$W.get($X)
        ...
        $P = os.path.join(..., $V, ...)
        ...
        open($P, ...)
    - pattern: |
        $V = request.$W($X)
        ...
        $P = os.path.join(..., $V, ...)
        ...
        open($P, ...)
    - pattern: |
        $V = request.$W[$X]
        ...
        $P = os.path.join(..., $V, ...)
        ...
        open($P, ...)
    - pattern: |
        $V = request.$W
        ...
        $P = os.path.join(..., $V, ...)
        ...
        open($P, ...)
    - pattern: |
        $P = request.$W.get(...)
        ...
        open(os.path.join(..., $P, ...), ...)
    - pattern: |
        $P = request.$W(...)
        ...
        open(os.path.join(..., $P, ...), ...)
    - pattern: |
        $P = request.$W
        ...
        open(os.path.join(..., $P, ...), ...)
    - pattern: |
        $P = request.$W[...]
        ...
        open(os.path.join(..., $P, ...), ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.path-traversal.path-traversal-open.path-traversal-open
  message: Found request data in a call to 'open'. Ensure the request data is validated
    or sanitized, otherwise it could result in path traversal attacks.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.path-traversal.path-traversal-open.path-traversal-open
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: open(..., request.$W.get(...), ...)
    - pattern: open(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: open(..., $S % request.$W.get(...), ...)
    - pattern: open(..., f"...{request.$W.get(...)}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        open(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        open(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        open(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        open(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        open(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: $A = open(..., request.$W.get(...), ...)
    - pattern: $A = open(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: $A = open(..., $S % request.$W.get(...), ...)
    - pattern: $A = open(..., f"...{request.$W.get(...)}...", ...)
    - pattern: return open(..., request.$W.get(...), ...)
    - pattern: return open(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: return open(..., $S % request.$W.get(...), ...)
    - pattern: return open(..., f"...{request.$W.get(...)}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        with open(..., $DATA, ...) as $FD:
          ...
    - pattern: open(..., request.$W(...), ...)
    - pattern: open(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: open(..., $S % request.$W(...), ...)
    - pattern: open(..., f"...{request.$W(...)}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        open(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W(...)
        ...
        open(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W(...)
        ...
        open(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W(...)
        ...
        open(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W(...)
        ...
        open(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: $A = open(..., request.$W(...), ...)
    - pattern: $A = open(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: $A = open(..., $S % request.$W(...), ...)
    - pattern: $A = open(..., f"...{request.$W(...)}...", ...)
    - pattern: return open(..., request.$W(...), ...)
    - pattern: return open(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: return open(..., $S % request.$W(...), ...)
    - pattern: return open(..., f"...{request.$W(...)}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        with open(..., $DATA, ...) as $FD:
          ...
    - pattern: open(..., request.$W[...], ...)
    - pattern: open(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: open(..., $S % request.$W[...], ...)
    - pattern: open(..., f"...{request.$W[...]}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        open(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W[...]
        ...
        open(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W[...]
        ...
        open(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W[...]
        ...
        open(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W[...]
        ...
        open(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: $A = open(..., request.$W[...], ...)
    - pattern: $A = open(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: $A = open(..., $S % request.$W[...], ...)
    - pattern: $A = open(..., f"...{request.$W[...]}...", ...)
    - pattern: return open(..., request.$W[...], ...)
    - pattern: return open(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: return open(..., $S % request.$W[...], ...)
    - pattern: return open(..., f"...{request.$W[...]}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        with open(..., $DATA, ...) as $FD:
          ...
    - pattern: open(..., request.$W, ...)
    - pattern: open(..., $S.format(..., request.$W, ...), ...)
    - pattern: open(..., $S % request.$W, ...)
    - pattern: open(..., f"...{request.$W}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        open(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W
        ...
        open(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W
        ...
        open(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W
        ...
        open(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: |
        $DATA = request.$W
        ...
        open(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        open(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        with open(..., $INTERM, ...) as $FD:
          ...
    - pattern: $A = open(..., request.$W, ...)
    - pattern: $A = open(..., $S.format(..., request.$W, ...), ...)
    - pattern: $A = open(..., $S % request.$W, ...)
    - pattern: $A = open(..., f"...{request.$W}...", ...)
    - pattern: return open(..., request.$W, ...)
    - pattern: return open(..., $S.format(..., request.$W, ...), ...)
    - pattern: return open(..., $S % request.$W, ...)
    - pattern: return open(..., f"...{request.$W}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        with open(..., $DATA, ...) as $FD:
          ...
- id: python.django.security.injection.reflected-data-httpresponsebadrequest.reflected-data-httpresponsebadrequest
  message: Found request data reflected into HttpResponseBadRequest. This could be
    vulnerable to XSS. Ensure the request data is properly escaped or sanitzed.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://django-book.readthedocs.io/en/latest/chapter20.html#cross-site-scripting-xss
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.reflected-data-httpresponsebadrequest.reflected-data-httpresponsebadrequest
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: django.http.HttpResponseBadRequest(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: django.http.HttpResponseBadRequest(..., $S % request.$W.get(...), ...)
    - pattern: django.http.HttpResponseBadRequest(..., f"...{request.$W.get(...)}...",
        ...)
    - pattern: django.http.HttpResponseBadRequest(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseBadRequest(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseBadRequest(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseBadRequest(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponseBadRequest(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseBadRequest(..., request.$W.get(...), ...)
    - pattern: return django.http.HttpResponseBadRequest(..., request.$W.get(...),
        ...)
    - pattern: django.http.HttpResponseBadRequest(..., $S.format(..., request.$W(...),
        ...), ...)
    - pattern: django.http.HttpResponseBadRequest(..., $S % request.$W(...), ...)
    - pattern: django.http.HttpResponseBadRequest(..., f"...{request.$W(...)}...",
        ...)
    - pattern: django.http.HttpResponseBadRequest(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseBadRequest(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseBadRequest(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseBadRequest(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponseBadRequest(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseBadRequest(..., request.$W(...), ...)
    - pattern: return django.http.HttpResponseBadRequest(..., request.$W(...), ...)
    - pattern: django.http.HttpResponseBadRequest(..., $S.format(..., request.$W[...],
        ...), ...)
    - pattern: django.http.HttpResponseBadRequest(..., $S % request.$W[...], ...)
    - pattern: django.http.HttpResponseBadRequest(..., f"...{request.$W[...]}...",
        ...)
    - pattern: django.http.HttpResponseBadRequest(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseBadRequest(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseBadRequest(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseBadRequest(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponseBadRequest(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseBadRequest(..., request.$W[...], ...)
    - pattern: return django.http.HttpResponseBadRequest(..., request.$W[...], ...)
    - pattern: django.http.HttpResponseBadRequest(..., $S.format(..., request.$W,
        ...), ...)
    - pattern: django.http.HttpResponseBadRequest(..., $S % request.$W, ...)
    - pattern: django.http.HttpResponseBadRequest(..., f"...{request.$W}...", ...)
    - pattern: django.http.HttpResponseBadRequest(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseBadRequest(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseBadRequest(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseBadRequest(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponseBadRequest(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponseBadRequest(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponseBadRequest(..., request.$W, ...)
    - pattern: return django.http.HttpResponseBadRequest(..., request.$W, ...)
- id: python.django.security.injection.reflected-data-httpresponse.reflected-data-httpresponse
  message: Found request data reflected into HttpResponse. This could be vulnerable
    to XSS. Ensure the request data is properly escaped or sanitzed.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://django-book.readthedocs.io/en/latest/chapter20.html#cross-site-scripting-xss
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.reflected-data-httpresponse.reflected-data-httpresponse
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W.get(...), ...),
        ...)
    - pattern: django.http.HttpResponse(..., $S % request.$W.get(...), ...)
    - pattern: django.http.HttpResponse(..., f"...{request.$W.get(...)}...", ...)
    - pattern: django.http.HttpResponse(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponse(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponse(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponse(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.HttpResponse(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponse(..., request.$W.get(...), ...)
    - pattern: return django.http.HttpResponse(..., request.$W.get(...), ...)
    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W(...), ...),
        ...)
    - pattern: django.http.HttpResponse(..., $S % request.$W(...), ...)
    - pattern: django.http.HttpResponse(..., f"...{request.$W(...)}...", ...)
    - pattern: django.http.HttpResponse(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponse(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponse(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponse(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.HttpResponse(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponse(..., request.$W(...), ...)
    - pattern: return django.http.HttpResponse(..., request.$W(...), ...)
    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W[...], ...),
        ...)
    - pattern: django.http.HttpResponse(..., $S % request.$W[...], ...)
    - pattern: django.http.HttpResponse(..., f"...{request.$W[...]}...", ...)
    - pattern: django.http.HttpResponse(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponse(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponse(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponse(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.HttpResponse(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: $A = django.http.HttpResponse(..., request.$W[...], ...)
    - pattern: return django.http.HttpResponse(..., request.$W[...], ...)
    - pattern: django.http.HttpResponse(..., $S.format(..., request.$W, ...), ...)
    - pattern: django.http.HttpResponse(..., $S % request.$W, ...)
    - pattern: django.http.HttpResponse(..., f"...{request.$W}...", ...)
    - pattern: django.http.HttpResponse(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponse(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponse(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponse(..., f"...{$DATA}...", ...)
    - pattern: $A = django.http.HttpResponse(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        $A = django.http.HttpResponse(..., $INTERM, ...)
    - pattern: return django.http.HttpResponse(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.http.HttpResponse(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.HttpResponse(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.http.HttpResponse(..., $INTERM, ...)
- id: python.django.security.injection.request-data-fileresponse.request-data-fileresponse
  message: Found request data opening a file into FileResponse. This is dangerous
    because an attacker could specify an arbitrary file to read, leaking data. Be
    sure to validate or sanitize the filename before using it in FileResponse.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://django-book.readthedocs.io/en/latest/chapter20.html#cross-site-scripting-xss
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.request-data-fileresponse.request-data-fileresponse
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: django.http.FileResponse(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.http.FileResponse(..., open($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = open($DATA, ...)
        ...
        django.http.FileResponse(..., $INTERM, ...)
    - pattern: $A = django.http.FileResponse(..., request.$W.get(...), ...)
    - pattern: return django.http.FileResponse(..., request.$W.get(...), ...)
    - pattern: django.http.FileResponse(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.http.FileResponse(..., open($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = open($DATA, ...)
        ...
        django.http.FileResponse(..., $INTERM, ...)
    - pattern: $A = django.http.FileResponse(..., request.$W(...), ...)
    - pattern: return django.http.FileResponse(..., request.$W(...), ...)
    - pattern: django.http.FileResponse(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.http.FileResponse(..., open($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = open($DATA, ...)
        ...
        django.http.FileResponse(..., $INTERM, ...)
    - pattern: $A = django.http.FileResponse(..., request.$W[...], ...)
    - pattern: return django.http.FileResponse(..., request.$W[...], ...)
    - pattern: django.http.FileResponse(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.http.FileResponse(..., open($DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = open($DATA, ...)
        ...
        django.http.FileResponse(..., $INTERM, ...)
    - pattern: $A = django.http.FileResponse(..., request.$W, ...)
    - pattern: return django.http.FileResponse(..., request.$W, ...)
- id: python.django.security.injection.request-data-write.request-data-write
  message: |
    Found request data in '.write(...)'. This could be dangerous if a malicious
    actor is able to control data into sensitive files. For example, a malicious
    actor could force rolling of critical log files, or cause a denial-of-service
    by using up available disk space. Ensure content is validated.
  metadata:
    cwe: 'CWE-93: Improper Neutralization of CRLF Sequences (''CRLF Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.request-data-write.request-data-write
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: $F.write(..., request.$W.get(...), ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $F.write(..., $DATA, ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $INTERM = $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $F.write(..., $B.$C(..., $DATA, ...), ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $INTERM = $B.$C(..., $DATA, ...)
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $F.write(..., $STR % $DATA, ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $INTERM = $STR % $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $F.write(..., f"...{$DATA}...", ...)
  - pattern: |
      $DATA = request.$W.get(...)
      ...
      $INTERM = f"...{$DATA}..."
      ...
      $F.write(..., $INTERM, ...)
  - pattern: $A = $F.write(..., request.$W.get(...), ...)
  - pattern: return $F.write(..., request.$W.get(...), ...)
  - pattern: $F.write(..., request.$W(...), ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $F.write(..., $DATA, ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $INTERM = $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $F.write(..., $B.$C(..., $DATA, ...), ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $INTERM = $B.$C(..., $DATA, ...)
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $F.write(..., $STR % $DATA, ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $INTERM = $STR % $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $F.write(..., f"...{$DATA}...", ...)
  - pattern: |
      $DATA = request.$W(...)
      ...
      $INTERM = f"...{$DATA}..."
      ...
      $F.write(..., $INTERM, ...)
  - pattern: $A = $F.write(..., request.$W(...), ...)
  - pattern: return $F.write(..., request.$W(...), ...)
  - pattern: $F.write(..., request.$W[...], ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $F.write(..., $DATA, ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $INTERM = $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $F.write(..., $B.$C(..., $DATA, ...), ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $INTERM = $B.$C(..., $DATA, ...)
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $F.write(..., $STR % $DATA, ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $INTERM = $STR % $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $F.write(..., f"...{$DATA}...", ...)
  - pattern: |
      $DATA = request.$W[...]
      ...
      $INTERM = f"...{$DATA}..."
      ...
      $F.write(..., $INTERM, ...)
  - pattern: $A = $F.write(..., request.$W[...], ...)
  - pattern: return $F.write(..., request.$W[...], ...)
  - pattern: $F.write(..., request.$W, ...)
  - pattern: |
      $DATA = request.$W
      ...
      $F.write(..., $DATA, ...)
  - pattern: |
      $DATA = request.$W
      ...
      $INTERM = $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W
      ...
      $F.write(..., $B.$C(..., $DATA, ...), ...)
  - pattern: |
      $DATA = request.$W
      ...
      $INTERM = $B.$C(..., $DATA, ...)
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W
      ...
      $F.write(..., $STR % $DATA, ...)
  - pattern: |
      $DATA = request.$W
      ...
      $INTERM = $STR % $DATA
      ...
      $F.write(..., $INTERM, ...)
  - pattern: |
      $DATA = request.$W
      ...
      $F.write(..., f"...{$DATA}...", ...)
  - pattern: |
      $DATA = request.$W
      ...
      $INTERM = f"...{$DATA}..."
      ...
      $F.write(..., $INTERM, ...)
  - pattern: $A = $F.write(..., request.$W, ...)
  - pattern: return $F.write(..., request.$W, ...)
- id: python.django.security.injection.sql.sql-injection-extra.sql-injection-using-extra-where
  message: Data from request is passed to extra(). This is a SQL injection and could
    be exploited. See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#.objects.extra
    to learn how to mitigate. See https://cwe.mitre.org/data/definitions/89.html to
    learn about SQLi.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#.objects.extra
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.sql.sql-injection-extra.sql-injection-using-extra-where
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: $MODEL.objects.extra(..., where=[..., $S.format(..., request.$W.get(...),
        ...), ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., $S % request.$W.get(...), ...],
        ...)
    - pattern: $MODEL.objects.extra(..., where=[..., f"...{request.$W.get(...)}...",
        ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., request.$W.get(...), ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.extra(..., where=[..., $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.extra(..., where=[..., f"...{$DATA}...", ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: $A = $MODEL.objects.extra(..., where=[..., request.$W.get(...), ...],
        ...)
    - pattern: return $MODEL.objects.extra(..., where=[..., request.$W.get(...), ...],
        ...)
    - pattern: $MODEL.objects.extra(..., where=[..., $S.format(..., request.$W(...),
        ...), ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., $S % request.$W(...), ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., f"...{request.$W(...)}...", ...],
        ...)
    - pattern: $MODEL.objects.extra(..., where=[..., request.$W(...), ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.extra(..., where=[..., $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.extra(..., where=[..., f"...{$DATA}...", ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: $A = $MODEL.objects.extra(..., where=[..., request.$W(...), ...], ...)
    - pattern: return $MODEL.objects.extra(..., where=[..., request.$W(...), ...],
        ...)
    - pattern: $MODEL.objects.extra(..., where=[..., $S.format(..., request.$W[...],
        ...), ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., $S % request.$W[...], ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., f"...{request.$W[...]}...", ...],
        ...)
    - pattern: $MODEL.objects.extra(..., where=[..., request.$W[...], ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.extra(..., where=[..., $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.extra(..., where=[..., f"...{$DATA}...", ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: $A = $MODEL.objects.extra(..., where=[..., request.$W[...], ...], ...)
    - pattern: return $MODEL.objects.extra(..., where=[..., request.$W[...], ...],
        ...)
    - pattern: $MODEL.objects.extra(..., where=[..., $S.format(..., request.$W, ...),
        ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., $S % request.$W, ...], ...)
    - pattern: $MODEL.objects.extra(..., where=[..., f"...{request.$W}...", ...],
        ...)
    - pattern: $MODEL.objects.extra(..., where=[..., request.$W, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.extra(..., where=[..., $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.extra(..., where=[..., f"...{$DATA}...", ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: $A = $MODEL.objects.extra(..., where=[..., request.$W, ...], ...)
    - pattern: return $MODEL.objects.extra(..., where=[..., request.$W, ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)
- id: python.django.security.injection.sql.sql-injection-rawsql.sql-injection-using-rawsql
  message: Data from request is passed to RawSQL(). This is a SQL injection and could
    be exploited. See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.expressions.RawSQL
    to learn how to mitigate. See https://cwe.mitre.org/data/definitions/89.html to
    learn about SQLi.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.expressions.RawSQL
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.sql.sql-injection-rawsql.sql-injection-using-rawsql
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: django.db.models.expressions.RawSQL(..., $S.format(..., request.$W.get(...),
        ...), ...)
    - pattern: django.db.models.expressions.RawSQL(..., $S % request.$W.get(...),
        ...)
    - pattern: django.db.models.expressions.RawSQL(..., f"...{request.$W.get(...)}...",
        ...)
    - pattern: django.db.models.expressions.RawSQL(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.db.models.expressions.RawSQL(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.db.models.expressions.RawSQL(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.db.models.expressions.RawSQL(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.db.models.expressions.RawSQL(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: $A = django.db.models.expressions.RawSQL(..., request.$W.get(...),
        ...)
    - pattern: return django.db.models.expressions.RawSQL(..., request.$W.get(...),
        ...)
    - pattern: django.db.models.expressions.RawSQL(..., $S.format(..., request.$W(...),
        ...), ...)
    - pattern: django.db.models.expressions.RawSQL(..., $S % request.$W(...), ...)
    - pattern: django.db.models.expressions.RawSQL(..., f"...{request.$W(...)}...",
        ...)
    - pattern: django.db.models.expressions.RawSQL(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.db.models.expressions.RawSQL(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.db.models.expressions.RawSQL(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.db.models.expressions.RawSQL(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.db.models.expressions.RawSQL(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: $A = django.db.models.expressions.RawSQL(..., request.$W(...), ...)
    - pattern: return django.db.models.expressions.RawSQL(..., request.$W(...), ...)
    - pattern: django.db.models.expressions.RawSQL(..., $S.format(..., request.$W[...],
        ...), ...)
    - pattern: django.db.models.expressions.RawSQL(..., $S % request.$W[...], ...)
    - pattern: django.db.models.expressions.RawSQL(..., f"...{request.$W[...]}...",
        ...)
    - pattern: django.db.models.expressions.RawSQL(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.db.models.expressions.RawSQL(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.db.models.expressions.RawSQL(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.db.models.expressions.RawSQL(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.db.models.expressions.RawSQL(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: $A = django.db.models.expressions.RawSQL(..., request.$W[...], ...)
    - pattern: return django.db.models.expressions.RawSQL(..., request.$W[...], ...)
    - pattern: django.db.models.expressions.RawSQL(..., $S.format(..., request.$W,
        ...), ...)
    - pattern: django.db.models.expressions.RawSQL(..., $S % request.$W, ...)
    - pattern: django.db.models.expressions.RawSQL(..., f"...{request.$W}...", ...)
    - pattern: django.db.models.expressions.RawSQL(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.db.models.expressions.RawSQL(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.db.models.expressions.RawSQL(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.db.models.expressions.RawSQL(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.db.models.expressions.RawSQL(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.db.models.expressions.RawSQL(..., $INTERM, ...)
    - pattern: $A = django.db.models.expressions.RawSQL(..., request.$W, ...)
    - pattern: return django.db.models.expressions.RawSQL(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL($INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL($INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL($INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        django.db.models.expressions.RawSQL($INTERM, ...)
- id: python.django.security.injection.sql.sql-injection-using-db-cursor-execute.sql-injection-db-cursor-execute
  message: Data from request is passed to execute(). This is a SQL injection and could
    be exploited. See https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection
    to learn how to mitigate. See https://cwe.mitre.org/data/definitions/89.html to
    learn about SQLi.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.sql.sql-injection-using-db-cursor-execute.sql-injection-db-cursor-execute
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: $CURSOR.execute(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: $CURSOR.execute(..., $S % request.$W.get(...), ...)
    - pattern: $CURSOR.execute(..., f"...{request.$W.get(...)}...", ...)
    - pattern: $CURSOR.execute(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $CURSOR.execute(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $CURSOR.execute(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $CURSOR.execute(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $CURSOR.execute(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: $A = $CURSOR.execute(..., request.$W.get(...), ...)
    - pattern: return $CURSOR.execute(..., request.$W.get(...), ...)
    - pattern: $CURSOR.execute(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: $CURSOR.execute(..., $S % request.$W(...), ...)
    - pattern: $CURSOR.execute(..., f"...{request.$W(...)}...", ...)
    - pattern: $CURSOR.execute(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $CURSOR.execute(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $CURSOR.execute(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $CURSOR.execute(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $CURSOR.execute(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: $A = $CURSOR.execute(..., request.$W(...), ...)
    - pattern: return $CURSOR.execute(..., request.$W(...), ...)
    - pattern: $CURSOR.execute(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: $CURSOR.execute(..., $S % request.$W[...], ...)
    - pattern: $CURSOR.execute(..., f"...{request.$W[...]}...", ...)
    - pattern: $CURSOR.execute(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $CURSOR.execute(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $CURSOR.execute(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $CURSOR.execute(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $CURSOR.execute(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: $A = $CURSOR.execute(..., request.$W[...], ...)
    - pattern: return $CURSOR.execute(..., request.$W[...], ...)
    - pattern: $CURSOR.execute(..., $S.format(..., request.$W, ...), ...)
    - pattern: $CURSOR.execute(..., $S % request.$W, ...)
    - pattern: $CURSOR.execute(..., f"...{request.$W}...", ...)
    - pattern: $CURSOR.execute(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $CURSOR.execute(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $CURSOR.execute(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $CURSOR.execute(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $CURSOR.execute(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        $CURSOR.execute(..., $INTERM, ...)
    - pattern: $A = $CURSOR.execute(..., request.$W, ...)
    - pattern: return $CURSOR.execute(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $CURSOR.execute($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $CURSOR.execute($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $CURSOR.execute($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $CURSOR.execute($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $CURSOR.execute($INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $CURSOR.execute($INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $CURSOR.execute($INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $CURSOR.execute($INTERM, ...)
- id: python.django.security.injection.sql.sql-injection-using-raw.sql-injection-using-raw
  message: Data from request is passed to raw(). This is a SQL injection and could
    be exploited. See https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection
    to learn how to mitigate. See https://cwe.mitre.org/data/definitions/89.html to
    learn about SQLi.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.sql.sql-injection-using-raw.sql-injection-using-raw
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: $MODEL.objects.raw(..., $S % request.$W.get(...), ...)
    - pattern: $MODEL.objects.raw(..., f"...{request.$W.get(...)}...", ...)
    - pattern: $MODEL.objects.raw(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.raw(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.raw(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.raw(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.raw(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: $A = $MODEL.objects.raw(..., request.$W.get(...), ...)
    - pattern: return $MODEL.objects.raw(..., request.$W.get(...), ...)
    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: $MODEL.objects.raw(..., $S % request.$W(...), ...)
    - pattern: $MODEL.objects.raw(..., f"...{request.$W(...)}...", ...)
    - pattern: $MODEL.objects.raw(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.raw(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.raw(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.raw(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.raw(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: $A = $MODEL.objects.raw(..., request.$W(...), ...)
    - pattern: return $MODEL.objects.raw(..., request.$W(...), ...)
    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: $MODEL.objects.raw(..., $S % request.$W[...], ...)
    - pattern: $MODEL.objects.raw(..., f"...{request.$W[...]}...", ...)
    - pattern: $MODEL.objects.raw(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.raw(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.raw(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.raw(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.raw(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: $A = $MODEL.objects.raw(..., request.$W[...], ...)
    - pattern: return $MODEL.objects.raw(..., request.$W[...], ...)
    - pattern: $MODEL.objects.raw(..., $S.format(..., request.$W, ...), ...)
    - pattern: $MODEL.objects.raw(..., $S % request.$W, ...)
    - pattern: $MODEL.objects.raw(..., f"...{request.$W}...", ...)
    - pattern: $MODEL.objects.raw(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.raw(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.raw(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.raw(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.raw(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        $MODEL.objects.raw(..., $INTERM, ...)
    - pattern: $A = $MODEL.objects.raw(..., request.$W, ...)
    - pattern: return $MODEL.objects.raw(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $MODEL.objects.raw($STR % (..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.raw($INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.raw($INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.raw($INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % (..., $DATA, ...)
        ...
        $MODEL.objects.raw($INTERM, ...)
- id: python.django.security.injection.ssrf.ssrf-injection-requests.ssrf-injection-requests
  message: |
    Data from request object is passed to a new server-side request.
    This could lead to a server-side request forgery (SSRF). To mitigate,
    ensure that schemes and hosts are validated against an allowlist,
    do not forward the response to the user, and ensure proper authentication
    and transport-layer security in the proxied request.
    See https://owasp.org/www-community/attacks/Server_Side_Request_Forgery to
    learn more about SSRF vulnerabilities.
  metadata:
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.ssrf.ssrf-injection-requests.ssrf-injection-requests
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: requests.$METHOD(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: requests.$METHOD(..., $S % request.$W.get(...), ...)
    - pattern: requests.$METHOD(..., f"...{request.$W.get(...)}...", ...)
    - pattern: requests.$METHOD(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        requests.$METHOD(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        requests.$METHOD(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        requests.$METHOD(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        requests.$METHOD(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        requests.$METHOD(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: $A = requests.$METHOD(..., request.$W.get(...), ...)
    - pattern: return requests.$METHOD(..., request.$W.get(...), ...)
    - pattern: requests.$METHOD(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: requests.$METHOD(..., $S % request.$W(...), ...)
    - pattern: requests.$METHOD(..., f"...{request.$W(...)}...", ...)
    - pattern: requests.$METHOD(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        requests.$METHOD(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        requests.$METHOD(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        requests.$METHOD(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        requests.$METHOD(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        requests.$METHOD(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: $A = requests.$METHOD(..., request.$W(...), ...)
    - pattern: return requests.$METHOD(..., request.$W(...), ...)
    - pattern: requests.$METHOD(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: requests.$METHOD(..., $S % request.$W[...], ...)
    - pattern: requests.$METHOD(..., f"...{request.$W[...]}...", ...)
    - pattern: requests.$METHOD(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        requests.$METHOD(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        requests.$METHOD(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        requests.$METHOD(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        requests.$METHOD(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        requests.$METHOD(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: $A = requests.$METHOD(..., request.$W[...], ...)
    - pattern: return requests.$METHOD(..., request.$W[...], ...)
    - pattern: requests.$METHOD(..., $S.format(..., request.$W, ...), ...)
    - pattern: requests.$METHOD(..., $S % request.$W, ...)
    - pattern: requests.$METHOD(..., f"...{request.$W}...", ...)
    - pattern: requests.$METHOD(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        requests.$METHOD(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        requests.$METHOD(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        requests.$METHOD(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        requests.$METHOD(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        requests.$METHOD(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        requests.$METHOD(..., $INTERM, ...)
    - pattern: $A = requests.$METHOD(..., request.$W, ...)
    - pattern: return requests.$METHOD(..., request.$W, ...)
- id: python.django.security.injection.ssrf.ssrf-injection-urllib.ssrf-injection-urllib
  message: |
    Data from request object is passed to a new server-side request.
    This could lead to a server-side request forgery (SSRF). To mitigate,
    ensure that schemes and hosts are validated against an allowlist,
    do not forward the response to the user, and ensure proper authentication
    and transport-layer security in the proxied request.
    See https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
    to learn more about SSRF vulnerabilities.
  metadata:
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.injection.ssrf.ssrf-injection-urllib.ssrf-injection-urllib
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: urllib.request.urlopen(..., $S.format(..., request.$W.get(...), ...),
        ...)
    - pattern: urllib.request.urlopen(..., $S % request.$W.get(...), ...)
    - pattern: urllib.request.urlopen(..., f"...{request.$W.get(...)}...", ...)
    - pattern: urllib.request.urlopen(..., request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        urllib.request.urlopen(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        urllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        urllib.request.urlopen(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        urllib.request.urlopen(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        urllib.request.urlopen(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: $A = urllib.request.urlopen(..., request.$W.get(...), ...)
    - pattern: return urllib.request.urlopen(..., request.$W.get(...), ...)
    - pattern: urllib.request.urlopen(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: urllib.request.urlopen(..., $S % request.$W(...), ...)
    - pattern: urllib.request.urlopen(..., f"...{request.$W(...)}...", ...)
    - pattern: urllib.request.urlopen(..., request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        urllib.request.urlopen(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        urllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        urllib.request.urlopen(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        urllib.request.urlopen(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        urllib.request.urlopen(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: $A = urllib.request.urlopen(..., request.$W(...), ...)
    - pattern: return urllib.request.urlopen(..., request.$W(...), ...)
    - pattern: urllib.request.urlopen(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: urllib.request.urlopen(..., $S % request.$W[...], ...)
    - pattern: urllib.request.urlopen(..., f"...{request.$W[...]}...", ...)
    - pattern: urllib.request.urlopen(..., request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        urllib.request.urlopen(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        urllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        urllib.request.urlopen(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        urllib.request.urlopen(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        urllib.request.urlopen(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: $A = urllib.request.urlopen(..., request.$W[...], ...)
    - pattern: return urllib.request.urlopen(..., request.$W[...], ...)
    - pattern: urllib.request.urlopen(..., $S.format(..., request.$W, ...), ...)
    - pattern: urllib.request.urlopen(..., $S % request.$W, ...)
    - pattern: urllib.request.urlopen(..., f"...{request.$W}...", ...)
    - pattern: urllib.request.urlopen(..., request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        urllib.request.urlopen(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        urllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        urllib.request.urlopen(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        urllib.request.urlopen(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        urllib.request.urlopen(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        urllib.request.urlopen(..., $INTERM, ...)
    - pattern: $A = urllib.request.urlopen(..., request.$W, ...)
    - pattern: return urllib.request.urlopen(..., request.$W, ...)
- id: python.django.security.passwords.password-empty-string.password-empty-string
  message: |
    '$VAR' is the empty string and is being used to set the password on '$MODEL'.
    If you meant to set an unusable password, set the password to None or call
    'set_unusable_password()'.
  metadata:
    cwe: 'CWE-521: Weak Password Requirements'
    owasp: 'A2: Broken Authentication'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.passwords.password-empty-string.password-empty-string
  patterns:
  - pattern-either:
    - pattern: |
        $MODEL.set_password($EMPTY)
        ...
        $MODEL.save()
    - pattern: |
        $VAR = $EMPTY
        ...
        $MODEL.set_password($VAR)
        ...
        $MODEL.save()
  - metavariable-regex:
      metavariable: $EMPTY
      regex: (\'\'|\"\")
  languages:
  - python
  severity: ERROR
- id: python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
  message: |
    '$VAR' is using the empty string as its default and is being used to set
    the password on '$MODEL'. If you meant to set an unusable password, set
    the default value to 'None' or call 'set_unusable_password()'.
  metadata:
    cwe: 'CWE-521: Weak Password Requirements'
    owasp: 'A2: Broken Authentication'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password
    category: security
    technology:
    - django
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
  fix-regex:
    regex: (def.*|request.*)(""|'')
    replacement: \1None
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: |
      $VAR = request.$W.get($X, "")
      ...
      $MODEL.set_password($VAR)
      ...
      $MODEL.save(...)
  - pattern: |
      def $F(..., $VAR="", ...):
        ...
        $MODEL.set_password($VAR)
- id: python.flask.security.audit.app-run-param-config.avoid_app_run_with_bad_host
  message: Running flask app with host 0.0.0.0 could expose the server publicly.
  metadata:
    cwe: 'CWE-668: Exposure of Resource to Wrong Sphere'
    owasp: 'A6: Security Misconfiguration'
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.app-run-param-config.avoid_app_run_with_bad_host
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: app.run(..., host="0.0.0.0", ...)
  - pattern: app.run(..., "0.0.0.0", ...)
- id: python.flask.security.audit.app-run-security-config.avoid_using_app_run_directly
  patterns:
  - pattern-not-inside: |
      if __name__ == '__main__':
        ...
  - pattern-not-inside: |
      def $X(...):
        ...
  - pattern: app.run(...)
  message: top-level app.run(...) is ignored by flask. Consider putting app.run(...)
    behind a guard, like inside a function
  metadata:
    cwe: 'CWE-668: Exposure of Resource to Wrong Sphere'
    owasp: 'A6: Security Misconfiguration'
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.app-run-security-config.avoid_using_app_run_directly
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.debug-enabled.debug-enabled
  patterns:
  - pattern-inside: |
      import flask
      ...
  - pattern: $APP.run(..., debug=True, ...)
  message: |
    Detected Flask app with debug=True. Do not deploy to production with this flag enabled
    as it will leak sensitive information. Instead, consider using Flask configuration
    variables or setting 'debug' using system environment variables.
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://labs.detectify.com/2015/10/02/how-patreon-got-hacked-publicly-exposed-werkzeug-debugger/
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.debug-enabled.debug-enabled
  severity: WARNING
  languages:
  - python
- id: python.flask.security.audit.directly-returned-format-string.directly-returned-format-string
  message: |
    Detected Flask route directly returning a formatted string. This
    is subject to cross-site scripting if user input can reach the string.
    Consider using the template engine instead and rendering pages with
    'render_template()'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.directly-returned-format-string.directly-returned-format-string
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      @$APP.route(...)
      def $FUNC(...):
        ...
  - pattern-not-inside: return "..."
  - pattern-either:
    - pattern: return "...".format(...)
    - pattern: return "..." % ...
    - pattern: return "..." + ...
    - pattern: return ... + "..."
    - pattern: return f"...{...}..."
    - patterns:
      - pattern: return $X
      - pattern-either:
        - pattern-inside: |
            $X = "...".format(...)
            ...
        - pattern-inside: |
            $X = "..." % ...
            ...
        - pattern-inside: |
            $X = "..." + ...
            ...
        - pattern-inside: |
            $X = ... + "..."
            ...
        - pattern-inside: |
            $X = f"...{...}..."
            ...
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_TESTING
  pattern-either:
  - pattern: $M.config['TESTING'] = True
  - pattern: $M.config['TESTING'] = False
  - pattern: $M.update(TESTING=True, ...)
  - pattern: $M.update(TESTING=False, ...)
  message: Hardcoded variable `TESTING` detected. Use environment variables or config
    files instead
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_TESTING
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_SECRET_KEY
  pattern-either:
  - pattern: $M.update(SECRET_KEY="=~/.*/")
  - pattern: $M.config['SECRET_KEY'] = "=~/.*/"
  message: Hardcoded variable `SECRET_KEY` detected. Use environment variables or
    config files instead
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_SECRET_KEY
  languages:
  - python
  severity: ERROR
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_ENV
  pattern-either:
  - pattern: $M.update(ENV="=~/^development|production$/")
  - pattern: $M.config['ENV'] = "=~/^development|production$/"
  message: Hardcoded variable `ENV` detected. Set this by using FLASK_ENV environment
    variable
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_ENV
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_DEBUG
  pattern-either:
  - pattern: $M.update(DEBUG=True)
  - pattern: $M.update(DEBUG=False)
  - pattern: $M.config['DEBUG'] = True
  - pattern: $M.config['DEBUG'] = False
  message: Hardcoded variable `DEBUG` detected. Set this by using FLASK_DEBUG environment
    variable
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_DEBUG
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.render-template-string.render-template-string
  pattern: flask.render_template_string(...)
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.render-template-string.render-template-string
  message: Found a template created with string formatting. This is susceptible to
    server-side template injection and cross-site scripting attacks.
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.secure-set-cookie.secure-set-cookie
  patterns:
  - pattern-either:
    - pattern-inside: |
        $RESP = flask.make_response(...)
        ...
    - pattern-inside: |
        $RESP = flask.Response(...)
        ...
  - pattern-not: $RESPONSE.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)
  - pattern-not: $RESPONSE.set_cookie(..., **$A)
  - pattern: $RESPONSE.set_cookie(...)
  message: |
    Flask cookies should be handled securely by setting secure=True, httponly=True, and samesite='Lax' in
    response.set_cookie(...). If your situation calls for different settings, explicitly disable the setting.
    If you want to send the cookie over http, set secure=False.  If you want to let client-side JavaScript
    read the cookie, set httponly=False. If you want to attach cookies to requests for external sites,
    set samesite=None.
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://blog.r2c.dev/2020/bento-check-keeping-cookies-safe-in-flask/
    - https://bento.dev/checks/flask/secure-set-cookie/
    - https://flask.palletsprojects.com/en/1.1.x/security/#set-cookie-options
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.secure-set-cookie.secure-set-cookie
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.wtf-csrf-disabled.flask-wtf-csrf-disabled
  message: |
    Setting 'WTF_CSRF_ENABLED' to 'False' explicitly disables CSRF protection.
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://flask-wtf.readthedocs.io/en/stable/csrf.html
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.audit.wtf-csrf-disabled.flask-wtf-csrf-disabled
  severity: WARNING
  languages:
  - python
  pattern: $APP.config['WTF_CSRF_ENABLED'] = False
- id: python.flask.security.dangerous-template-string.dangerous-template-string
  message: |
    Found a template created with string formatting.
    This is susceptible to server-side template injection
    and cross-site scripting attacks.
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
    - https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.dangerous-template-string.dangerous-template-string
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: |
      $V = "...".format(...)
      ...
      flask.render_template_string($V, ...)
  - pattern: |
      $V = "...".format(...)
      ...
      return flask.render_template_string($V, ...), $MORE
  - pattern: |
      $V = "..." % $S
      ...
      flask.render_template_string($V, ...)
  - pattern: |
      $V = "..." % $S
      ...
      return flask.render_template_string($V, ...), $MORE
  - pattern: |
      $V = "..."
      ...
      $V += $O
      ...
      flask.render_template_string($V, ...)
  - pattern: |
      $V = "..."
      ...
      $V += $O
      ...
      return flask.render_template_string($V, ...), $MORE
  - pattern: |
      $V = f"...{$X}..."
      ...
      flask.render_template_string($V, ...)
  - pattern: |
      $V = f"...{$X}..."
      ...
      return flask.render_template_string($V, ...), $CODE
- id: python.flask.security.injection.os-system-injection.os-system-injection
  languages:
  - python
  severity: ERROR
  message: User data detected in os.system. This could be vulnerable to a command
    injection and should be avoided. If this must be done, use the 'subprocess' module
    instead and pass the arguments as a list.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Command_Injection
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.injection.os-system-injection.os-system-injection
  pattern-either:
  - patterns:
    - pattern: os.system(...)
    - pattern-either:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            os.system(..., <... $ROUTEVAR ...>, ...)
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            $INTERM = <... $ROUTEVAR ...>
            ...
            os.system(..., <... $INTERM ...>, ...)
  - pattern: os.system(..., <... flask.request.$W.get(...) ...>, ...)
  - pattern: os.system(..., <... flask.request.$W[...] ...>, ...)
  - pattern: os.system(..., <... flask.request.$W(...) ...>, ...)
  - pattern: os.system(..., <... flask.request.$W ...>, ...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W.get(...) ...>
        ...
        os.system(<... $INTERM ...>)
    - pattern: os.system(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W[...] ...>
        ...
        os.system(<... $INTERM ...>)
    - pattern: os.system(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W(...) ...>
        ...
        os.system(<... $INTERM ...>)
    - pattern: os.system(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W ...>
        ...
        os.system(<... $INTERM ...>)
    - pattern: os.system(...)
- id: python.flask.security.injection.path-traversal-open.path-traversal-open
  languages:
  - python
  severity: ERROR
  message: Found request data in a call to 'open'. Ensure the request data is validated
    or sanitized, otherwise it could result in path traversal attacks.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.injection.path-traversal-open.path-traversal-open
  pattern-either:
  - patterns:
    - pattern: open(...)
    - pattern-either:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            open(..., <... $ROUTEVAR ...>, ...)
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            with open(..., <... $ROUTEVAR ...>, ...) as $FD:
              ...
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            $INTERM = <... $ROUTEVAR ...>
            ...
            open(..., <... $INTERM ...>, ...)
  - pattern: open(..., <... flask.request.$W.get(...) ...>, ...)
  - pattern: open(..., <... flask.request.$W[...] ...>, ...)
  - pattern: open(..., <... flask.request.$W(...) ...>, ...)
  - pattern: open(..., <... flask.request.$W ...>, ...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W.get(...) ...>
        ...
        open(<... $INTERM ...>, ...)
    - pattern: open(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W[...] ...>
        ...
        open(<... $INTERM ...>, ...)
    - pattern: open(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W(...) ...>
        ...
        open(<... $INTERM ...>, ...)
    - pattern: open(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W ...>
        ...
        open(<... $INTERM ...>, ...)
    - pattern: open(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W.get(...) ...>
        ...
        with open(<... $INTERM ...>, ...) as $F:
          ...
    - pattern: open(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W[...] ...>
        ...
        with open(<... $INTERM ...>, ...) as $F:
          ...
    - pattern: open(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W(...) ...>
        ...
        with open(<... $INTERM ...>, ...) as $F:
          ...
    - pattern: open(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W ...>
        ...
        with open(<... $INTERM ...>, ...) as $F:
          ...
    - pattern: open(...)
- id: python.flask.security.injection.ssrf-requests.ssrf-requests
  languages:
  - python
  severity: ERROR
  message: Data from request object is passed to a new server-side request. This could
    lead to a server-side request forgery (SSRF). To mitigate, ensure that schemes
    and hosts are validated against an allowlist, do not forward the response to the
    user, and ensure proper authentication and transport-layer security in the proxied
    request.
  metadata:
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.injection.ssrf-requests.ssrf-requests
  pattern-either:
  - patterns:
    - pattern: requests.$FUNC(...)
    - pattern-either:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $ROUTE_FUNC(..., $ROUTEVAR, ...):
            ...
            requests.$FUNC(..., <... $ROUTEVAR ...>, ...)
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $ROUTE_FUNC(..., $ROUTEVAR, ...):
            ...
            $INTERM = <... $ROUTEVAR ...>
            ...
            requests.$FUNC(..., <... $INTERM ...>, ...)
  - pattern: requests.$FUNC(..., <... flask.request.$W.get(...) ...>, ...)
  - pattern: requests.$FUNC(..., <... flask.request.$W[...] ...>, ...)
  - pattern: requests.$FUNC(..., <... flask.request.$W(...) ...>, ...)
  - pattern: requests.$FUNC(..., <... flask.request.$W ...>, ...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W.get(...) ...>
        ...
        requests.$FUNC(<... $INTERM ...>, ...)
    - pattern: requests.$FUNC(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W[...] ...>
        ...
        requests.$FUNC(<... $INTERM ...>, ...)
    - pattern: requests.$FUNC(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W(...) ...>
        ...
        requests.$FUNC(<... $INTERM ...>, ...)
    - pattern: requests.$FUNC(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W ...>
        ...
        requests.$FUNC(<... $INTERM ...>, ...)
    - pattern: requests.$FUNC(...)
- id: python.flask.security.injection.user-eval.eval-injection
  languages:
  - python
  severity: ERROR
  message: Detected user data flowing into eval. This is code injection and should
    be avoided.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.injection.user-eval.eval-injection
  pattern-either:
  - patterns:
    - pattern: eval(...)
    - pattern-either:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            eval(..., <... $ROUTEVAR ...>, ...)
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            $INTERM = <... $ROUTEVAR ...>
            ...
            eval(..., <... $INTERM ...>, ...)
  - pattern: eval(..., <... flask.request.$W.get(...) ...>, ...)
  - pattern: eval(..., <... flask.request.$W[...] ...>, ...)
  - pattern: eval(..., <... flask.request.$W(...) ...>, ...)
  - pattern: eval(..., <... flask.request.$W ...>, ...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W.get(...) ...>
        ...
        eval(..., <... $INTERM ...>, ...)
    - pattern: eval(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W[...] ...>
        ...
        eval(..., <... $INTERM ...>, ...)
    - pattern: eval(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W(...) ...>
        ...
        eval(..., <... $INTERM ...>, ...)
    - pattern: eval(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W ...>
        ...
        eval(..., <... $INTERM ...>, ...)
    - pattern: eval(...)
- id: python.flask.security.injection.user-exec.exec-injection
  languages:
  - python
  severity: ERROR
  message: Detected user data flowing into exec. This is code injection and should
    be avoided.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/exec_really_is_dangerous.html
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.injection.user-exec.exec-injection
  pattern-either:
  - patterns:
    - pattern: exec(...)
    - pattern-either:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            exec(..., <... $ROUTEVAR ...>, ...)
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
            $INTERM = <... $ROUTEVAR ...>
            ...
            exec(..., <... $INTERM ...>, ...)
  - pattern: exec(..., <... flask.request.$W.get(...) ...>, ...)
  - pattern: exec(..., <... flask.request.$W[...] ...>, ...)
  - pattern: exec(..., <... flask.request.$W(...) ...>, ...)
  - pattern: exec(..., <... flask.request.$W ...>, ...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W.get(...) ...>
        ...
        exec(..., <... $INTERM ...>, ...)
    - pattern: exec(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W[...] ...>
        ...
        exec(..., <... $INTERM ...>, ...)
    - pattern: exec(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W(...) ...>
        ...
        exec(..., <... $INTERM ...>, ...)
    - pattern: exec(...)
  - patterns:
    - pattern-inside: |
        $INTERM = <... flask.request.$W ...>
        ...
        exec(..., <... $INTERM ...>, ...)
    - pattern: exec(...)
- id: python.flask.security.insecure-deserialization.insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.insecure-deserialization.insecure-deserialization
  message: |
    Detected the use of an insecure deserizliation library in a Flask route. These libraries
    are prone to code execution vulnerabilities. Ensure user data does not enter this function.
    To fix this, try to avoid serializing whole objects. Consider instead using a serializer
    such as JSON.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      @app.route(...)
      def $X(...):
        ...
  - pattern-not: $MODULE.$FUNC("...")
  - pattern-not: $MODULE.$FUNC(open("...", ...))
  - pattern-either:
    - pattern: pickle.$FUNC(...)
    - pattern: _pickle.$FUNC(...)
    - pattern: cPickle.$FUNC(...)
    - pattern: dill.$FUNC(...)
    - pattern: shelve.$FUNC(...)
    - pattern: yaml.load(...)
- id: python.flask.security.open-redirect.open-redirect
  patterns:
  - pattern-inside: |
      @$APP.route(...)
      def $X():
        ...
  - pattern-not-inside: |
      ...
      if <... werkzeug.urls.url_parse($V) ...>:
        ...
  - pattern-either:
    - pattern: flask.redirect(<... flask.request.$W.get(...) ...>, ...)
    - pattern: flask.redirect(<... flask.request.$W[...] ...>, ...)
    - pattern: flask.redirect(<... flask.request.$W(...) ...>, ...)
    - pattern: flask.redirect(<... flask.request.$W ...>, ...)
    - pattern: |
        $V = flask.request.$W.get(...)
        ...
        flask.redirect(<... $V ...>, ...)
    - pattern: |
        $V = flask.request.$W[...]
        ...
        flask.redirect(<... $V ...>, ...)
    - pattern: |
        $V = flask.request.$W(...)
        ...
        flask.redirect(<... $V ...>, ...)
    - pattern: |
        $V = flask.request.$W
        ...
        flask.redirect(<... $V ...>, ...)
  message: |
    Data from request is passed to redirect().
    This is an open redirect and could be exploited.
    Consider using 'url_for()' to generate links to known locations.
    If you must use a URL to unknown pages, consider using 'urlparse()'
    or similar and checking if the 'netloc' property is the same as
    your site's host name. See the references for more information.
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    owasp: 'A1: Injection'
    references:
    - https://flask-login.readthedocs.io/en/latest/#login-example
    - https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#dangerous-url-redirect-example-1
    - https://docs.python.org/3/library/urllib.parse.html#url-parsing
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.open-redirect.open-redirect
  languages:
  - python
  severity: ERROR
- id: python.flask.security.secure-static-file-serve.avoid_send_file_without_path_sanitization
  patterns:
  - pattern-inside: |
      @app.route(...)
      def $X(filename):
        ...
  - pattern: flask.send_file(filename, ...)
  message: Looks like `filename` could flow to `flask.send_file()` function. Make
    sure to properly sanitize filename or use `flask.send_from_directory`
  metadata:
    cwe: 'CWE-73: External Control of File Name or Path'
    owasp: 'A1: Injection'
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.secure-static-file-serve.avoid_send_file_without_path_sanitization
  languages:
  - python
  severity: WARNING
- id: python.flask.security.unescaped-template-extension.unescaped-template-extension
  message: |
    Flask does not automatically escape Jinja templates unless they have
    .html, .htm, .xml, or .xhtml extensions. This could lead to XSS attacks.
    Use .html, .htm, .xml, or .xhtml for your template extensions.
    See https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
    for more information.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    source-rule-url: https://pypi.org/project/flake8-flask/
    references:
    - https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
    - https://blog.r2c.dev/2020/bento-check-unescaped-template-extensions-in-flask/
    - https://bento.dev/checks/flask/unescaped-file-extension/
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.unescaped-template-extension.unescaped-template-extension
  patterns:
  - pattern-not: flask.render_template("=~/.+\.html$/", ...)
  - pattern-not: flask.render_template("=~/.+\.xml$/", ...)
  - pattern-not: flask.render_template("=~/.+\.htm$/", ...)
  - pattern-not: flask.render_template("=~/.+\.xhtml$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.html$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.xml$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.htm$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.xhtml$/", ...)
  - pattern-not: flask.render_template("=~/.+\.html$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.xml$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.htm$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.xhtml$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.html$/".format(...), ...)
  - pattern-not: flask.render_template("=~/.+\.xml$/".format(...), ...)
  - pattern-not: flask.render_template("=~/.+\.htm$/".format(...), ...)
  - pattern-not: flask.render_template("=~/.+\.xhtml$/".format(...), ...)
  - pattern-not: flask.render_template($TEMPLATE)
  - pattern-either:
    - pattern: flask.render_template("...", ...)
    - pattern: flask.render_template($X + "...", ...)
    - pattern: flask.render_template("..." % $Y, ...)
    - pattern: flask.render_template("...".format(...), ...)
  languages:
  - python
  severity: WARNING
- id: python.flask.security.unsanitized-input.response-contains-unsanitized-input
  message: |
    Flask response reflects unsanitized user input. This could lead to a
    cross-site scripting vulnerability (https://owasp.org/www-community/attacks/xss/)
    in which an attacker causes arbitrary code to be executed in the user's browser.
    To prevent, please sanitize the user input, e.g. by rendering the response
    in a Jinja2 template (see considerations in https://flask.palletsprojects.com/en/1.0.x/security/).
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.0.x/security/
    - https://owasp.org/www-community/attacks/xss/
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.unsanitized-input.response-contains-unsanitized-input
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: |
      $X = flask.request.args.get(...)
      ...
      flask.make_response("...".format($X))
  - pattern: |
      $X = flask.request.args.get(...)
      ...
      flask.make_response(f"...{$X}...")
  - pattern: |
      $X = flask.request.args.get(...)
      ...
      flask.make_response(f"...{$X}")
  - pattern: |
      $X = flask.request.args.get(...)
      ...
      flask.make_response(f"{$X}...")
- id: python.flask.security.xss.audit.direct-use-of-jinja2.direct-use-of-jinja2
  message: |
    Detected direct use of jinja2. If not done properly,
    this may bypass HTML escaping which opens up the application to
    cross-site scripting (XSS) vulnerabilities. Prefer using the Flask
    method 'render_template()' and templates with a '.html' extension
    in order to prevent XSS.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://jinja.palletsprojects.com/en/2.11.x/api/#basics
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.xss.audit.direct-use-of-jinja2.direct-use-of-jinja2
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: jinja2.Environment(...)
  - pattern: jinja2.Template.render(...)
  - patterns:
    - pattern-inside: |
        $TEMPLATE = $ENV.get_template(...)
        ...
    - pattern: $TEMPLATE.render(...)
  - patterns:
    - pattern-inside: |
        $TEMPLATE = jinja2.Template(...)
        ...
    - pattern: $TEMPLATE.render(...)
- id: python.flask.security.xss.audit.explicit-unescape-with-markup.explicit-unescape-with-markup
  message: |
    Detected explicitly unescaped content using 'Markup()'. This permits
    the unescaped data to include unescaped HTML which could result in
    cross-site scripting. Ensure this data is not externally controlled,
    or consider rewriting to not use 'Markup()'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://tedboy.github.io/flask/generated/generated/flask.Markup.html
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.xss.audit.explicit-unescape-with-markup.explicit-unescape-with-markup
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: flask.Markup(...)
  - pattern: flask.Markup.unescape(...)
  - pattern: markupsafe.Markup(...)
  - pattern: $MARKUPOBJ.unescape()
- id: python.flask.security.xss.audit.template-autoescape-off.template-autoescape-off
  message: Detected a segment of a Flask template where autoescaping is explicitly
    disabled with '{% autoescape off %}'. This allows rendering of raw HTML in this
    segment. Ensure no user data is rendered here, otherwise this is a cross-site
    scripting (XSS) vulnerability, or turn autoescape on.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/templating/#controlling-autoescaping
    - https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.xss.audit.template-autoescape-off.template-autoescape-off
  languages:
  - regex
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{%\s*autoescape\s+false\s*%}'
- id: python.flask.security.xss.audit.template-href-var.template-href-var
  message: Detected a template variable used in an anchor tag with the 'href' attribute.
    This allows a malicious actor to input the 'javascript:' URI and is subject to
    cross- site scripting (XSS) attacks. Use 'url_for()' to safely generate a URL.
    You may also consider setting the Content Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
    - https://content-security-policy.com/
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.xss.audit.template-href-var.template-href-var
  languages:
  - generic
  paths:
    include:
    - '*.html'
  severity: WARNING
  patterns:
  - pattern-inside: <a ...>
  - pattern-either:
    - pattern: href = {{ ... }}
    - pattern: href = "{{ ... }}"
    - pattern: href = '{{ ... }}'
  - pattern-not-inside: href = {{ url_for(...) ... }}
  - pattern-not-inside: href = "{{ url_for(...) ... }}"
  - pattern-not-inside: href = '{{ url_for(...) ... }}'
- id: python.flask.security.xss.audit.template-unescaped-with-safe.template-unescaped-with-safe
  message: Detected a segment of a Flask template where autoescaping is explicitly
    disabled with '| safe' filter. This allows rendering of raw HTML in this segment.
    Ensure no user data is rendered here, otherwise this is a cross-site scripting
    (XSS) vulnerability.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.xss.audit.template-unescaped-with-safe.template-unescaped-with-safe
  languages:
  - regex
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{{.*?\|\s*safe(\s*}})?'
- id: python.flask.security.xss.audit.template-unquoted-attribute-var.template-unquoted-attribute-var
  message: 'Detected a unquoted template variable as an attribute. If unquoted, a
    malicious actor could inject custom JavaScript handlers. To fix this, add quotes
    around the template expression, like this: "{{ expr }}".'
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
    category: security
    technology:
    - flask
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.flask.security.xss.audit.template-unquoted-attribute-var.template-unquoted-attribute-var
  languages:
  - generic
  paths:
    include:
    - '*.html'
  severity: WARNING
  patterns:
  - pattern-inside: <$TAG ...>
  - pattern-not-inside: ="..."
  - pattern-not-inside: ='...'
  - pattern: '{{ ... }}'
  fix-regex:
    regex: '{{(.*?)}}'
    replacement: '"{{\1}}"'
- id: python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
  patterns:
  - pattern-not: jinja2.Environment(..., autoescape=True, ...)
  - pattern-not: jinja2.Environment(..., autoescape=jinja2.select_autoescape(...),
      ...)
  - pattern: jinja2.Environment(...)
  fix-regex:
    regex: (.*)\)
    replacement: \1, autoescape=True)
  message: Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape
    by default. This is dangerous if you are rendering to a browser because this allows
    for cross-site scripting (XSS) attacks. If you are in a web context, enable autoescaping
    by setting 'autoescape=True.' You may also consider using 'jinja2.select_autoescape()'
    to only enable automatic escaping for certain file extensions.
  metadata:
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://jinja.palletsprojects.com/en/2.11.x/api/#basics
    category: security
    technology:
    - jinja2
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
  languages:
  - python
  severity: WARNING
- id: python.jwt.security.audit.jwt-exposed-data.jwt-python-exposed-data
  message: |
    The object is passed strictly to jwt.encode(...)
    Make sure that sensitive information is not exposed through JWT token payload.
  severity: WARNING
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.jwt.security.audit.jwt-exposed-data.jwt-python-exposed-data
  languages:
  - python
  patterns:
  - pattern-inside: |
      def $FUNC(...,$INPUT,...):
        ...
  - pattern: jwt.encode($INPUT,...)
- id: python.jwt.security.jwt-exposed-credentials.jwt-python-exposed-credentials
  languages:
  - python
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.jwt.security.jwt-exposed-credentials.jwt-python-exposed-credentials
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  pattern-either:
  - pattern: |
      jwt.encode({...,"password":$P,...},...)
  - pattern: |
      $PAYLOAD = {...,"password":$P,...}
      ...
      jwt.encode($PAYLOAD,...)
  severity: ERROR
- id: python.jwt.security.jwt-hardcode.jwt-python-hardcoded-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.jwt.security.jwt-hardcode.jwt-python-hardcoded-secret
  pattern-either:
  - pattern: |
      jwt.encode($X, "...", ...)
  - pattern: |
      $SECRET = "..."
      ...
      jwt.encode($X, $SECRET, ...)
  languages:
  - python
  severity: ERROR
- id: python.jwt.security.jwt-none-alg.jwt-python-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.jwt.security.jwt-none-alg.jwt-python-none-alg
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: |
      jwt.encode(...,algorithm="none",...)
  - pattern: jwt.decode(...,algorithms=[...,"none",...],...)
- id: python.jwt.security.unverified-jwt-decode.unverified-jwt-decode
  pattern: |
    jwt.decode(..., verify=False, ...)
  message: |
    Detected JWT token decoded with 'verify=False'. This bypasses any integrity
    checks for the token which means the token could be tampered with by
    malicious actors. Ensure that the JWT token is verified.
  metadata:
    owasp: 'A2: Broken Authentication'
    cwe: 'CWE-287: Improper Authentication'
    references:
    - https://github.com/we45/Vulnerable-Flask-App/blob/752ee16087c0bfb79073f68802d907569a1f0df7/app/app.py#L96
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.jwt.security.unverified-jwt-decode.unverified-jwt-decode
  fix-regex:
    regex: (verify\s*=\s*)False
    replacement: \1True
  severity: ERROR
  languages:
  - python
- id: python.lang.security.audit.conn_recv.multiprocessing-recv
  languages:
  - python
  message: 'The Connection.recv() method automatically unpickles the data it receives,
    which can be a security risk unless you can trust the process which sent the message.
    Therefore, unless the connection object was produced using Pipe() you should only
    use the recv() and send() methods after performing some sort of authentication.
    See more dettails: https://docs.python.org/3/library/multiprocessing.html?highlight=security#multiprocessing.connection.Connection'
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.python.org/3/library/multiprocessing.html?highlight=security#multiprocessing.connection.Connection
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.conn_recv.multiprocessing-recv
  pattern-either:
  - pattern: multiprocessing.connection.Connection.recv(...)
  - pattern: multiprocessing.connection.Client.recv(...)
  - pattern: |
      $C = multiprocessing.connection.Client(...)
      ...
      $C.recv(...)
  severity: WARNING
- id: python.lang.security.audit.dangerous-spawn-process.dangerous-spawn-process
  message: |
    Found dynamic content when spawning a process. This is dangerous if external
    data can reach this function call because it allows a malicious actor to
    execute commands. Ensure no external data reaches here.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.3.8 OS Command Injection
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.dangerous-spawn-process.dangerous-spawn-process
  languages:
  - python
  severity: WARNING
  pattern-either:
  - patterns:
    - pattern-not: os.$METHOD($MODE, "...", ...)
    - pattern: os.$METHOD(...)
    - metavariable-regex:
        metavariable: $METHOD
        regex: (spawnl|spawnle|spawnlp|spawnlpe|spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp|startfile)
  - patterns:
    - pattern-not: os.$METHOD($MODE, "...", ["...","...",...], ...)
    - pattern: os.$METHOD($MODE, $BASH, ["-c",$CMD,...],...)
    - metavariable-regex:
        metavariable: $METHOD
        regex: (spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp)
    - metavariable-regex:
        metavariable: $BASH
        regex: (.*)(sh|bash|ksh|csh|tcsh|zsh)
  - patterns:
    - pattern-not: os.$METHOD($MODE, "...", "...", "...", ...)
    - pattern: os.$METHOD($MODE, $BASH, "-c", $CMD,...)
    - metavariable-regex:
        metavariable: $METHOD
        regex: (spawnl|spawnle|spawnlp|spawnlpe)
    - metavariable-regex:
        metavariable: $BASH
        regex: (.*)(sh|bash|ksh|csh|tcsh|zsh)
- id: python.lang.security.audit.dangerous-subprocess-use.dangerous-subprocess-use
  pattern-either:
  - patterns:
    - pattern-not: subprocess.$FUNC("...", ...)
    - pattern-not: subprocess.$FUNC(["...",...], ...)
    - pattern-not: subprocess.CalledProcessError(...)
    - pattern-not: subprocess.SubprocessError(...)
    - pattern: subprocess.$FUNC(...)
  - patterns:
    - pattern: subprocess.$FUNC("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",...)
    - pattern-not: subprocess.$FUNC("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c","...",...)
  - patterns:
    - pattern: subprocess.$FUNC(["=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",...],...)
    - pattern-not: subprocess.$FUNC(["=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c","...",...],...)
  - patterns:
    - pattern: subprocess.$FUNC("=~/(python)/",...)
    - pattern-not: subprocess.$FUNC("=~/(python)/","...",...)
  - patterns:
    - pattern: subprocess.$FUNC(["=~/(python)/",...],...)
    - pattern-not: subprocess.$FUNC(["=~/(python)/","...",...],...)
  message: |
    Detected subprocess function '$FUNC' without a static string. If this data can be
    controlled by a malicious actor, it may be an instance of command injection.
    Audit the use of this call to ensure it is not controllable by an external resource.
    You may consider using 'shlex.escape()'.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.3.8 OS Command Injection
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements
      version: '4'
    references:
    - https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess
    - https://docs.python.org/3/library/subprocess.html
    - https://docs.python.org/3/library/shlex.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.dangerous-subprocess-use.dangerous-subprocess-use
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.dangerous-system-call.dangerous-system-call
  patterns:
  - pattern-not: os.$W("...", ...)
  - pattern-either:
    - pattern: os.system(...)
    - pattern: os.popen(...)
    - pattern: os.popen2(...)
    - pattern: os.popen3(...)
    - pattern: os.popen4(...)
  message: Found dynamic content used in a system call. This is dangerous if external
    data can reach this function call because it allows a malicious actor to execute
    commands. Use the 'subprocess' module instead, which is easier to use without
    accidentally exposing a command injection vulnerability.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.2.4 Dyanmic Code Execution Features
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.dangerous-system-call.dangerous-system-call
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected
  patterns:
  - pattern-not: urllib.$W("...")
  - pattern-not: urllib.request.$W("...")
  - pattern-not: $OPENER.$W("...")
  - pattern-either:
    - pattern: urllib.urlopen(...)
    - pattern: urllib.request.urlopen(...)
    - pattern: urllib.urlretrieve(...)
    - pattern: urllib.request.urlretrieve(...)
    - patterns:
      - pattern-either:
        - pattern-inside: |
            $OPENER = urllib.URLopener(...)
            ...
        - pattern-inside: |
            $OPENER = urllib.request.URLopener(...)
            ...
        - pattern-inside: |
            $OPENER = urllib.FancyURLopener(...)
            ...
        - pattern-inside: |
            $OPENER = urllib.request.FancyURLopener(...)
            ...
      - pattern-either:
        - pattern: $OPENER.open(...)
        - pattern: $OPENER.retrieve(...)
  message: Detected a dynamic value being used with urllib. urllib supports 'file://'
    schemes, so a dynamic value controlled by a malicious actor may allow them to
    read arbitrary files. Audit uses of urllib calls to ensure user data cannot control
    the URLs, or consider using the 'requests' library instead.
  metadata:
    cwe: 'CWE-939: Improper Authorization in Handler for Custom URL Scheme'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/blacklists/calls.py#L163
    bandit-code: B310
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.2.4 Dyanmic Code Execution Features
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.eval-detected.eval-detected
  patterns:
  - pattern-not: eval("...")
  - pattern: eval(...)
  message: |
    Detected the use of eval(). eval() can be dangerous if used to evaluate
    dynamic content. If this content can be input from outside the program, this
    may be a code injection vulnerability. Ensure evaluated content is not definable
    by external sources.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.2.4 Dyanmic Code Execution Features
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.eval-detected.eval-detected
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.exec-detected.exec-detected
  patterns:
  - pattern-not: exec("...")
  - pattern: exec(...)
  message: |
    Detected the use of exec(). exec() can be dangerous if used to evaluate
    dynamic content. If this content can be input from outside the program, this
    may be a code injection vulnerability. Ensure evaluated content is not definable
    by external sources.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    asvs:
      section: 'V5: Validation, Sanitization and Encoding Verification Requirements'
      control_id: 5.2.4 Dyanmic Code Execution Features
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements
      version: '4'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.exec-detected.exec-detected
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.formatted-sql-query.formatted-sql-query
  message: |
    Detected possible formatted SQL query. Use parameterized queries instead.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    references:
    - https://stackoverflow.com/questions/775296/mysql-parameterized-queries
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.formatted-sql-query.formatted-sql-query
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: $DB.execute("..." % ...)
  - pattern: $DB.execute("...".format(...))
  - pattern: $DB.execute(f"...")
  - patterns:
    - pattern-either:
      - pattern-inside: |
          $SQL = "..." % ...
          ...
      - pattern-inside: |
          $SQL = "...".format(...)
          ...
      - pattern-inside: |
          $SQL = f"...{$X}..."
          ...
    - pattern: $DB.execute($SQL)
- id: python.lang.security.audit.ftplib.ftplib
  pattern: ftplib.$ANYTHING(...)
  message: |
    FTP does not encrypt communications by default. This can lead to sensitive
    data being exposed. Ensure use of FTP here does not expose sensitive data.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L265
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B321
    references:
    - https://docs.python.org/3/library/telnetlib.html
    category: security
    technology:
    - ftplib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.ftplib.ftplib
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.httpsconnection-detected.httpsconnection-detected
  message: |
    The HTTPSConnection API has changed frequently with minor releases of Python.
    Ensure you are using the API for your version of Python securely.
    For example, Python 3 versions prior to 3.4.3 will not verify SSL certificates by default.
    See https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    for more information.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-295: Improper Certificate Validation'
    references:
    - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.httpsconnection-detected.httpsconnection-detected
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: httplib.HTTPSConnection(...)
  - pattern: http.client.HTTPSConnection(...)
  - pattern: six.moves.http_client.HTTPSConnection(...)
- id: python.lang.security.audit.insecure-transport.ftplib.use-ftp-tls.use-ftp-tls
  pattern: ftplib.FTP(...)
  fix-regex:
    regex: FTP(.*)\)
    replacement: FTP_TLS\1, context=ssl.create_default_context())
  message: |
    The 'FTP' class sends information unencrypted. Consider using
    the 'FTP_TLS' class instead.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/ftplib.html#ftplib.FTP_TLS
    category: security
    technology:
    - ftplib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.ftplib.use-ftp-tls.use-ftp-tls
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.insecure-transport.requests.request-session-http-in-with-context.request-session-http-in-with-context
  patterns:
  - pattern-inside: |
      with requests.Session(...) as $SESSION:
        ...
  - pattern-either:
    - pattern: $SESSION.$W("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
    - pattern: $SESSION.request($METHOD, "=~/[Hh][Tt][Tt][Pp]://.*/", ...)
    - patterns:
      - pattern-inside: |
          $URL =  "=~/[Hh][Tt][Tt][Pp]://.*/"
          ...
      - pattern-either:
        - pattern: $SESSION.$W($URL, ...)
        - pattern: $SESSION.request($METHOD, $URL, ...)
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  message: |
    Detected a request using 'http://'. This request will be unencrypted. Use 'https://' instead.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.2.1 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements
      version: '4'
    category: security
    technology:
    - requests
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.requests.request-session-http-in-with-context.request-session-http-in-with-context
  languages:
  - python
  severity: ERROR
- id: python.lang.security.audit.insecure-transport.requests.request-session-with-http.request-session-with-http
  pattern-either:
  - pattern: |
      def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...):
        ...
        $SESSION = requests.Session(...)
        ...
        $SESSION.$W($URL, ...)
  - pattern: |
      def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...):
        ...
        $SESSION = requests.Session(...)
        ...
        $SESSION.request($METHOD, $URL, ...)
  - patterns:
    - pattern-inside: |
        $SESSION = requests.Session(...)
        ...
    - pattern-either:
      - pattern: $SESSION.$W("=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...)
      - pattern: |
          $URL = "=~/[Hh][Tt][Tt][Pp]:\/\/.*/"
          ...
          $SESSION.$W($URL, ...)
      - pattern: $SESSION.request($METHOD, "=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...)
      - pattern: |
          $URL = "=~/[Hh][Tt][Tt][Pp]:\/\/.*/"
          ...
          $SESSION.request($METHOD, $URL, ...)
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  message: |
    Detected a request using 'http://'. This request will be unencrypted. Use 'https://' instead.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.2.1 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements
      version: '4'
    category: security
    technology:
    - requests
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.requests.request-session-with-http.request-session-with-http
  languages:
  - python
  severity: ERROR
- id: python.lang.security.audit.insecure-transport.requests.request-with-http.request-with-http
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  message: |
    Detected a request using 'http://'. This request will be unencrypted. Use 'https://' instead.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.1.1 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements
      version: '4'
    category: security
    technology:
    - requests
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.requests.request-with-http.request-with-http
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: requests.$W("=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]:\/\/.*/"
      ...
      requests.$W($URL, ...)
  - pattern: |
      def $FUNC(..., $URL = "=~/^[Hh][Tt][Tt][Pp]://.*/", ...):
        ...
        requests.$W($URL, ...)
  - pattern: requests.request($METHOD, "=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]:\/\/.*/"
      ...
      requests.request($METHOD, $URL, ...)
  - pattern: |
      def $FUNC(..., $URL = "=~/^[Hh][Tt][Tt][Pp]://.*/", ...):
        ...
        requests.request($METHOD, $URL, ...)
  - pattern: requests.Request($METHOD, "=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]:\/\/.*/"
      ...
      requests.Request($METHOD, $URL, ...)
  - pattern: |
      def $FUNC(..., $URL = "=~/^[Hh][Tt][Tt][Pp]://.*/", ...):
        ...
        requests.Request($METHOD, $URL, ...)
- id: python.lang.security.audit.insecure-transport.ssl.no-set-ciphers.no-set-ciphers
  pattern: $CONTEXT.set_ciphers(...)
  message: |
    The 'ssl' module disables insecure cipher suites by default. Therefore,
    use of 'set_ciphers()' should only be used when you have very specialized
    requirements. Otherwise, you risk lowering the security of the SSL channel.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-326: Inadequate Encryption Strength'
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.1.3 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v91-client-communications-security-requirements
      version: '4'
    references:
    - https://docs.python.org/3/library/ssl.html#cipher-selection
    - https://docs.python.org/3/library/ssl.html#ssl.SSLContext.set_ciphers
    category: security
    technology:
    - ssl
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.ssl.no-set-ciphers.no-set-ciphers
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.insecure-transport.urllib.insecure-openerdirector-open-ftp.insecure-openerdirector-open-ftp
  message: |
    Detected an unsecured transmission channel. 'OpenerDirector.open(...)' is
    being used with 'ftp://'. Information sent over this connection will be
    unencrypted. Consider using SFTP instead. urllib does not support SFTP,
    so consider a library which supports SFTP.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.OpenerDirector.open
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-openerdirector-open-ftp.insecure-openerdirector-open-ftp
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: urllib.request.OpenerDirector(...).open("=~/^[Ff][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.OpenerDirector(...)
        ...
    - pattern: $OPENERDIRECTOR.open("=~/^[Ff][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.OpenerDirector(...)
        ...
    - pattern: |
        $URL = "=~/^[Ff][Tt][Pp]://.*/"
        ...
        $OPENERDIRECTOR.open($URL, ...)
  - pattern: |
      $URL = "=~/^[Ff][Tt][Pp]://.*/"
      ...
      urllib.request.OpenerDirector(...).open($URL, ...)
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $URL = "=~/^[Ff][Tt][Pp]://.*/", ...):
          ...
    - pattern-either:
      - pattern: urllib.request.OpenerDirector(...).open($URL, ...)
      - patterns:
        - pattern-inside: |
            $OPENERDIRECTOR = urllib.request.OpenerDirector(...)
            ...
        - pattern: $OPENERDIRECTOR.open($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-openerdirector-open.insecure-openerdirector-open
  message: |
    Detected an unsecured transmission channel. 'OpenerDirector.open(...)' is
    being used with 'http://'. Use 'https://' instead to secure the channel.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.OpenerDirector.open
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-openerdirector-open.insecure-openerdirector-open
  severity: WARNING
  languages:
  - python
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  pattern-either:
  - pattern: urllib.request.OpenerDirector(...).open("=~/[Hh][Tt][Tt][Pp]://.*/",
      ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.OpenerDirector(...)
        ...
    - pattern: $OPENERDIRECTOR.open("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.OpenerDirector(...)
        ...
    - pattern: |
        $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
        ...
        $OPENERDIRECTOR.open($URL, ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
      ...
      urllib.request.OpenerDirector(...).open($URL, ...)
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]://.*/", ...):
          ...
    - pattern-either:
      - pattern: urllib.request.OpenerDirector(...).open($URL, ...)
      - patterns:
        - pattern-inside: |
            $OPENERDIRECTOR = urllib.request.OpenerDirector(...)
            ...
        - pattern: $OPENERDIRECTOR.open($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-request-object-ftp.insecure-request-object-ftp
  message: |
    Detected a 'urllib.request.Request()' object using an insecure transport
    protocol, 'ftp://'. This connection will not be encrypted. Consider using
    SFTP instead. urllib does not support SFTP natively, so consider using
    a library which supports SFTP.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.Request
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-request-object-ftp.insecure-request-object-ftp
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: urllib.request.Request("=~/^[Ff][Tt][Pp]://.*/", ...)
  - pattern: |
      $URL = "=~/^[Ff][Tt][Pp]://.*/"
      ...
      urllib.request.Request($URL, ...)
  - pattern: |-
      def $FUNC(..., $URL = "=~/^[Ff][Tt][Pp]://.*/", ...):
        ...
        urllib.request.Request($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-request-object.insecure-request-object
  message: |
    Detected a 'urllib.request.Request()' object using an insecure transport
    protocol, 'http://'. This connection will not be encrypted. Use
    'https://' instead.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.Request
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-request-object.insecure-request-object
  severity: WARNING
  languages:
  - python
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  pattern-either:
  - pattern: urllib.request.Request("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
      ...
      urllib.request.Request($URL, ...)
  - pattern: |
      def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]://.*/", ...):
        ...
        urllib.request.Request($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-open-ftp.insecure-urlopener-open-ftp
  message: |
    Detected an insecure transmission channel. 'URLopener.open(...)' is
    being used with 'ftp://'. Use SFTP instead. urllib does not support
    SFTP, so consider using a library which supports SFTP.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.open
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-open-ftp.insecure-urlopener-open-ftp
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: urllib.request.URLopener(...).open("=~/[Ff][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: $OPENERDIRECTOR.open("=~/[Ff][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: |
        $URL = "=~/[Ff][Tt][Pp]://.*/"
        ...
        $OPENERDIRECTOR.open($URL, ...)
  - pattern: |
      $URL = "=~/[Ff][Tt][Pp]://.*/"
      ...
      urllib.request.URLopener(...).open($URL, ...)
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $URL = "=~/[Ff][Tt][Pp]://.*/", ...):
          ...
    - pattern-either:
      - pattern: urllib.request.URLopener(...).open($URL, ...)
      - patterns:
        - pattern-inside: |
            $OPENERDIRECTOR = urllib.request.URLopener(...)
            ...
        - pattern: $OPENERDIRECTOR.open($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-open.insecure-urlopener-open
  message: |
    Detected an unsecured transmission channel. 'URLopener.open(...)' is
    being used with 'http://'. Use 'https://' instead to secure the channel.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.open
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-open.insecure-urlopener-open
  severity: WARNING
  languages:
  - python
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  pattern-either:
  - pattern: urllib.request.URLopener(...).open("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: $OPENERDIRECTOR.open("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: |
        $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
        ...
        $OPENERDIRECTOR.open($URL, ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
      ...
      urllib.request.URLopener(...).open($URL, ...)
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]://.*/", ...):
          ...
    - pattern-either:
      - pattern: urllib.request.URLopener(...).open($URL, ...)
      - patterns:
        - pattern-inside: |
            $OPENERDIRECTOR = urllib.request.URLopener(...)
            ...
        - pattern: $OPENERDIRECTOR.open($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-retrieve-ftp.insecure-urlopener-retrieve-ftp
  message: |
    Detected an insecure transmission channel. 'URLopener.retrieve(...)' is
    being used with 'ftp://'. Use SFTP instead. urllib does not support
    SFTP, so consider using a library which supports SFTP.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.retrieve
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-retrieve-ftp.insecure-urlopener-retrieve-ftp
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: urllib.request.URLopener(...).retrieve("=~/[Ff][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: $OPENERDIRECTOR.retrieve("=~/[Ff][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: |
        $URL = "=~/[Ff][Tt][Pp]://.*/"
        ...
        $OPENERDIRECTOR.retrieve($URL, ...)
  - pattern: |
      $URL = "=~/[Ff][Tt][Pp]://.*/"
      ...
      urllib.request.URLopener(...).retrieve($URL, ...)
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $URL = "=~/[Ff][Tt][Pp]://.*/", ...):
          ...
    - pattern-either:
      - pattern: urllib.request.URLopener(...).retrieve($URL, ...)
      - patterns:
        - pattern-inside: |
            $OPENERDIRECTOR = urllib.request.URLopener(...)
            ...
        - pattern: $OPENERDIRECTOR.retrieve($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-retrieve.insecure-urlopener-retrieve
  message: |
    Detected an unsecured transmission channel. 'URLopener.retrieve(...)' is
    being used with 'http://'. Use 'https://' instead to secure the channel.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.retrieve
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-retrieve.insecure-urlopener-retrieve
  severity: WARNING
  languages:
  - python
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
    count: 1
  pattern-either:
  - pattern: urllib.request.URLopener(...).retrieve("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: $OPENERDIRECTOR.retrieve("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - patterns:
    - pattern-inside: |
        $OPENERDIRECTOR = urllib.request.URLopener(...)
        ...
    - pattern: |
        $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
        ...
        $OPENERDIRECTOR.retrieve($URL, ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
      ...
      urllib.request.URLopener(...).retrieve($URL, ...)
  - patterns:
    - pattern-inside: |
        def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]://.*/", ...):
          ...
    - pattern-either:
      - pattern: urllib.request.URLopener(...).retrieve($URL, ...)
      - patterns:
        - pattern-inside: |
            $OPENERDIRECTOR = urllib.request.URLopener(...)
            ...
        - pattern: $OPENERDIRECTOR.retrieve($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlopen-ftp.insecure-urlopen-ftp
  message: |
    Detected 'urllib.urlopen()' using 'ftp://'. This request will not be
    encrypted. Consider using SFTP instead. urllib does not support SFTP,
    so consider switching to a library which supports SFTP.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlopen-ftp.insecure-urlopen-ftp
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: urllib.request.urlopen("=~/^[Ff][Tt][Pp]://.*/", ...)
  - pattern: |
      $URL = "=~/^[Ff][Tt][Pp]://.*/"
      ...
      urllib.request.urlopen($URL, ...)
  - pattern: |-
      def $FUNC(..., $URL = "=~/^[Ff][Tt][Pp]://.*/", ...):
        ...
        urllib.request.urlopen($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlopen.insecure-urlopen
  message: |
    Detected 'urllib.urlopen()' using 'http://'. This request will not be
    encrypted. Use 'https://' instead.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlopen.insecure-urlopen
  severity: WARNING
  languages:
  - python
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
  pattern-either:
  - pattern: urllib.request.urlopen("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
      ...
      urllib.request.urlopen($URL, ...)
  - pattern: |
      def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]://.*/", ...):
        ...
        urllib.request.urlopen($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlretrieve-ftp.insecure-urlretrieve-ftp
  message: |
    Detected 'urllib.urlretrieve()' using 'ftp://'. This request will not be
    encrypted. Use SFTP instead. urllib does not support SFTP, so consider
    switching to a library which supports SFTP.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlretrieve-ftp.insecure-urlretrieve-ftp
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: urllib.request.urlretrieve("=~/^[Ff][Tt][Pp]://.*/", ...)
  - pattern: |
      $URL = "=~/^[Ff][Tt][Pp]://.*/"
      ...
      urllib.request.urlretrieve($URL, ...)
  - pattern: |-
      def $FUNC(..., $URL = "=~/^[Ff][Tt][Pp]://.*/", ...):
        ...
        urllib.request.urlretrieve($URL, ...)
- id: python.lang.security.audit.insecure-transport.urllib.insecure-urlretrieve.insecure-urlretrieve
  message: |
    Detected 'urllib.urlretrieve()' using 'http://'. This request will not be
    encrypted. Use 'https://' instead.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve
    category: security
    technology:
    - urllib
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.insecure-transport.urllib.insecure-urlretrieve.insecure-urlretrieve
  severity: WARNING
  languages:
  - python
  fix-regex:
    regex: '[Hh][Tt][Tt][Pp]://'
    replacement: https://
  pattern-either:
  - pattern: urllib.request.urlretrieve("=~/[Hh][Tt][Tt][Pp]://.*/", ...)
  - pattern: |
      $URL = "=~/[Hh][Tt][Tt][Pp]://.*/"
      ...
      urllib.request.urlretrieve($URL, ...)
  - pattern: |
      def $FUNC(..., $URL = "=~/[Hh][Tt][Tt][Pp]://.*/", ...):
        ...
        urllib.request.urlretrieve($URL, ...)
- id: python.lang.security.audit.logging.listeneval.listen-eval
  languages:
  - python
  message: |
    Because portions of the logging configuration are passed through eval(),
    use of this function may open its users to a security risk. While the
    function only binds to a socket on localhost, and so does not accept
    connections from remote machines, there are scenarios where untrusted
    code could be run under the account of the process which calls listen().
    See more details at https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.logging.listeneval.listen-eval
  severity: WARNING
  pattern: logging.config.listen(...)
- id: python.lang.security.audit.mako-templates-detected.mako-templates-detected
  pattern: mako.template.Template(...)
  message: |
    Mako templates do not provide a global HTML escaping mechanism.
    This means you must escape all sensitive data in your templates
    using '| u' for URL escaping or '| h' for HTML escaping.
    If you are using Mako to serve web content, consider using
    a system such as Jinja2 which enables global escaping.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/mako_templates.py
    references:
    - https://docs.makotemplates.org/en/latest/syntax.html#expression-escaping
    - https://jinja.palletsprojects.com/en/2.11.x/intro/#
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.mako-templates-detected.mako-templates-detected
  languages:
  - python
  severity: INFO
- id: python.lang.security.audit.marshal.marshal-usage
  languages:
  - python
  message: |
    The marshal module is not intended to be secure against erroneous or maliciously constructed data.
    Never unmarshal data received from an untrusted or unauthenticated source.
    See more details: https://docs.python.org/3/library/marshal.html?highlight=security
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.python.org/3/library/marshal.html?highlight=security
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.marshal.marshal-usage
  pattern-either:
  - pattern: marshal.dump(...)
  - pattern: marshal.dumps(...)
  - pattern: marshal.load(...)
  - pattern: marshal.loads(...)
  severity: WARNING
- id: python.lang.security.audit.network.bind.avoid-bind-to-all-interfaces
  message: |
    Running `socket.bind` to 0.0.0.0, ::, or empty string could unexpectedly
    expose the server publicly as it binds to all available interfaces. Consider
    instead getting correct address from an environment variable or
    configuration file.
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A6: Security Misconfiguration'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.network.bind.avoid-bind-to-all-interfaces
  languages:
  - python
  severity: INFO
  pattern-either:
  - pattern: |
      $S = socket.socket(...)
      ...
      $S.bind(("0.0.0.0", ...))
  - pattern: |
      $S = socket.socket(...)
      ...
      $S.bind(("::", ...))
  - pattern: |
      $S = socket.socket(...)
      ...
      $S.bind(("", ...))
- id: python.lang.security.audit.network.disabled-cert-validation.disabled-cert-validation
  patterns:
  - pattern-either:
    - pattern: urllib3.PoolManager(..., cert_reqs=$REQS, ...)
    - pattern: urllib3.ProxyManager(..., cert_reqs=$REQS, ...)
    - pattern: urllib3.HTTPSConnectionPool(..., cert_reqs=$REQS, ...)
    - pattern: urllib3.connectionpool.HTTPSConnectionPool(..., cert_reqs=$REQS, ...)
    - pattern: urllib3.connection_from_url(..., cert_reqs=$REQS, ...)
    - pattern: urllib3.proxy_from_url(..., cert_reqs=$REQS, ...)
    - pattern: $CONTEXT.wrap_socket(..., cert_reqs=$REQS, ...)
    - pattern: ssl.wrap_socket(..., cert_reqs=$REQS, ...)
  - metavariable-regex:
      metavariable: $REQS
      regex: (NONE|CERT_NONE|CERT_OPTIONAL|ssl\.CERT_NONE|ssl\.CERT_OPTIONAL|\'NONE\'|\"NONE\"|\'OPTIONAL\'|\"OPTIONAL\")
  message: certificate verification explicitly disabled, insecure connections possible
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.network.disabled-cert-validation.disabled-cert-validation
  languages:
  - python
  severity: ERROR
- id: python.lang.security.audit.network.http-not-https-connection.http-not-https-connection
  message: |
    Detected HTTPConnectionPool. This will transmit data in cleartext.
    It is recommended to use HTTPSConnectionPool instead for to encrypt
    communications.
  metadata:
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://urllib3.readthedocs.io/en/1.2.1/pools.html#urllib3.connectionpool.HTTPSConnectionPool
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.network.http-not-https-connection.http-not-https-connection
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: urllib3.HTTPConnectionPool(...)
  - pattern: urllib3.connectionpool.HTTPConnectionPool(...)
- id: python.lang.security.audit.paramiko-implicit-trust-host-key.paramiko-implicit-trust-host-key
  patterns:
  - pattern-inside: |
      $CLIENT = paramiko.client.SSHClient(...)
      ...
      $CLIENT.set_missing_host_key_policy(...)
  - pattern-either:
    - pattern: paramiko.client.AutoAddPolicy
    - pattern: paramiko.client.WarningPolicy
  message: |
    Detected a paramiko host key policy that implicitly trusts a server's
    host key. Host keys should be verified to ensure the connection
    is not to a malicious server. Use RejectPolicy or a custom subclass
    instead.
  metadata:
    cwe: 'CWE-322: Key Exchange without Entity Authentication'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/ssh_no_host_key_verification.py
    references:
    - http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.AutoAddPolicy
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.paramiko-implicit-trust-host-key.paramiko-implicit-trust-host-key
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.paramiko.paramiko-exec-command.paramiko-exec-command
  patterns:
  - pattern-inside: |
      $CLIENT = paramiko.client.SSHClient(...)
      ...
  - pattern: $CLIENT.exec_command(...)
  - pattern-not: $CLIENT.exec_command("...", ...)
  message: |
    Unverified SSL context detected. This will permit insecure connections without verifying
    SSL certificates. Use 'ssl.create_default_context()' instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py
    owasp: 'A1: Injection'
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    references:
    - http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.exec_command
    - https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py
    category: security
    technology:
    - paramiko
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.paramiko.paramiko-exec-command.paramiko-exec-command
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.ssl-wrap-socket-is-deprecated.ssl-wrap-socket-is-deprecated
  pattern: ssl.wrap_socket(...)
  message: |
    'ssl.wrap_socket()' is deprecated. This function creates an insecure socket
    without server name indication or hostname matching. Instead, create an SSL
    context using 'ssl.SSLContext()' and use that to wrap a socket.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://docs.python.org/3/library/ssl.html#ssl.wrap_socket
    - https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.ssl-wrap-socket-is-deprecated.ssl-wrap-socket-is-deprecated
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.subprocess-shell-true.subprocess-shell-true
  patterns:
  - pattern: subprocess.$FUNC(..., shell=True, ...)
  - pattern-not: subprocess.$FUNC("...", shell=True, ...)
  message: |
    Found 'subprocess' function '$FUNC' with 'shell=True'. This is dangerous because this call will spawn
    the command using a shell process. Doing so propagates current shell settings and variables, which
    makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.
  fix-regex:
    regex: (shell\s*=\s*)True
    replacement: \1False
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    references:
    - https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess
    - https://docs.python.org/3/library/subprocess.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.subprocess-shell-true.subprocess-shell-true
  languages:
  - python
  severity: ERROR
- id: python.lang.security.audit.system-wildcard-detected.system-wildcard-detected
  patterns:
  - pattern-either:
    - pattern-inside: os.system("...")
    - pattern-inside: os.popen("...")
    - pattern-inside: os.popen2("...")
    - pattern-inside: os.popen3("...")
    - pattern-inside: os.popen4("...")
    - pattern-inside: subprocess.$W(..., shell=True, ...)
  - pattern-regex: (tar|chmod|chown|rsync)(.*?)\*
  message: |
    Detected use of the wildcard character in a system call that spawns a shell.
    This subjects the wildcard to normal shell expansion, which can have unintended consequences
    if there exist any non-standard file names. Consider a file named '-e sh script.sh' -- this
    will execute a script when 'rsync' is called. See
    https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt
    for more information.
  metadata:
    cwe: 'CWE-155: Improper Neutralization of Wildcards or Matching Symbols'
    owasp: 'A1: Injection'
    source-url-open: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/injection_wildcard.py
    references:
    - https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.system-wildcard-detected.system-wildcard-detected
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.telnetlib.telnetlib
  pattern: telnetlib.$ANYTHING(...)
  message: |
    Telnet does not encrypt communications. Use SSH instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L208
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B312
    references:
    - https://docs.python.org/3/library/telnetlib.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.telnetlib.telnetlib
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.weak-ssl-version.weak-ssl-version
  message: |
    An insecure SSL version was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use 'ssl.PROTOCOL_TLSv1_2' or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/insecure_ssl_tls.py#L30
    asvs:
      section: V9 Communications Verification Requirements
      control_id: 9.1.3 Weak TLS
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v91-client-communications-security-requirements
      version: '4'
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    - https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLSv1_2
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.audit.weak-ssl-version.weak-ssl-version
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: ssl.PROTOCOL_SSLv2
  - pattern: ssl.PROTOCOL_SSLv3
  - pattern: ssl.PROTOCOL_TLSv1
  - pattern: ssl.PROTOCOL_TLSv1_1
  - pattern: pyOpenSSL.SSL.SSLv2_METHOD
  - pattern: pyOpenSSL.SSL.SSLv23_METHOD
  - pattern: pyOpenSSL.SSL.SSLv3_METHOD
  - pattern: pyOpenSSL.SSL.TLSv1_METHOD
  - pattern: pyOpenSSL.SSL.TLSv1_1_METHOD
- id: python.lang.security.dangerous-globals-use.dangerous-globals-use
  patterns:
  - pattern-either:
    - pattern: globals().get(...)
    - pattern: locals().get(...)
    - pattern: globals()[...]
    - pattern: locals()[...]
    - patterns:
      - pattern-either:
        - pattern-inside: |
            $G = globals()
            ...
        - pattern-inside: |
            $G = locals()
            ...
      - pattern-either:
        - pattern: $G.get(...)
        - pattern: $G[...]
    - pattern: $FUNC.__globals__[...]
  - pattern-not: globals().get("...")
  - pattern-not: locals().get("...")
  - pattern-not: globals()["..."]
  - pattern-not: locals()["..."]
  - pattern-not: $G.get("...")
  - pattern-not: $G.get["..."]
  - pattern-not: $G["..."]
  - pattern-not: $FUNC.__globals__["..."]
  - pattern-not-inside: globals()[...] = ...
  - pattern-not-inside: locals()[...] = ...
  - pattern-not-inside: $G[...] = ...
  - pattern-not-inside: $FUNC.__globals__[...] = ...
  message: |
    Found non static data as an index to 'globals()'. This is extremely
    dangerous because it allows an attacker to execute arbitrary code
    on the system. Refactor your code not to use 'globals()'.
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.dangerous-globals-use.dangerous-globals-use
  severity: WARNING
  languages:
  - python
- id: python.lang.security.deserialization.avoid-pyyaml-load.avoid-pyyaml-load
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://github.com/yaml/pyyaml/wiki/PyYAML-yaml.load(input)-Deprecation
    - https://nvd.nist.gov/vuln/detail/CVE-2017-18342
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.deserialization.avoid-pyyaml-load.avoid-pyyaml-load
  languages:
  - python
  message: |
    Avoid using `load()`. `PyYAML.load` can create arbitrary Python
    objects. A malicious actor could exploit this to run arbitrary
    code. Use `safe_load()` instead.
  fix-regex:
    regex: load
    replacement: safe_load
    count: 1
  severity: ERROR
  patterns:
  - pattern-inside: |
      import yaml
      ...
  - pattern-not-inside: |
      $YAML = ruamel.yaml.YAML(...)
      ...
  - pattern-not: yaml.load(..., Loader=yaml.CSafeLoader, ...)
  - pattern-not: yaml.load(..., Loader=yaml.SafeLoader, ...)
  - pattern-not: yaml.load_all(..., Loader=yaml.CSafeLoader, ...)
  - pattern-not: yaml.load_all(..., Loader=yaml.SafeLoader, ...)
  - pattern-either:
    - pattern: yaml.load(...)
    - pattern: yaml.load_all(...)
- id: python.lang.security.deserialization.avoid-unsafe-ruamel.avoid-unsafe-ruamel
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://yaml.readthedocs.io/en/latest/basicuse.html?highlight=typ
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.deserialization.avoid-unsafe-ruamel.avoid-unsafe-ruamel
  languages:
  - python
  message: |
    Avoid using unsafe `ruamel.yaml.YAML()`. `ruamel.yaml.YAML` can
    create arbitrary Python objects. A malicious actor could exploit
    this to run arbitrary code. Use `YAML(typ='rt')` or
    `YAML(typ='safe')` instead.
  severity: ERROR
  pattern-either:
  - pattern: ruamel.yaml.YAML(..., typ='unsafe', ...)
  - pattern: ruamel.yaml.YAML(..., typ='base', ...)
- id: python.lang.security.deserialization.pickle.avoid-pickle
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    - https://davidhamann.de/2020/04/05/exploiting-python-pickle/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.deserialization.pickle.avoid-pickle
  languages:
  - python
  message: |
    Avoid using `pickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern-either:
  - pattern: pickle.$FUNC(...)
  - pattern: _pickle.$FUNC(...)
- id: python.lang.security.deserialization.pickle.avoid-cPickle
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.deserialization.pickle.avoid-cPickle
  languages:
  - python
  message: |
    Avoid using `cPickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern: cPickle.$FUNC(...)
- id: python.lang.security.deserialization.pickle.avoid-dill
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.deserialization.pickle.avoid-dill
  languages:
  - python
  message: |
    Avoid using `dill`, which uses `pickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern: dill.$FUNC(...)
- id: python.lang.security.deserialization.pickle.avoid-shelve
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.deserialization.pickle.avoid-shelve
  languages:
  - python
  message: |
    Avoid using `shelve`, which uses `pickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern: shelve.$FUNC(...)
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: hashlib.md5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.2 Insecure Custom Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  severity: WARNING
  languages:
  - python
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: hashlib.sha1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.2 Insecure Custom Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  severity: WARNING
  languages:
  - python
- id: python.lang.security.insecure-hash-function.insecure-hash-function
  message: |
    Detected use of an insecure MD4 or MD5 hash function.
    These functions have known vulnerabilities and are considered deprecated.
    Consider using 'SHA256' or a similar function instead.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/hashlib_new_insecure_functions.py
    asvs:
      section: V6 Stored Cryptography Verification Requirements
      control_id: 6.2.2 Insecure Custom Algorithm
      control_url: https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms
      version: '4'
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.insecure-hash-function.insecure-hash-function
  languages:
  - python
  severity: WARNING
  pattern-either:
  - pattern: hashlib.new("=~/[M|m][D|d][4|5]/", ...)
  - pattern: hashlib.new(..., name="=~/[M|m][D|d][4|5]/", ...)
- id: python.lang.security.unquoted-csv-writer.unquoted-csv-writer
  patterns:
  - pattern-not: csv.writer(..., quoting=csv.QUOTE_ALL, ...)
  - pattern: csv.writer(...)
  message: Found an unquoted CSV writer. This is susceptible to injection. Use 'quoting=csv.QUOTE_ALL'.
  metadata:
    cwe: 'CWE-1236: Improper Neutralization of Formula Elements in a CSV File'
    owasp: 'A1: Injection'
    references:
    - https://affinity-it-security.com/how-to-prevent-csv-injection/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.unquoted-csv-writer.unquoted-csv-writer
  fix-regex:
    regex: (.*)\)
    replacement: \1, quoting=csv.QUOTE_ALL)
  languages:
  - python
  severity: ERROR
- id: python.lang.security.unverified-ssl-context.unverified-ssl-context
  pattern: ssl._create_unverified_context(...)
  message: |
    Unverified SSL context detected. This will permit insecure connections without verifying
    SSL certificates. Use 'ssl.create_default_context()' instead.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-295: Improper Certificate Validation'
    references:
    - https://docs.python.org/3/library/ssl.html#ssl-security
    - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.unverified-ssl-context.unverified-ssl-context
  severity: ERROR
  languages:
  - python
- id: python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
  pattern-either:
  - pattern: import xmlrpclib
  - pattern: import SimpleXMLRPCServer
  - pattern: import xmlrpc
  message: |
    Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities.
    Use defusedxml.xmlrpc instead.
  metadata:
    cwe: 'CWE-776: Improper Restriction of Recursive Entity References in DTDs (''XML
      Entity Expansion'')'
    owasp: 'A4: XML External Entities (XXE)'
    source-rule-url: https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160
    references:
    - https://pypi.org/project/defusedxml/
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
  severity: ERROR
  languages:
  - python
- id: python.lang.security.use-defused-xml.use-defused-xml
  fix-regex:
    regex: xml
    replacement: defusedxml
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    references:
    - https://docs.python.org/3/library/xml.html
    - https://github.com/tiran/defusedxml
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.lang.security.use-defused-xml.use-defused-xml
  message: |
    Found use of the native Python XML libraries, which is vulnerable to XML external entity (XXE)
    attacks. The Python documentation recommends the 'defusedxml' library instead. Use 'defusedxml'.
    See https://github.com/tiran/defusedxml for more information.
  languages:
  - python
  severity: ERROR
  pattern: import xml
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
  message: |
    Detected RC2 cipher algorithm which is considered insecure. The algorithm has known vulnerabilities and is difficult to use securely. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://security.stackexchange.com/questions/93924/is-rc2-cbc-at-all-secure
    - https://sweet32.info/
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Cryptodome.Cipher.ARC2.new(...)
  - pattern: Crypto.Cipher.ARC2.new
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Cryptodome.Cipher.ARC4.new(...)
  - pattern: Crypto.Cipher.ARC4.new(...)
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Cryptodome.Cipher.Blowfish.new(...)
  - pattern: Crypto.Cipher.Blowfish.new(...)
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
  message: |
    Detected DES cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Cryptodome.Cipher.DES.new(...)
  - pattern: Crypto.Cipher.DES.new(...)
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
  message: |
    Detected XOR cipher algorithm which is considered insecure. This algorithm
    is not cryptographically secure and can be reversed easily. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Cryptodome.Cipher.XOR.new(...)
  - pattern: Crypto.Cipher.XOR.new(...)
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
  message: |
    Detected MD2 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6149
    - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2409
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Crypto.Hash.MD2.new(...)
  - pattern: Cryptodome.Hash.MD2.new (...)
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
  message: |
    Detected MD4 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6150
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Crypto.Hash.MD4.new(...)
  - pattern: Cryptodome.Hash.MD4.new (...)
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Crypto.Hash.MD5.new(...)
  - pattern: Cryptodome.Hash.MD5.new (...)
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
  severity: WARNING
  languages:
  - python
  pattern-either:
  - pattern: Crypto.Hash.SHA.new(...)
  - pattern: Cryptodome.Hash.SHA.new (...)
- id: python.pycryptodome.security.insufficient-dsa-key-size.insufficient-dsa-key-size
  patterns:
  - pattern-either:
    - pattern: Crypto.PublicKey.DSA.generate(..., bits=$SIZE, ...)
    - pattern: Crypto.PublicKey.DSA.generate($SIZE, ...)
    - pattern: Cryptodome.PublicKey.DSA.generate(..., bits=$SIZE, ...)
    - pattern: Cryptodome.PublicKey.DSA.generate($SIZE, ...)
  - metavariable-comparison:
      metavariable: $SIZE
      comparison: $SIZE < 2048
  message: |
    Detected an insufficient key size for DSA. NIST recommends
    a key size of 2048 or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insufficient-dsa-key-size.insufficient-dsa-key-size
  languages:
  - python
  severity: WARNING
- id: python.pycryptodome.security.insufficient-rsa-key-size.insufficient-rsa-key-size
  patterns:
  - pattern-either:
    - pattern: Crypto.PublicKey.RSA.generate(..., bits=$SIZE, ...)
    - pattern: Crypto.PublicKey.RSA.generate($SIZE, ...)
    - pattern: Cryptodome.PublicKey.RSA.generate(..., bits=$SIZE, ...)
    - pattern: Cryptodome.PublicKey.RSA.generate($SIZE, ...)
  - metavariable-comparison:
      metavariable: $SIZE
      comparison: $SIZE < 2048
  message: |
    Detected an insufficient key size for RSA. NIST recommends
    a key size of 2048 or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    category: security
    technology:
    - pycryptodome
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.pycryptodome.security.insufficient-rsa-key-size.insufficient-rsa-key-size
  languages:
  - python
  severity: WARNING
- id: python.requests.security.disabled-cert-validation.disabled-cert-validation
  message: |
    Certificate verification has been explicitly disabled. This
    permits insecure connections to insecure servers. Re-enable
    certification validation.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://stackoverflow.com/questions/41740361/is-it-safe-to-disable-ssl-certificate-verification-in-pythonss-requests-lib
    category: security
    technology:
    - requests
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.requests.security.disabled-cert-validation.disabled-cert-validation
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: requests.put(..., verify=False, ...)
  - pattern: requests.patch(..., verify=False, ...)
  - pattern: requests.delete(..., verify=False, ...)
  - pattern: requests.head(..., verify=False, ...)
  - pattern: requests.options(..., verify=False, ...)
  - pattern: requests.request(..., verify=False, ...)
  - pattern: requests.get(..., verify=False, ...)
  - pattern: requests.post(..., verify=False, ...)
- id: python.requests.security.no-auth-over-http.no-auth-over-http
  fix-regex:
    regex: http:\/\/
    replacement: https://
    count: 1
  message: |
    Authentication detected over HTTP. HTTP does not provide any
    encryption or protection for these authentication credentials.
    This may expose these credentials to unauthhorized parties.
    Use 'https://' instead.
  metadata:
    cwe: 'CWE-523: Unprotected Transport of Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-flask/
    references:
    - https://blog.r2c.dev/2020/bento-check-no-auth-over-http/
    - https://bento.dev/checks/requests/no-auth-over-http/
    category: security
    technology:
    - requests
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.requests.security.no-auth-over-http.no-auth-over-http
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: requests.$W("=~/http:\/\/.*/", ..., auth=$X, ...)
  - pattern: |
      $URL = "=~/http:\/\/.../"
      ...
      requests.$W($URL, ..., auth=$X, ...)
- id: python.sh.security.string-concat.string-concat
  languages:
  - python
  severity: WARNING
  message: |
    Detected string concatenation or formatting in a call to a command via 'sh'.
    This could be a command injection vulnerability if the data is user-controlled.
    Instead, use a list and append the argument.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    category: security
    technology:
    - sh
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.sh.security.string-concat.string-concat
  pattern-either:
  - pattern: sh.$BIN($X + $Y)
  - pattern: sh.$BIN($X.format(...))
  - pattern: sh.$BIN(f"...{...}...")
- id: python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query
  message: |
    Avoiding SQL string concatenation: untrusted input concatinated with raw SQL query can result in SQL Injection. In order to execute raw query safely, prepared statement should be used. SQLAlchemy provides TextualSQL to easily used prepared statement with named parameters. For complexe SQL composition, use SQL Expression Languague or Schema Definition Language. In most cases, SQLAlchemy ORM will be a better option.
  metadata:
    cwe: |
      CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')
    owasp: 'A1: Injection'
    references:
    - https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-textual-sql
    - https://www.tutorialspoint.com/sqlalchemy/sqlalchemy_quick_guide.htm
    - https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-more-specific-text-with-table-expression-literal-column-and-expression-column
    category: security
    technology:
    - sqlalchemy
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query
  severity: ERROR
  languages:
  - python
  pattern-either:
  - pattern: |
      $CONNECTION.execute( $SQL + ..., ... )
  - pattern: |
      $CONNECTION.execute( $SQL % (...), ...)
  - pattern: |
      $CONNECTION.execute( $SQL.format(...), ... )
  - pattern: |
      $CONNECTION.execute(f"...{...}...", ...)
  - pattern: |
      $QUERY = $SQL + ...
      ...
      $CONNECTION.execute($QUERY, ...)
  - pattern: |
      $QUERY = $SQL % (...)
      ...
      $CONNECTION.execute($QUERY, ...)
  - pattern: |
      $QUERY = $SQL.format(...)
      ...
      $CONNECTION.execute($QUERY, ...)
  - pattern: |
      $QUERY = f"...{...}..."
      ...
      $CONNECTION.execute($QUERY, ...)
- id: ruby.jwt.security.audit.jwt-decode-without-verify.ruby-jwt-decode-without-verify
  message: |
    Detected the decoding of a JWT token without a verify step.
    JWT tokens must be verified before use, otherwise the token's
    integrity is unknown. This means a malicious actor could forge
    a JWT token with any claims.
  metadata:
    cwe: 'CWE-345: Insufficient Verification of Data Authenticity'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.jwt.security.audit.jwt-decode-without-verify.ruby-jwt-decode-without-verify
  languages:
  - ruby
  severity: WARNING
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern: JWT.decode($PAYLOAD,$SECRET,false,...)
- id: ruby.jwt.security.audit.jwt-exposed-data.ruby-jwt-exposed-data
  message: |
    The object is passed strictly to jsonwebtoken.sign(...)
    Make sure that sensitive information is not exposed through JWT token payload.
  severity: WARNING
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.jwt.security.audit.jwt-exposed-data.ruby-jwt-exposed-data
  languages:
  - ruby
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern-inside: |
      def $FUNC(...,$INPUT,...)
        ...
      end
  - pattern: |
      JWT.encode($INPUT,...)
- id: ruby.jwt.security.jwt-exposed-credentials.ruby-jwt-exposed-credentials
  languages:
  - ruby
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.jwt.security.jwt-exposed-credentials.ruby-jwt-exposed-credentials
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern: |
      $PAYLOAD = {...,password:...,...}
      ...
      JWT.encode($PAYLOAD,...)
  severity: ERROR
- id: ruby.jwt.security.jwt-hardcode.ruby-jwt-hardcoded-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.jwt.security.jwt-hardcode.ruby-jwt-hardcoded-secret
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern-either:
    - pattern: |
        JWT.encode($PAYLOAD,"...",...)
    - pattern: |
        JWT.decode($PAYLOAD,"...",...)
    - pattern: |
        JWT.encode($PAYLOAD,nil,...)
    - pattern: |
        JWT.decode($PAYLOAD,nil,...)
    - pattern: |
        $SECRET = "..."
        ...
        JWT.encode($PAYLOAD,$SECRET,...)
    - pattern: |
        $SECRET = "..."
        ...
        JWT.decode($PAYLOAD,$SECRET,...)
  languages:
  - ruby
  severity: ERROR
- id: ruby.jwt.security.jwt-none-alg.ruby-jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    category: security
    technology:
    - jwt
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.jwt.security.jwt-none-alg.ruby-jwt-none-alg
  languages:
  - ruby
  severity: ERROR
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern: |
      JWT.encode($PAYLOAD, $SECRET, 'none', ...)
- id: ruby.lang.security.dangerous-exec.dangerous-exec
  pattern-either:
  - patterns:
    - pattern: |
        $EXEC(...)
    - pattern-not: |
        $EXEC("...",...)
    - pattern-not: |
        $EXEC(["...",...],...)
    - pattern-not: |
        $EXEC({...},"...",...)
    - pattern-not: |
        $EXEC({...},["...",...],...)
    - metavariable-regex:
        metavariable: $EXEC
        regex: ^(system|exec|spawn|Process.exec|Process.spawn|Open3.capture2|Open3.capture2e|Open3.capture3|Open3.popen2|Open3.popen2e|Open3.popen3|IO.popen|Gem::Util.popen|PTY.spawn)$
  - patterns:
    - pattern-either:
      - pattern: |
          $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/",...)
      - pattern: |
          $EXEC({...},"=~/(sh|bash|ksh|csh|tcsh|zsh)/",...)
      - pattern: |
          $EXEC(["=~/(sh|bash|ksh|csh|tcsh|zsh)/",...],...)
      - pattern: |
          $EXEC({...},["=~/(sh|bash|ksh|csh|tcsh|zsh)/",...],...)
    - pattern-not: |
        $EXEC("...","...",...)
    - pattern-not: |
        $EXEC(["...","...",...],...)
    - pattern-not: |
        $EXEC({...},"...","...",...)
    - pattern-not: |
        $EXEC({...},["...","...",...],...)
    - metavariable-regex:
        metavariable: $EXEC
        regex: ^(system|exec|spawn|Process.exec|Process.spawn|Open3.capture2|Open3.capture2e|Open3.capture3|Open3.popen2|Open3.popen2e|Open3.popen3|IO.popen|Gem::Util.popen|PTY.spawn)$
  - patterns:
    - pattern-either:
      - pattern: |
          $EXEC("=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",...)
      - pattern: |
          $EXEC({...},"=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",...)
      - pattern: |
          $EXEC(["=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",...],...)
      - pattern: |
          $EXEC({...},["=~/(sh|bash|ksh|csh|tcsh|zsh)/","-c",...],...)
    - pattern-not: |
        $EXEC("...","...","...",...)
    - pattern-not: |
        $EXEC(["...","...","...",...],...)
    - pattern-not: |
        $EXEC({...},"...","...","...",...)
    - pattern-not: |
        $EXEC({...},["...","...","...",...],...)
    - metavariable-regex:
        metavariable: $EXEC
        regex: ^(system|exec|spawn|Process.exec|Process.spawn|Open3.capture2|Open3.capture2e|Open3.capture3|Open3.popen2|Open3.popen2e|Open3.popen3|IO.popen|Gem::Util.popen|PTY.spawn)$
  message: |
    Detected non-static command inside $EXEC. Audit the input to '$EXEC'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.dangerous-exec.dangerous-exec
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.dangerous-open3-pipeline.dangerous-open3-pipeline
  patterns:
  - pattern: |
      Open3.$PIPE(...)
  - pattern-not: |
      Open3.$PIPE(...,"...",...)
  - metavariable-regex:
      metavariable: $PIPE
      regex: ^(pipeline|pipeline_r|pipeline_rw|pipeline_start|pipeline_w)$
  message: |
    Detected non-static command inside $PIPE. Audit the input to '$PIPE'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.dangerous-open3-pipeline.dangerous-open3-pipeline
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.dangerous-open.dangerous-open
  patterns:
  - pattern: |
      open($CMD,...)
  - pattern-not: |
      open("...",...)
  - metavariable-regex:
      metavariable: $CMD
      regex: '|'
  message: |
    Detected non-static command inside 'open'. Audit the input to 'open'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.dangerous-open.dangerous-open
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.dangerous-subshell.dangerous-subshell
  patterns:
  - pattern: |
      `...#{$VAL}...`
  - pattern-not: |
      `...#{"..."}...`
  - pattern-not-inside: |
      $VAL = "..."
      ...
  message: |
    Detected non-static command inside `...`.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.dangerous-subshell.dangerous-subshell
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.dangerous-syscall.dangerous-syscall
  pattern: |
    syscall
  message: |
    'syscall' is essentially unsafe and unportable. The DL (https://apidock.com/ruby/Fiddle) library is preferred for safer and a bit more portable programming.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.dangerous-syscall.dangerous-syscall
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
  pattern: |
    class $CONTROLLER < ApplicationController
      ...
      http_basic_authenticate_with ..., :password => "...", ...
    end
  message: |
    Detected hardcoded password used in basic authentication in a controller
    class. Including this password in version control could expose this
    credential. Consider refactoring to use environment variables or
    configuration files.
  severity: ERROR
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/basic_auth/index.markdown
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
  languages:
  - ruby
- id: ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
  pattern: $MODEL.new(params[...], ..., :without_protection => true, ...)
  message: |
    Mass assignment protection disabled for '$MODEL'. This could
    permit assignment to sensitive model fields without intention. Instead,
    use 'attr_accessible' for the model or disable mass assigment using
    'config.active_record.whitelist_attributes = true'.
    ':without_protection => true' must be removed for this to take effect.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/mass_assignment/index.markdown
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.missing-csrf-protection.missing-csrf-protection
  patterns:
  - pattern: |
      class $CONTROLLER < ActionController::Base
        ...
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery :with => :exception
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery prepend: true, with: :exception
      end
  message: |
    Detected controller which does not enable cross-site request forgery
    protections using 'protect_from_forgery'. Add
    'protect_from_forgery :with => :exception' to your controller class.
  severity: ERROR
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.missing-csrf-protection.missing-csrf-protection
  languages:
  - ruby
- id: ruby.lang.security.unprotected-mass-assign.mass-assignment-vuln
  patterns:
  - pattern-either:
    - pattern: |
        $MOD.new(params[$CODE])
    - pattern: |
        $MOD.new(..., params[$CODE], :without_protection => true, ...)
  - pattern-not-inside: |
      attr_accessible $VAR
      ...
      $MOD.new(params[$CODE])
  message: |
    Checks for calls to without_protection during mass assignment (which allows record creation from hash values).
    This can lead to users bypassing permissions protections. For Rails 4 and higher, mass protection is on by default.
    Fix: Don't use :without_protection => true. Instead, configure attr_acessible to control attribute access.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_without_protection.rb
    - https://www.acunetix.com/vulnerabilities/web/rails-mass-assignment/
    category: security
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.lang.security.unprotected-mass-assign.mass-assignment-vuln
  languages:
  - ruby
  severity: WARNING
- id: ruby.rails.security.audit.xss.avoid-content-tag.avoid-content-tag
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/template_injection/index.markdown
    - https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.avoid-content-tag.avoid-content-tag
  message: |
    'content_tag()' bypasses HTML escaping for some portion of the content.
    If external data can reach here, this exposes your application
    to cross-site scripting (XSS) attacks. Ensure no external data reaches here.
    If you must do this, create your HTML manually and use 'html_safe'. Ensure no
    external data enters the HTML-safe string!
  languages:
  - ruby
  severity: WARNING
  pattern: content_tag(...)
- id: ruby.rails.security.audit.xss.avoid-html-safe.avoid-html-safe
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross_site_scripting/index.markdown
    - https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.avoid-html-safe.avoid-html-safe
  message: |
    'html_safe()' does not make the supplied string safe. 'html_safe()' bypasses
    HTML escaping. If external data can reach here, this exposes your application
    to cross-site scripting (XSS) attacks. Ensure no external data reaches here.
  languages:
  - ruby
  severity: WARNING
  pattern-either:
  - pattern: $STR.html_safe
  - pattern: $STR.html_safe.$MORE
- id: ruby.rails.security.audit.xss.avoid-raw.avoid-raw
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://api.rubyonrails.org/classes/ActionView/Helpers/OutputSafetyHelper.html#method-i-raw
    - https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.avoid-raw.avoid-raw
  message: |
    'raw()' bypasses HTML escaping. If external data can reach here, this exposes your application
    to cross-site scripting (XSS) attacks. If you must do this, construct individual strings
    and mark them as safe for HTML rendering with `html_safe()`.
  languages:
  - ruby
  severity: WARNING
  pattern: raw(...)
- id: ruby.rails.security.audit.xss.avoid-render-inline.avoid-render-inline
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#inline-renders---even-worse-than-xss
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.avoid-render-inline.avoid-render-inline
  message: |
    'render inline: ...' renders an entire ERB template inline and is dangerous.
    If external data can reach here, this exposes your application
    to server-side template injection (SSTI) or cross-site scripting (XSS) attacks.
    Instead, consider using a partial or another safe rendering method.
  languages:
  - ruby
  severity: WARNING
  pattern: 'render inline: ...'
- id: ruby.rails.security.audit.xss.avoid-render-text.avoid-render-text
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#inline-renders---even-worse-than-xss
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.avoid-render-text.avoid-render-text
  message: |
    'render text: ...' actually sets the content-type to 'text/html'.
    If external data can reach here, this exposes your application
    to cross-site scripting (XSS) attacks. Instead, use 'render plain: ...' to
    render non-HTML text.
  languages:
  - ruby
  severity: WARNING
  pattern: 'render text: ...'
  fix-regex:
    regex: 'text:'
    replacement: 'plain:'
- id: ruby.rails.security.audit.xss.manual-template-creation.manual-template-creation
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/template_injection/index.markdown
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.manual-template-creation.manual-template-creation
  message: |
    Detected manual creation of an ERB template. Manual creation of templates
    may expose your application to server-side template injection (SSTI) or
    cross-site scripting (XSS) attacks if user input is used to create the
    template. Instead, create a '.erb' template file and use 'render'.
  languages:
  - ruby
  severity: WARNING
  pattern: ERB.new(...)
- id: ruby.rails.security.audit.xss.templates.dangerous-link-to.dangerous-link-to
  message: |
    Detected a template variable used in 'link_to'. This will
    generate dynamic data in the 'href' attribute.
    This allows a malicious actor to
    input the 'javascript:' URI and is subject to cross-
    site scripting (XSS) attacks. If using a relative URL,
    start with a literal forward slash and concatenate the URL,
    like this: 'link_to "Here", "/"+@link'. You may also consider
    setting the Content Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Ruby_on_Rails_Cheat_Sheet.html#cross-site-scripting-xss
    - https://brakemanscanner.org/docs/warning_types/link_to_href/
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.templates.dangerous-link-to.dangerous-link-to
  languages:
  - generic
  paths:
    include:
    - '*.erb'
  severity: WARNING
  patterns:
  - pattern-inside: <%= ... %>
  - pattern-not-inside: link_to ... "/" + ... @$VAR
  - pattern-not-inside: link_to ... '/' + ... @$VAR
  - pattern: link_to ... @$VAR
- id: ruby.rails.security.audit.xss.templates.unquoted-attribute.unquoted-attribute
  message: |
    Detected a unquoted template variable as an attribute. If unquoted, a
    malicious actor could inject custom JavaScript handlers. To fix this,
    add quotes around the template expression, like this: "<%= expr %>".
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#unquoted-attributes
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.templates.unquoted-attribute.unquoted-attribute
  languages:
  - generic
  paths:
    include:
    - '*.erb'
  severity: WARNING
  patterns:
  - pattern-inside: <$TAG ...>
  - pattern-not-inside: ="..."
  - pattern-not-inside: ='...'
  - pattern: <%= ... %>
  fix-regex:
    regex: <%=(.*?)%>
    replacement: '"<%=\1%>"'
- id: ruby.rails.security.audit.xss.templates.var-in-href.var-in-href
  message: |
    Detected a template variable used in an anchor tag with
    the 'href' attribute. This allows a malicious actor to
    input the 'javascript:' URI and is subject to cross-
    site scripting (XSS) attacks. If using a relative URL,
    start with a literal forward slash and concatenate the URL,
    like this: href='/<%= link =>'. You may also consider setting
    the Content Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI
    - https://github.com/pugjs/pug/issues/2952
    category: security
    technology:
    - rails
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/ruby.rails.security.audit.xss.templates.var-in-href.var-in-href
  languages:
  - generic
  paths:
    include:
    - '*.erb'
  severity: WARNING
  pattern-either:
  - pattern: <a ... href = "<%= ... %>" ... >
  - pattern: <a ... href = '<%= ... %>' ... >
- id: typescript.react.security.audit.react-css-injection.react-css-injection
  patterns:
  - pattern-either:
    - pattern-inside: |
        import $STYLE from "...";
        ...
    - pattern-inside: |
        $STYLE = $METHOD(...);
        ...
    - pattern-inside: |
        function $FUNC(...,{$STYLE},...) {
          ...
        }
    - pattern-inside: |
        function $FUNC(...,$STYLE,...) {
          ...
        }
  - pattern-either:
    - pattern: |
        <$EL style={$STYLE} />
    - pattern: |
        $R.createElement($EL, {style: $STYLE}, ...)
  - pattern-not: |
      <$EL style={{$X:...}} />
  - pattern-not: |
      $R.createElement($EL, {style: {...}}, ...)
  message: |
    User controlled data in a `style` attribute is an anti-pattern that can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-css-injection.react-css-injection
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml
  pattern-either:
  - pattern: |
      <$X dangerouslySetInnerHTML=... />
  - pattern: |
      {dangerouslySetInnerHTML: ...}
  message: "Setting HTML from code is risky because it\u2019s easy to inadvertently
    expose your users to a cross-site scripting (XSS) attack.\n"
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-href-var.react-href-var
  pattern-either:
  - patterns:
    - pattern: |
        <$EL href=... />
    - pattern-not: |
        <$EL href="..." />
  - patterns:
    - pattern: |
        <Link to=... />
    - pattern-not: |
        <Link to="..." />
  - patterns:
    - pattern: |
        React.createElement($EL, {href: ...})
    - pattern-not: |
        React.createElement($EL, {href: "..."})
  - patterns:
    - pattern: |
        $PARAMS = {href: ...};
    - pattern-not: |
        $PARAMS = {href: "..."};
    - pattern-inside: |
        ...
        React.createElement($EL, $PARAMS);
  message: Detected a variable used in an anchor tag with the 'href' attribute. A
    malicious actor may be able to input the 'javascript:' URI, which could cause
    cross-site scripting (XSS). If you are generating a URL to a known host, hardcode
    the base link (or retrieve it from a configuration) and append the path. You may
    also consider funneling link generation through a safe method which sanitizes
    URLs for the 'javascript:' URI.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://reactjs.org/blog/2019/08/08/react-v16.9.0.html#deprecating-javascript-urls
    - https://pragmaticwebsecurity.com/articles/spasecurity/react-xss-part1.html
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-href-var.react-href-var
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-html-element-spreading.react-html-element-spreading
  patterns:
  - pattern: |
      <$EL {...$PROPS} />
  - metavariable-regex:
      metavariable: $EL
      regex: '[a-z]([a-zA-Z])*'
  message: |
    It is a good practice to avoid spreading for JSX attributes. This prevents accidentally
    passing `dangerouslySetInnerHTML` to an element.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-html-element-spreading.react-html-element-spreading
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-http-leak.react-http-leak
  pattern-either:
  - patterns:
    - pattern: |
        <$EL codebase=... />
    - metavariable-regex:
        metavariable: $EL
        regex: applet|object
    - pattern-not: |
        <$EL codebase="..." />
  - patterns:
    - pattern: |
        <$EL cite=... />
    - metavariable-regex:
        metavariable: $EL
        regex: blockquote|del|ins|q
    - pattern-not: |
        <$EL cite="..." />
  - patterns:
    - pattern: |
        <$EL longdesc=... />
    - metavariable-regex:
        metavariable: $EL
        regex: frame|iframe|img
    - pattern-not: |
        <$EL longdesc="..." />
  - patterns:
    - pattern: |
        <$EL src={$INJECT} />
    - metavariable-regex:
        metavariable: $EL
        regex: frame|iframe|img|input|script|audio|source|track|embed|video
    - pattern-not: |
        <$EL src="..." />
    - pattern-not-inside: |
        import $INJECT from "...";
        ...
  - patterns:
    - pattern: |
        <$EL usemap=... />
    - metavariable-regex:
        metavariable: $EL
        regex: img|input|object
    - pattern-not: |
        <$EL usemap="..." />
  - patterns:
    - pattern: |
        <$EL formaction=... />
    - metavariable-regex:
        metavariable: $EL
        regex: button|input
    - pattern-not: |
        <$EL formaction="..." />
  - patterns:
    - pattern: |
        <$EL srcset=... />
    - metavariable-regex:
        metavariable: $EL
        regex: img|source
    - pattern-not: |
        <$EL srcset="..." />
  - patterns:
    - pattern: |
        <$EL archive=... />
    - metavariable-regex:
        metavariable: $EL
        regex: object|applet
    - pattern-not: |
        <$EL archive="..." />
  - patterns:
    - pattern: |
        <body background=... />
    - pattern-not: |
        <body background="..." />
  - patterns:
    - pattern: |
        <form action=... />
    - pattern-not: |
        <form action="..." />
  - patterns:
    - pattern: |
        <head profile=... />
    - pattern-not: |
        <head profile="..." />
  - patterns:
    - pattern: |
        <object $ATTR=... />
    - metavariable-regex:
        metavariable: $ATTR
        regex: classid|data
    - pattern-not: |
        <object $ATTR="..." />
  - patterns:
    - pattern: |
        <video poster=... />
    - pattern-not: |
        <video poster="..." />
  - patterns:
    - pattern: |
        <command icon=... />
    - pattern-not: |
        <command icon="..." />
  - patterns:
    - pattern: |
        <html manifest=... />
    - pattern-not: |
        <html manifest="..." />
  - patterns:
    - pattern: |
        <meta content=... />
    - pattern-not: |
        <meta content="..." />
  message: This HTML element '$EL' and attribute '$ATTR' together may load an external
    resource. This means that if dynamic content can enter this attribute it may be
    possible for an attacker to send HTTP requests to unintended locations which may
    leak data about your users. If this element is reaching out to a known host, consider
    hardcoding the host (or loading from a configuration) and appending the dynamic
    path. See https://github.com/cure53/HTTPLeaks for more information.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    references:
    - https://github.com/cure53/HTTPLeaks
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-http-leak.react-http-leak
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-missing-noopener.react-missing-noopener
  pattern-either:
  - patterns:
    - pattern: |
        <$X target="_blank" />
    - pattern-not: |
        <$X target="_blank" rel="..." />
  - patterns:
    - pattern-inside: |
        <$X target="_blank" rel=... />
    - pattern-regex: rel=["']((?!noopener).)*?["']
  - patterns:
    - pattern: |
        React.createElement($A, {target: '_blank'},...)
    - pattern-not: |
        React.createElement($A, {rel: '...'},...)
  - patterns:
    - pattern: |
        React.createElement($A, {target: '_blank', rel: $REL},...)
    - metavariable-regex:
        metavariable: $REL
        regex: '["'']((?!noopener).)*?[''"]'
  - patterns:
    - pattern: |
        $P = {target: '_blank'};
        ...
        React.createElement($A, $P,...);
    - pattern-not: |
        $P = {rel: '...'};
        ...
        React.createElement($A, $P,...);
  - patterns:
    - pattern: |
        $P = {target: '_blank', rel: $REL};
        ...
        React.createElement($A, $P,...);
    - metavariable-regex:
        metavariable: $REL
        regex: '["'']((?!noopener).)*?[''"]'
  message: |
    Missing 'noopener' on an anchor tag where target='_blank'. This could introduce
    a reverse tabnabbing vulnerability. Include 'noopener' when using target='_blank'.
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://html.spec.whatwg.org/multipage/links.html#link-type-noreferrer
    - https://web.dev/external-anchors-use-rel-noopener/
    - https://owasp.org/www-community/attacks/Reverse_Tabnabbing
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-missing-noopener.react-missing-noopener
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-missing-noreferrer.react-missing-noreferrer
  pattern-either:
  - patterns:
    - pattern: |
        <$X target="_blank" />
    - pattern-not: |
        <$X target="_blank" rel="..." />
    - pattern-not: |
        <$X href="=~/^\/[^\/]/i" />
    - pattern-not: |
        <$X to="=~/^\/[^\/]/i" />
  - patterns:
    - pattern-inside: |
        <$X target="_blank" rel=... />
    - pattern-not-inside: |
        <$X href="=~/^\/[^\/]/i" rel=... />
    - pattern-not-inside: |
        <$X to="=~/^\/[^\/]/i" rel=... />
    - pattern-regex: rel=["']((?!noreferrer).)*?["']
  - patterns:
    - pattern: |
        React.createElement($A, {target: '_blank'},...)
    - pattern-not: |
        React.createElement($A, {rel: '...'},...)
    - pattern-not: |
        React.createElement($A, {href: '=~/^\/[^\/]/i'},...)
  - patterns:
    - pattern: |
        React.createElement($A, {target: '_blank', rel: $REL},...)
    - pattern-not: |
        React.createElement($A, {href: '=~/^\/[^\/]/i'},...)
    - metavariable-regex:
        metavariable: $REL
        regex: '["'']((?!noreferrer).)*?[''"]'
  - patterns:
    - pattern: |
        $P = {target: '_blank'};
        ...
        React.createElement($A, $P,...);
    - pattern-not: |
        $P = {rel: '...'};
        ...
        React.createElement($A, $P,...);
    - pattern-not: |
        $P = {href: '=~/^\/[^\/]/i'};
        ...
        React.createElement($A, $P,...);
  - patterns:
    - pattern: |
        $P = {target: '_blank', rel: $REL};
        ...
        React.createElement($A, $P,...);
    - pattern-not: |
        $P = {href: '=~/^\/[^\/]/i'};
        ...
        React.createElement($A, $P,...);
    - metavariable-regex:
        metavariable: $REL
        regex: '["'']((?!noreferrer).)*?[''"]'
  message: |
    This anchor tag with 'target="_blank"' is missing 'noreferrer'.
    A page opened with 'target="_blank"' can access the window object of the origin page.
    This means it can manipulate the 'window.opener' property, which could redirect the origin page to a malicious URL.
    This is called reverse tabnabbing. To prevent this, include 'rel=noreferrer' on this tag.
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://web.dev/external-anchors-use-rel-noopener/
    - https://html.spec.whatwg.org/multipage/links.html#link-type-noreferrer
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-missing-noreferrer.react-missing-noreferrer
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-no-refs.react-no-refs
  pattern-either:
  - pattern: <$EL ref=... />
  - pattern: $REACT.createRef(...)
  - pattern: $REACT.useRef(...)
  - pattern: createRef(...)
  - pattern: useRef(...)
  message: |
    `ref` usage found, refs give direct DOM access and may create a possibility for XSS
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-no-refs.react-no-refs
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-props-injection.react-props-injection
  patterns:
  - pattern-either:
    - pattern-inside: |
        import $PROPS from "...";
        ...
    - pattern-inside: |
        $PROPS = $METHOD(...);
        ...
    - pattern-inside: |
        function $FUNC(...,$PROPS,...) {
          ...
        }
  - pattern-either:
    - pattern: |
        <$EL {...<... $PROPS ...>} />
    - pattern: |
        <$EL {...$F(<... $PROPS ...>)} />
    - pattern: |
        React.createElement($EL, <... $PROPS ...>)
    - pattern: |
        React.createElement($EL, $F(<... $PROPS ...>))
  message: |
    Inject arbitrary props into the new element. It may introduce an XSS vulnerability.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://medium.com/dailyjs/exploiting-script-injection-flaws-in-reactjs-883fb1fe36c1
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-props-injection.react-props-injection
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-styled-components-injection.react-styled-components-injection
  patterns:
  - pattern-inside: |
      import styled from 'styled-components';
      ...
  - pattern-not-inside: |
      import { keyframes } from 'styled-components';
      ...
      $STYLE = keyframes(...);
      ...
  - pattern-either:
    - pattern-inside: |
        $STYLE = $METHOD(...);
        ...
    - pattern-inside: |
        function $FUNC(...,{$STYLE},...) {
          ...
        }
    - pattern-inside: |
        function $FUNC(...,$STYLE,...) {
          ...
        }
    - pattern-inside: |
        function $FUNC(...,{$INPUT},...) {
          ...
          $STYLE = <... $INPUT ...>;
          ...
        }
    - pattern-inside: |
        function $FUNC(...,$INPUT,...) {
          ...
          $STYLE = <... $INPUT ...>;
          ...
        }
  - pattern: |
      styled.$EL`...${$STYLE}...`
  message: |
    User controlled data in a styled component's css is an anti-pattern that can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://styled-components.com/docs/advanced#security
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-styled-components-injection.react-styled-components-injection
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-unsanitized-method.react-unsanitized-method
  patterns:
  - pattern-either:
    - pattern: $EL.insertAdjacentHTML($P, ...)
    - pattern: document.write(...)
    - pattern: document.writeln(...)
  - pattern-not: $EL.insertAdjacentHTML($P, "...")
  - pattern-not: document.write("...")
  - pattern-not: document.writeln("...")
  message: |
    User controlled data in a insertAdjacentHTML, document.write or document.writeln is an anti-pattern that can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-unsanitized-method.react-unsanitized-method
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-unsanitized-property.react-unsanitized-property
  patterns:
  - pattern-either:
    - pattern: |
        $X.innerHTML = ...;
    - pattern: |
        $X.outerHTML = ...;
  - pattern-not: |
      $X.innerHTML = "...";
  - pattern-not: |
      $X.outerHTML = "...";
  message: |
    User controlled data in a `$X` is an anti-pattern that can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.audit.react-unsanitized-property.react-unsanitized-property
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.react-insecure-request.react-insecure-request
  message: |
    Unencrypted request over HTTP detected.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://www.npmjs.com/package/axios
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.react-insecure-request.react-insecure-request
  languages:
  - typescript
  - javascript
  severity: ERROR
  pattern-either:
  - patterns:
    - pattern-either:
      - pattern-inside: |
          import $AXIOS from 'axios';
          ...
          $AXIOS.$METHOD(...)
      - pattern-inside: |
          $AXIOS = require('axios');
          ...
          $AXIOS.$METHOD(...)
    - pattern-either:
      - pattern: $AXIOS.get("=~/[Hh][Tt][Tt][Pp]:\/\/.*/",...)
      - pattern: $AXIOS.post("=~/[Hh][Tt][Tt][Pp]:\/\/.*/",...)
      - pattern: $AXIOS.delete("=~/[Hh][Tt][Tt][Pp]:\/\/.*/",...)
      - pattern: $AXIOS.head("=~/[Hh][Tt][Tt][Pp]:\/\/.*/",...)
      - pattern: $AXIOS.patch("=~/[Hh][Tt][Tt][Pp]:\/\/.*/",...)
      - pattern: $AXIOS.put("=~/[Hh][Tt][Tt][Pp]:\/\/.*/",...)
      - pattern: $AXIOS.options("=~/[Hh][Tt][Tt][Pp]:\/\/.*/",...)
  - patterns:
    - pattern-either:
      - pattern-inside: |
          import $AXIOS from 'axios';
          ...
          $AXIOS(...)
      - pattern-inside: |
          $AXIOS = require('axios');
          ...
          $AXIOS(...)
    - pattern-either:
      - pattern: '$AXIOS({url: "=~/[Hh][Tt][Tt][Pp]:\/\/.*/"}, ...)'
      - pattern: |
          $OPTS = {url: "=~/[Hh][Tt][Tt][Pp]:\/\/.*/"}
          ...
          $AXIOS($OPTS, ...)
  - pattern: fetch("=~/[Hh][Tt][Tt][Pp]:\/\/.*/", ...)
- id: typescript.react.security.react-markdown-insecure-html.react-markdown-insecure-html
  patterns:
  - pattern-either:
    - pattern-inside: |
        $X = require('react-markdown/with-html');
        ...
    - pattern-inside: |
        $X = require('react-markdown');
        ...
    - pattern-inside: |
        import 'react-markdown/with-html';
        ...
    - pattern-inside: |
        import 'react-markdown';
        ...
  - pattern-either:
    - pattern: |
        <$EL allowDangerousHtml />
    - pattern: |
        <$EL transformLinkUri=... />
    - pattern: |
        <$EL transformImageUri=... />
  message: |
    Overwriting `transformLinkUri` or `transformImageUri` to something insecure or turning `allowDangerousHtml` on, will open code up to XSS vectors.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://www.npmjs.com/package/react-markdown#security
    category: security
    technology:
    - react
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    source: https://semgrep.dev/r/typescript.react.security.react-markdown-insecure-html.react-markdown-insecure-html
  languages:
  - typescript
  - javascript
  severity: WARNING
